(this, transaction, {\n    ...getDefaultSamplingContext(transactionContext),\n    ...customSamplingContext,\n  });\n}\n\n/**\n * Create new idle transaction.\n */\nexport function startIdleTransaction(\n  hub: Hub,\n  transactionContext: TransactionContext,\n  idleTimeout?: number,\n  onScope?: boolean,\n): IdleTransaction {\n  const transaction = new IdleTransaction(transactionContext, hub, idleTimeout, onScope);\n  return sample(hub, transaction, getDefaultSamplingContext(transactionContext));\n}\n\n/**\n * @private\n */\nexport function _addTracingExtensions(): void {\n  const carrier = getMainCarrier();\n  if (carrier.__SENTRY__) {\n    carrier.__SENTRY__.extensions = carrier.__SENTRY__.extensions || {};\n    if (!carrier.__SENTRY__.extensions.startTransaction) {\n      carrier.__SENTRY__.extensions.startTransaction = _startTransaction;\n    }\n    if (!carrier.__SENTRY__.extensions.traceHeaders) {\n      carrier.__SENTRY__.extensions.traceHeaders = traceHeaders;\n    }\n  }\n}\n\n/**\n * This patches the global object and injects the Tracing extensions methods\n */\nexport function addExtensionMethods(): void {\n  _addTracingExtensions();\n\n  // If an error happens globally, we should make sure transaction status is set to error.\n  registerErrorInstrumentation();\n}\n"]}import { Hub } from '@sentry/hub';
import { TransactionContext } from '@sentry/types';
import { Span, SpanRecorder } from './span';
import { Transaction } from './transaction';
export declare const DEFAULT_IDLE_TIMEOUT = 1000;
/**
 * @inheritDoc
 */
export declare class IdleTransactionSpanRecorder extends SpanRecorder {
    private readonly _pushActivity;
    private readonly _popActivity;
    transactionSpanId: string;
    constructor(_pushActivity: (id: string) => void, _popActivity: (id: string) => void, transactionSpanId?: string, maxlen?: number);
    /**
     * @inheritDoc
     */
    add(span: Span): void;
}
export declare type BeforeFinishCallback = (transactionSpan: IdleTransaction, endTimestamp: number) => void;
/**
 * An IdleTransaction is a transaction that automatically finishes. It does this by tracking child spans as activities.
 * You can have multiple IdleTransactions active, but if the `onScope` option is specified, the idle transaction will
 * put itself on the scope on creation.
 */
export declare class IdleTransaction extends Transaction {
    private readonly _idleHub?;
    private readonly _idleTimeout;
    private readonly _onScope;
    activities: Record<string, boolean>;
    private _heartbeatTimer;
    private _prevHeartbeatString;
    private _heartbeatCounter;
    private _finished;
    private readonly _beforeFinishCallbacks;
    private _initTimeout;
    constructor(transactionContext: TransactionContext, _idleHub?: Hub | undefined, _idleTimeout?: number, _onScope?: boolean);
    /** {@inheritDoc} */
    finish(endTimestamp?: number): string | undefined;
    /**
     * Register a callback function that gets excecuted before the transaction finishes.
     * Useful for cleanup or if you want to add any additional spans based on current context.
     *
     * This is exposed because users have no other way of running something before an idle transacti