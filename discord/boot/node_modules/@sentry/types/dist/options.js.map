go package */
export declare class Mongo implements Integration {
    /**
     * @inheritDoc
     */
    static id: string;
    /**
     * @inheritDoc
     */
    name: string;
    private _operations;
    private _describeOperations?;
    /**
     * @inheritDoc
     */
    constructor(options?: MongoOptions);
    /**
     * @inheritDoc
     */
    setupOnce(_: (callback: EventProcessor) => void, getCurrentHub: () => Hub): void;
    /**
     * Patches original collection methods
     */
    private _instrumentOperations;
    /**
     * Patches original collection to utilize our tracing functionality
     */
    private _patchOperation;
    /**
     * Form a SpanContext based on the user input to a given operation.
     */
    private _getSpanContextFromOperationArguments;
}
export {};
//# sourceMappingURL=mongo.d.ts.map{"version":3,"file":"mongo.d.ts","sourceRoot":"","sources":["../../src/integrations/mongo.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,GAAG,EAAE,MAAM,aAAa,CAAC;AAClC,OAAO,EAAE,cAAc,EAAE,WAAW,EAAe,MAAM,eAAe,CAAC;AAMzE,aAAK,SAAS,GAAG,OAAO,UAAU,CAAC,MAAM,CAAC,CAAC;AAC3C,QAAA,MAAM,UAAU,keAgCN,CAAC;AA0CX,UAAU,YAAY;IACpB,UAAU,CAAC,EAAE,SAAS,EAAE,CAAC;IACzB,kBAAkB,CAAC,EAAE,OAAO,GAAG,SAAS,EAAE,CAAC;CAC5C;AAED,4CAA4C;AAC5C,qBAAa,KAAM,YAAW,WAAW;IACvC;;OAEG;IACH,OAAc,EAAE,EAAE,MAAM,CAAW;IAEnC;;OAEG;IACI,IAAI,EAAE,MAAM,CAAY;IAE/B,OAAO,CAAC,WAAW,CAAc;IACjC,OAAO,CAAC,mBAAmB,CAAC,CAAwB;IAEpD;;OAEG;gBACgB,OAAO,GAAE,YAAiB;IAO7C;;OAEG;IACI,SAAS,CAAC,CAAC,EAAE,CAAC,QAAQ,EAAE,cAAc,KAAK,IAAI,EAAE,aAAa,EAAE,MAAM,GAAG,GAAG,IAAI;IAcvF;;OAEG;IACH,OAAO,CAAC,qBAAqB;IAI7B;;OAEG;IACH,OAAO,CAAC,eAAe;IAqCvB;;OAEG;IACH,OAAO,CAAC,qCAAqC;CA4C9C"}import { __read, __spread } from "tslib";
import { dynamicRequire, fill, isThenable, logger } from '@sentry/utils';
var OPERATIONS = [
    'aggregate',
    'bulkWrite',
    'countDocuments',
    'createIndex',
    'createIndexes',
    'deleteMany',
    'deleteOne',
    'distinct',
    'drop',
    'dropIndex',
    'dropIndexes',
    'estimatedDocumentCount',
    'findOne',
    'findOneAndDelete',
    'findOneAndReplace',
    'findOneAndUpdate',
    'indexes',
    'indexExists',
    'indexInformation',
    'initializeOrderedBulkOp',
    'insertMany',
    'insertOne',
    'isCapped',
    'mapReduce',
    'options',
    'parallelCollectionScan',
    'rename',
    'replaceOne',
    'stats',
    'updateMany',
    'updateOne',
];
// All of the operations above take `options` and `callback` as their final parameters, but some of them
// take additional parameters as well. For those operations, this is a map of
// { <operation name>:  [<names of additional parameters>] }, as a way to know what to call the operation's
// positional arguments when we add them to the span's `data` object later
var OPERATION_SIGNATURES = {
    // aggregate intentionally not included because `pipeline` arguments are too complex to serialize well
    // see https://github.com/getsentry/sentry-javascript/pull/3102
    bulkWrite: ['operations'],
    countDocuments: ['query'],
    createIndex: ['fieldOrSpec'],
    createIndexes: ['indexSpecs'],
    deleteMany: ['filter'],
    deleteOne: ['filter'],
    distinct: ['key', 'query'],
    dropIndex: ['indexName'],
    findOne: ['query'],
    findOneAndDelete: ['filter'],
    findOneAndReplace: ['filter', 'replacement'],
    findOneAndUpdate: ['filter', 'update'],
    indexExists: ['indexes'],
    insertMany: ['docs'],
    insertOne: ['doc'],
    mapReduce: ['map', 'reduce'],
    rename: ['newName'],
    replaceOne: ['filter', 'doc'],
    updateMany: ['filter', 'update'],
    updateOne: ['filter', 'update'],
};
/** Tracing integration for mongo package */
var Mongo = /** @class */ (function () {
    /**
     * @inheritDoc
     */
    function Mongo(options) {
        if (options === void 0) { options = {}; }
        /**
         * @inheritDoc
         */
        this.name = Mongo.id;
        this._operations = Array.isArray(options.operations)
            ? options.operations
            : OPERATIONS;
        this._describeOperations = 'describeOperations' in options ? options.describeOperations : true;
    }
    /**
     * @inheritDoc
     */
    Mongo.prototype.setupOnce = function (_, getCurrentHub) {
        var collection;
        try {
            var mongodbModule = dynamicRequire(module, 'mongodb');
            collection = mongodbModule.Collection;
        }
        catch (e) {
            logger.error('Mongo Integration was unable to require `mongodb` package.');
            return;
        }
        this._instrumentOperations(collection, this._operations, getCurrentHub);
    };
    /**
     * Patches original collection methods
     */
    Mongo.prototype._instrumentOperations = function (collection, operations, getCurrentHub) {
        var _this = this;
        operations.forEach(function (operation) { return _this._patchOperation(collection, operation, getCurrentHub); });
    };
    /**
     * Patches original collection to utilize our tracing functionality
     */
    Mongo.prototype._patchOperation = function (collection, operation, getCurrentHub) {
        if (!(operation in collection.prototype))
            return;
        var getSpanContext = this._getSpanContextFromOperationArguments.bind(this);
        fill(collection.prototype, operation, function (orig) {
            return function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                var _a, _b, _c, _d;
                var lastArg = args[args.length - 1];
                var scope = getCurrentHub().getScope();
                var parentSpan = (_a = scope) === null || _a === void 0 ? void 0 : _a.getSpan();
                // Check if the operation was passed a callback. (mapReduce requires a different check, as
                // its (non-callback) arguments can also be functions.)
                if (typeof lastArg !== 'function' || (operation === 'mapReduce' && args.length === 2)) {
                    var span_1 = (_b = parentSpan) === null || _b === void 0 ? void 0 : _b.startChild(getSpanContext(this, operation, args));
                    var maybePromise = orig.call.apply(orig, __spread([this], args));
                    if (isThenable(maybePromise)) {
                        return maybePromise.then(function (res) {
                            var 