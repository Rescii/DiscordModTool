-> decision so that we don't have to compute\n  // regexp everytime we create a request.\n  const urlMap: Record<string, boolean> = {};\n\n  const defaultShouldCreateSpan = (url: string): boolean => {\n    if (urlMap[url]) {\n      return urlMap[url];\n    }\n    const origins = tracingOrigins;\n    urlMap[url] =\n      origins.some((origin: string | RegExp) => isMatchingPattern(url, origin)) &&\n      !isMatchingPattern(url, 'sentry_key');\n    return urlMap[url];\n  };\n\n  // We want that our users don't have to re-implement shouldCreateSpanForRequest themselves\n  // That's why we filter out already unwanted Spans from tracingOrigins\n  let shouldCreateSpan = defaultShouldCreateSpan;\n  if (typeof shouldCreateSpanForRequest === 'function') {\n    shouldCreateSpan = (url: string) => {\n      return defaultShouldCreateSpan(url) && shouldCreateSpanForRequest(url);\n    };\n  }\n\n  const spans: Record<string, Span> = {};\n\n  if (traceFetch) {\n    addInstrumentationHandler({\n      callback: (handlerData: FetchData) => {\n        fetchCallback(handlerData, shouldCreateSpan, spans);\n      },\n      type: 'fetch',\n    });\n  }\n\n  if (traceXHR) {\n    addInstrumentationHandler({\n      callback: (handlerData: XHRData) => {\n        xhrCallback(handlerData, shouldCreateSpan, spans);\n      },\n      type: 'xhr',\n    });\n  }\n}\n\n/**\n * Create and track fetch request spans\n */\nexport function fetchCallback(\n  handlerData: FetchData,\n  shouldCreateSpan: (url: string) => boolean,\n  spans: Record<string, Span>,\n): void {\n  const currentClientOptions = getCurrentHub()\n    .getClient()\n    ?.getOptions();\n  if (\n    !(currentClientOptions && hasTracingEnabled(currentClientOptions)) ||\n    !(handlerData.fetchData && shouldCreateSpan(handlerData.fetchData.url))\n  ) {\n    return;\n  }\n\n  if (handlerData.endTimestamp && handlerData.fetchData.__span) {\n    const span = spans[handlerData.fetchData.__span];\n    if (span) {\n      const response = handlerData.response;\n      if (response) {\n        // TODO (kmclb) remove this once types PR goes through\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        span.setHttpStatus(response.status);\n      }\n      span.finish();\n\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete spans[handlerData.fetchData.__span];\n    }\n    return;\n  }\n\n  const activeTransaction = getActiveTransaction();\n  if (activeTransaction) {\n    const span = activeTransaction.startChild({\n      data: {\n        ...handlerData.fetchData,\n        type: 'fetch',\n      },\n      description: `${handlerData.fetchData.method} ${handlerData.fetchData.url}`,\n      op: 'http',\n    });\n\n    handlerData.fetchData.__span = span.spanId;\n    spans[span.spanId] = span;\n\n    const request = (handlerData.args[0] = handlerData.args[0] as string | Request);\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const options = (handlerData.args[1] = (handlerData.args[1] as { [key: string]: any }) || {});\n    let headers = options.headers;\n    if (isInstanceOf(request, Request)) {\n      headers = (request as Request).headers;\n    }\n    if (headers) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      if (typeof headers.append === 'function') {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        headers.append('sentry-trace', span.toTraceparent());\n      } else if (Array.isArray(headers)) {\n        headers = [...headers, ['sentry-trace', span.toTraceparent()]];\n      } else {\n        headers = { ...headers, 'sentry-trace': span.toTraceparent() };\n      }\n    } else {\n      headers = { 'sentry-trace': span.toTraceparent() };\n    }\n    options.headers = headers;\n  }\n}\n\n/**\n * Create and track xhr request spans\n */\nexport function xhrCallback(\n  handlerData: XHRData,\n  shouldCreateSpan: (url: string) => boolean,\n  spans: Record<string, Span>,\n): void {\n  const currentClientOptions = getCurrentHub()\n    .getClient()\n    ?.getOptions();\n  if (\n    !(currentClientOptions && hasTracingEnabled(currentClientOptions)) ||\n    !(handlerData.xhr && handlerData.xhr.__sentry_xhr__ && shouldCreateSpan(handlerData.xhr.__sentry_xhr__.url)) ||\n    handlerData.xhr.__sentry_own_request__\n  ) {\n    return;\n  }\n\n  const xhr = handlerData.xhr.__sentry_xhr__;\n\n  // check first if the request has finished and is tracked by an existing span which should now end\n  if (handlerData.endTimestamp && handlerData.xhr.__sentry_xhr_span_id__) {\n    const span = spans[handlerData.xhr.__sentry_xhr_span_id__];\n    if (span) {\n      span.setHttpStatus(xhr.status_code);\n      span.finish();\n\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete spans[handlerData.xhr.__sentry_xhr_span_id__];\n    }\n    return;\n  }\n\n  // if not, create a new span to track it\n  const activeTransaction = getActiveTransaction();\n  if (activeTransaction) {\n    const span = activeTransaction.startChild({\n      data: {\n        ...xhr.data,\n        type: 'xhr',\n        method: xhr.method,\n        url: xhr.url,\n      },\n      description: `${xhr.method} ${xhr.url}`,\n      op: 'http',\n    });\n\n    handlerData.xhr.__sentry_xhr_span_id__ = span.spanId;\n    spans[handlerData.xhr.__sentry_xhr_span_id__] = span;\n\n    if (handlerData.xhr.setRequestHeader) {\n      try {\n        handlerData.xhr.setRequestHeader('sentry-trace', span.toTraceparent());\n      } catch (_) {\n        // Error: InvalidStateError: Failed to execute 'setRequestHeader' on 'XMLHttpRequest': The object's state must be OPENED.\n      }\n    }\n  }\n}\n"]}import { Transaction, TransactionContext } from '@sentry/types';
/**
 * Default function implementing pageload and navigation transactions
 */
export declare function defaultRoutingInstrumentation<T extends Transaction>(startTransaction: (context: TransactionContext) => T | undefined, startTransactionOnPageLoad?: boolean, startTransactionOnLocationChange?: boolean): void;
//# sourceMappingURL=router.d.ts.map{"version":3,"file":"router.d.ts","sourceRoot":"","sources":["../../src/browser/router.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,WAAW,EAAE,kBAAkB,EAAE,MAAM,eAAe,CAAC;AAKhE;;GAEG;AACH,wBAAgB,6BAA6B,CAAC,CAAC,SAAS,WAAW,EACjE,gBAAgB,EAAE,CAAC,OAAO,EAAE,kBAAkB,KAAK,CAAC,GAAG,SAAS,EAChE,0BAA0B,GAAE,OAAc,EAC1C,gCAAgC,GAAE,OAAc,GAC/C,IAAI,CA2CN"}import { addInstrumentationHandler, getGlobalObject, logger } from '@sentry/utils';
var global = getGlobalObject();
/**
 * Default function implementing pageload and navigation transactions
 */
export function defaultRoutingInstrumentation(startTransaction, startTransactionOnPageLoad, startTransactionOnLocationChange) {
    if (startTransactionOnPageLoad === void 0) { startTransactionOnPageLoad = true; }
    if (startTransactionOnLocationChange === void 0) { startTransactionOnLocationChange = true; }
    if (!global || !global.location) {
        logger.warn('Could not initialize routing instrumentation due to invalid location');
        return;
    }
    var startingUrl = global.location.href;
    var activeTransaction;
    if (startTransactionOnPageLoad) {
        activeTransaction = startTransaction({ name: global.location.pathname, op: 'pageload' });
    }
    if (startTransactionOnLocationChange) {
        addInstrumentationHandler({
            callback: function (_a) {
                var to = _a.to, from = _a.from;
                /**
                 * This early return is there to account for some cases where a navigation transaction starts right after
                 * long-running pageload. We make sure that if `from` is undefined and a valid `startingURL` exists, we don't
                 * create an uneccessary navigation transaction.
                 *
                 * This was hard to duplicate, but this behavior stopped as soon as this fix was applied. This issue might also
                 * only be caused in certain development environments where the usage of a hot module reloader is causing
                 * errors.
                 */
                if (from === undefined && startingUrl && startingUrl.indexOf(to) !== -1) {
                    startingUrl = undefined;
                    return;
                }
                if (from !== to) {
                    startingUrl = undefined;
                    if (activeTransaction) {
                        logger.log("[Tracing] Finishing current transaction with op: " + activeTransaction.op);
                        // If there's an open transaction on the scope, we need to finish it before creating an new one.
                        activeTransaction.finish();
                    }
                    activeTransaction = startTransaction({ name: global.location.pathname, op: 'navigation' });
                }
            },
            type: 'history',
        });
    }
}
//# sourceMappingURL=router.js.map{"version":3,"file":"router.js","sourceRoot":"","sources":["../../src/browser/router.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,yBAAyB,EAAE,eAAe,EAAE,MAAM,EAAE,MAAM,eAAe,CAAC;AAEnF,IAAM,MAAM,GAAG,eAAe,EAAU,CAAC;AAEzC;;GAEG;AACH,MAAM,UAAU,6BAA6B,CAC3C,gBAAgE,EAChE,0BAA0C,EAC1C,gCAAgD;IADhD,2CAAA,EAAA,iCAA0C;IAC1C,iDAAA,EAAA,uCAAgD;IAEhD,IAAI,CAAC,MAAM,IAAI,CAAC,MAAM,CAAC,QAAQ,EAAE;QAC/B,MAAM,CAAC,IAAI,CAAC,sEAAsE,CAAC,CAAC;QACpF,OAAO;KACR;IAED,IAAI,WAAW,GAAuB,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC;IAE3D,IAAI,iBAAgC,CAAC;IACrC,IAAI,0BAA0B,EAAE;QAC9B,iBAAiB,GAAG,gBAAgB,CAAC,EAAE,IAAI,EAAE,MAAM,CAAC,QAAQ,CAAC,QAAQ,EAAE,EAAE,EAAE,UAAU,EAAE,CAAC,CAAC;KAC1F;IAED,IAAI,gCAAgC,EAAE;QACpC,yBAAyB,CAAC;YACxB,QAAQ,EAAE,UAAC,EAA2C;oBAAzC,UAAE,EAAE,cAAI;gBACnB;;;;;;;;mBAQG;gBACH,IAAI,IAAI,KAAK,SAAS,IAAI,WAAW,IAAI,WAAW,CAAC,OAAO,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,EAAE;oBACvE,WAAW,GAAG,SAAS,CAAC;oBACxB,OAAO;iBACR;gBAED,IAAI,IAAI,KAAK,EAAE,EAAE;oBACf,WAAW,GAAG,SAAS,CAAC;oBACxB,IAAI,iBAAiB,EAAE;wBACrB,MAAM,CAAC,GAAG,CAAC,sDAAoD,iBAAiB,CAAC,EAAI,CAAC,CAAC;wBACvF,gGAAgG;wBAChG,iBAAiB,CAAC,MAAM,EAAE,CAAC;qBAC5B;oBACD,iBAAiB,GAAG,gBAAgB,CAAC,EAAE,IAAI,EAAE,MAAM,CAAC,QAAQ,CAAC,QAAQ,EAAE,EAAE,EAAE,YAAY,EAAE,CAAC,CAAC;iBAC5F;YACH,CAAC;YACD,IAAI,EAAE,SAAS;SAChB,CAAC,CAAC;KACJ;AACH,CAAC","sourcesContent":["import { Transaction, TransactionContext } from '@sentry/types';\nimport { addInstrumentationHandler, getGlobalObject, logger } from '@sentry/utils';\n\nconst global = getGlobalObject<Window>();\n\n/**\n * Default function implementing pageload and navigation transactions\n */\nexport function defaultRoutingInstrumentation<T extends Transaction>(\n  startTransaction: (context: TransactionContext) => T | undefined,\n  startTransactionOnPageLoad: boolean = true,\n  startTransactionOnLocationChange: boolean = true,\n): void {\n  if (!global || !global.location) {\n    logger.warn('Could not initialize routing instrumentation due to invalid location');\n    return;\n  }\n\n  let startingUrl: string | undefined = global.location.href;\n\n  let activeTransaction: T | undefined;\n  if (startTransactionOnPageLoad) {\n    activeTransaction = startTransaction({ name: global.location.pathname, op: 'pageload' });\n  }\n\n  if (startTransactionOnLocationChange) {\n    addInstrumentationHandler({\n      callback: ({ to, from }: { to: string; from?: string }) => {\n        /**\n         * This early return is there to account for some cases where a navigation transaction starts right after\n         * long-running pageload. We make sure that if `from` is undefined and a valid `startingURL` exists, we don't\n         * create an uneccessary navigation transaction.\n         *\n         * This was hard to duplicate, but this behavior stopped as soon as this fix was applied. This issue might also\n         * only be caused in certain development environments where the usage of a hot module reloader is causing\n         * errors.\n         */\n        if (from === undefined && startingUrl && startingUrl.indexOf(to) !== -1) {\n          startingUrl = undefined;\n          return;\n        }\n\n        if (from !== to) {\n          startingUrl = undefined;\n          if (activeTransaction) {\n            logger.log(`[Tracing] Finishing current transaction with op: ${activeTransaction.op}`);\n            // If there's an open transaction on the scope, we need to finish it before creating an new one.\n            activeTransaction.finish();\n          }\n          activeTransaction = startTransaction({ name: global.location.pathname, op: 'navigation' });\n        }\n      },\n      type: 'history',\n    });\n  }\n}\n"]}import { ReportHandler } from './types';
export declare const getCLS: (onReport: ReportHandler, reportAllChanges?: boolean) => void;
//# sourceMappingURL=getCLS.d.ts.map{"version":3,"file":"getCLS.d.ts","sourceRoot":"","sources":["../../../src/browser/web-vitals/getCLS.ts"],"names":[],"mappings":"AAoBA,OAAO,EAAE,aAAa,EAAE,MAAM,SAAS,CAAC;AAQxC,eAAO,MAAM,MAAM,+DA2BlB,CAAC"}/*
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the Lic