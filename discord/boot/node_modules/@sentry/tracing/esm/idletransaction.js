rn undefined;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    const { beforeNavigate, idleTimeout, maxTransactionDuration } = this.options;\n\n    const parentContextFromHeader = context.op === 'pageload' ? getHeaderContext() : undefined;\n\n    const expandedContext = {\n      ...context,\n      ...parentContextFromHeader,\n      trimEnd: true,\n    };\n    const modifiedContext = typeof beforeNavigate === 'function' ? beforeNavigate(expandedContext) : expandedContext;\n\n    // For backwards compatibility reasons, beforeNavigate can return undefined to \"drop\" the transaction (prevent it\n    // from being sent to Sentry).\n    const finalContext = modifiedContext === undefined ? { ...expandedContext, sampled: false } : modifiedContext;\n\n    if (finalContext.sampled === false) {\n      logger.log(`[Tracing] Will not send ${finalContext.op} transaction because of beforeNavigate.`);\n    }\n\n    const hub = this._getCurrentHub();\n    const idleTransaction = startIdleTransaction(hub, finalContext, idleTimeout, true);\n    logger.log(`[Tracing] Starting ${finalContext.op} transaction on scope`);\n    idleTransaction.registerBeforeFinishCallback((transaction, endTimestamp) => {\n      this._metrics.addPerformanceEntries(transaction);\n      adjustTransactionDuration(secToMs(maxTransactionDuration), transaction, endTimestamp);\n    });\n\n    return idleTransaction as Transaction;\n  }\n}\n\n/**\n * Gets transaction context from a sentry-trace meta.\n *\n * @returns Transaction context data from the header or undefined if there's no header or the header is malformed\n */\nexport function getHeaderContext(): Partial<TransactionContext> | undefined {\n  const header = getMetaContent('sentry-trace');\n  if (header) {\n    return extractTraceparentData(header);\n  }\n\n  return undefined;\n}\n\n/** Returns the value of a meta tag */\nexport function getMetaContent(metaName: string): string | null {\n  const el = document.querySelector(`meta[name=${metaName}]`);\n  return el ? el.getAttribute('content') : null;\n}\n\n/** Adjusts transaction value based on max transaction duration */\nfunction adjustTransactionDuration(maxDuration: number, transaction: IdleTransaction, endTimestamp: number): void {\n  const diff = endTimestamp - transaction.startTimestamp;\n  const isOutdatedTransaction = endTimestamp && (diff > maxDuration || diff < 0);\n  if (isOutdatedTransaction) {\n    transaction.setStatus(SpanStatus.DeadlineExceeded);\n    transaction.setTag('maxTransactionDurationExceeded', 'true');\n  }\n}\n"]}export { BrowserTracing } from './browsertracing';
export { registerRequestInstrumentation, RequestInstrumentationOptions, defaultRequestInstrumentationOptions, } from './request';
//# sourceMappingURL=index.d.ts.map{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../../src/browser/index.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,cAAc,EAAE,MAAM,kBAAkB,CAAC;AAClD,OAAO,EACL,8BAA8B,EAC9B,6BAA6B,EAC7B,oCAAoC,GACrC,MAAM,WAAW,CAAC"}export { BrowserTracing } from './browsertracing';
export { registerRequestInstrumentation, defaultRequestInstrumentationOptions, } from './request';
//# sourceMappingURL=index.js.map{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/browser/index.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,cAAc,EAAE,MAAM,kBAAkB,CAAC;AAClD,OAAO,EACL,8BAA8B,EAE9B,oCAAoC,GACrC,MAAM,WAAW,CAAC","sourcesContent":["export { BrowserTracing } from './browsertracing';\nexport {\n  registerRequestInstrumentation,\n  RequestInstrumentationOptions,\n  defaultRequestInstrumentationOptions,\n} from './request';\n"]}import { SpanContext } from '@sentry/types';
import { Span } from '../span';
import { Transaction } from '../transaction';
/** Class tracking metrics  */
export declare class MetricsInstrumentation {
    private _measurements;
    private _performanceCursor;
    constructor();
    /** Add performance related spans to a transaction */
    addPerformanceEntries(transaction: Transaction): void;
    /** Starts tracking the Cumulative Layout Shift on the current page. */
    private _trackCLS;
    /**
     * Capture the information of the user agent.
     */
    private _trackNavigator;
    /** Starts tracking the Largest Contentful Paint on the current page. */
    private _trackLCP;
    /** Starts tracking the First Input Delay on the current page. */
    private _trackFID;
    /** Starts tracking the Time to First Byte on the current page. */
    private _trackTTFB;
}
export interface ResourceEntry extends Record<string, unknown> {
    initiatorType?: string;
    transferSize?: number;
    encodedBodySize?: number;
    decodedBodySize?: number;
}
/** Create resource-related spans */
export declare function addResourceSpans(transaction: Transaction, entry: ResourceEntry, resourceName: string, startTime: number, duration: number, timeOrigin: number): number | undefined;
/**
 * Helper function to start child on transactions. This function will make sure that the transaction will
 * use the start timestamp of the created child span if it is earlier than the transactions actual
 * start timestamp.
 */
export declare function _startChild(transaction: Transaction, { startTimestamp, ...ctx }: SpanContext): Span;
//# sourceMappingURL=metrics.d.ts.map{"version":3,"file":"metrics.d.ts","sourceRoot":"","sources":["../../src/browser/metrics.ts"],"names":[],"mappings":"AAEA,OAAO,EAAgB,WAAW,EAAE,MAAM,eAAe,CAAC;AAG1D,OAAO,EAAE,IAAI,EAAE,MAAM,SAAS,CAAC;AAC/B,OAAO,EAAE,WAAW,EAAE,MAAM,gBAAgB,CAAC;AAW7C,8BAA8B;AAC9B,qBAAa,sBAAsB;IACjC,OAAO,CAAC,aAAa,CAAoB;IAEzC,OAAO,CAAC,kBAAkB,CAAa;;IAevC,qDAAqD;IAC9C,qBAAqB,CAAC,WAAW,EAAE,WAAW,GAAG,IAAI;IA0I5D,uEAAuE;IACvE,OAAO,CAAC,SAAS;IAajB;;OAEG;IACH,OAAO,CAAC,eAAe;IAqCvB,wEAAwE;IACxE,OAAO,CAAC,SAAS;IAgBjB,iEAAiE;IACjE,OAAO,CAAC,SAAS;IAgBjB,kEAAkE;IAClE,OAAO,CAAC,UAAU;CAgBnB;AAoCD,MAAM,WAAW,aAAc,SAAQ,MAAM,CAAC,MAAM,EAAE,OAAO,CAAC;IAC5D,aAAa,CAAC,EAAE,MAAM,CAAC;IACvB,YAAY,CAAC,EAAE,MAAM,CAAC;IACtB,eAAe,CAAC,EAAE,MAAM,CAAC;IACzB,eAAe,CAAC,EAAE,MAAM,CAAC;CAC1B;AAED,oCAAoC;AACpC,wBAAgB,gBAAgB,CAC9B,WAAW,EAAE,WAAW,EACxB,KAAK,EAAE,aAAa,EACpB,YAAY,EAAE,MAAM,EACpB,SAAS,EAAE,MAAM,EACjB,QAAQ,EAAE,MAAM,EAChB,UAAU,EAAE,MAAM,GACjB,MAAM,GAAG,SAAS,CA8BpB;AAwCD;;;;GAIG;AACH,wBAAgB,WAAW,CAAC,WAAW,EAAE,WAAW,EAAE,EAAE,cAAc,EAAE,GAAG,GAAG,EAAE,EAAE,WAAW,GAAG,IAAI,CASnG"}import { __assign, __rest } from "tslib";
import { browserPerformanceTimeOrigin, getGlobalObject, logger } from '@sentry/utils';
import { msToSec } from '../utils';
import { getCLS } from './web-vitals/getCLS';
import { getFID } from './web-vitals/getFID';
import { getLCP } from './web-vitals/getLCP';
import { getTTFB } from './web-vitals/getTTFB';
import { getFirstHidden } from './web-vitals/lib/getFirstHidden';
var global = getGlobalObject();
/** Class tracking metrics  */
var MetricsInstrumentation = /** @class */ (function () {
    function MetricsInstrumentation() {
        this._measurements = {};
        this._performanceCursor = 0;
        if (global && global.performance) {
            if (global.performance.mark) {
                global.performance.mark('sentry-tracing-init');
            }
            this._trackCLS();
            this._trackLCP();
            this._trackFID();
            this._trackTTFB();
        }
    }
    /** Add performance related spans to a transaction */
    MetricsInstrumentation.prototype.addPerformanceEntries = function (transaction) {
        var _this = this;
        if (!global || !global.performance || !global.performance.getEntries || !browserPerformanceTimeOrigin) {
            // Gatekeeper if performance API not available
            return;
        }
        logger.log('[Tracing] Adding & adjusting spans using Performance API');
        var timeOrigin = msToSec(browserPerformanceTimeOrigin);
        var entryScriptSrc;
        if (global.document) {
            // eslint-disable-next-line @typescript-eslint/prefer-for-of
            for (var i = 0; i < document.scripts.length; i++) {
                // We go through all scripts on the page and look for 'data-entry'
                // We remember the name and measure the time between this script finished loading and
                // our mark 'sentry-tracing-init'
                if (document.scripts[i].dataset.entry === 'true') {
                    entryScriptSrc = document.scripts[i].src;
                    break;
                }
            }
        }
        var entryScriptStartTimestamp;
        var tracingInitMarkStartTime;
        global.performance
            .getEntries()
            .slice(this._performanceCursor)
            .forEach(function (entry) {
            var startTime = msToSec(entry.startTime);
            var duration = msToSec(entry.duration);
            if (transaction.op === 'navigation' && timeOrigin + startTime < transaction.startTimestamp) {
                return;
            }
            switch (entry.entryType) {
                case 'navigation':
                    addNavigationSpans(transaction, entry, timeOrigin);
                    break;
                case 'mark':
                case 'paint':
                case 'measure': {
                    var startTimestamp = addMeasureSpans(transaction, entry, startTime, duration, timeOrigin);
                    if (tracingInitMarkStartTime === undefined && entry.name === 'sentry-tracing-init') {
                        tracingInitMarkStartTime = startTimestamp;
                    }
                    // capture web vitals
                    var firstHidden = getFirstHidden();
                    // Only report if the page wasn't hidden prior to the web vital.
                    var shouldRecord = entry.startTime < firstHidden.timeStamp;
                    if (entry.name === 'first-paint' && shouldRecord) {
                        logger.log('[Measurements] Adding FP');
                        _this._measurements['fp'] = { value: entry.startTime };
                        _this._measurements['mark.fp'] = { value: startTimestamp };
                    }
                    if (entry.name === 'first-contentful-paint' && shouldRecord) {
                        logger.log('[Measurements] Adding FCP');
                        _this._measurements['fcp'] = { value: entry.startTime };
                        _this._measurements['mark.fcp'] = { value: startTimestamp };
                    }
                    break;
                }
                case 'resource': {
                    var resourceName = entry.name.replace(window.location.origin, '');
                    var endTimestamp = addResourceSpans(transaction, entry, resourceName, startTime, duration, timeOrigin);
                    // We remember the entry script end time to calculate the difference to the first init mark
                    if (entryScriptStartTimestamp === undefined && (entryScriptSrc || '').indexOf(resourceName) > -1) {
                        entryScriptStartTimestamp = endTimestamp;
                    }
                    break;
                