,OAAO,CAAC,CAAC,CAAC;YACnB,aAAa,eAAA;YACb,YAAY,EAAE,OAAO,CAAC,CAAC,CAAC;SACzB,CAAC;KACH;IACD,OAAO,SAAS,CAAC;AACnB,CAAC;AAhBD,wDAgBC;AAED,iDAAiD;AACjD,SAAgB,oBAAoB,CAAwB,GAA0B;IAA1B,oBAAA,EAAA,MAAW,mBAAa,EAAE;;IACpF,OAAO,YAAA,GAAG,0CAAE,QAAQ,4CAAI,cAAc,EAAmB,CAAC;AAC5D,CAAC;AAFD,oDAEC;AAED;;;GAGG;AACH,SAAgB,OAAO,CAAC,IAAY;IAClC,OAAO,IAAI,GAAG,IAAI,CAAC;AACrB,CAAC;AAFD,0BAEC;AAED;;;GAGG;AACH,SAAgB,OAAO,CAAC,IAAY;IAClC,OAAO,IAAI,GAAG,IAAI,CAAC;AACrB,CAAC;AAFD,0BAEC;AAED,uGAAuG;AACvG,uCAAyD;AAAhD,2CAAA,wBAAwB,CAAA","sourcesContent":["import { getCurrentHub, Hub } from '@sentry/hub';\nimport { Options, TraceparentData, Transaction } from '@sentry/types';\n\nexport const TRACEPARENT_REGEXP = new RegExp(\n  '^[ \\\\t]*' + // whitespace\n  '([0-9a-f]{32})?' + // trace_id\n  '-?([0-9a-f]{16})?' + // span_id\n  '-?([01])?' + // sampled\n    '[ \\\\t]*$', // whitespace\n);\n\n/**\n * Determines if tracing is currently enabled.\n *\n * Tracing is enabled when at least one of `tracesSampleRate` and `tracesSampler` is defined in the SDK config.\n */\nexport function hasTracingEnabled(options: Options): boolean {\n  return 'tracesSampleRate' in options || 'tracesSampler' in options;\n}\n\n/**\n * Extract transaction context data from a `sentry-trace` header.\n *\n * @param traceparent Traceparent string\n *\n * @returns Object containing data from the header, or undefined if traceparent string is malformed\n */\nexport function extractTraceparentData(traceparent: string): TraceparentData | undefined {\n  const matches = traceparent.match(TRACEPARENT_REGEXP);\n  if (matches) {\n    let parentSampled: boolean | undefined;\n    if (matches[3] === '1') {\n      parentSampled = true;\n    } else if (matches[3] === '0') {\n      parentSampled = false;\n    }\n    return {\n      traceId: matches[1],\n      parentSampled,\n      parentSpanId: matches[2],\n    };\n  }\n  return undefined;\n}\n\n/** Grabs active transaction off scope, if any */\nexport function getActiveTransaction<T extends Transaction>(hub: Hub = getCurrentHub()): T | undefined {\n  return hub?.getScope()?.getTransaction() as T | undefined;\n}\n\n/**\n * Converts from milliseconds to seconds\n * @param time time in ms\n */\nexport function msToSec(time: number): number {\n  return time / 1000;\n}\n\n/**\n * Converts from seconds to milliseconds\n * @param time time in seconds\n */\nexport function secToMs(time: number): number {\n  return time * 1000;\n}\n\n// so it can be used in manual instrumentation without necessitating a hard dependency on @sentry/utils\nexport { stripUrlQueryAndFragment } from '@sentry/utils';\n"]}/**
 * Add a listener that cancels and finishes a transaction when the global
 * document is hidden.
 */
export declare function registerBackgroundTabDetection(): void;
//# sourceMappingURL=backgroundtab.d.ts.map{"version":3,"file":"backgroundtab.d.ts","sourceRoot":"","sources":["../../src/browser/backgroundtab.ts"],"names":[],"mappings":"AAQA;;;GAGG;AACH,wBAAgB,8BAA8B,IAAI,IAAI,CAoBrD"}import { getGlobalObject, logger } from '@sentry/utils';
import { SpanStatus } from '../spanstatus';
import { getActiveTransaction } from '../utils';
var global = getGlobalObject();
/**
 * Add a listener that cancels and finishes a transaction when the global
 * document is hidden.
 */
export function registerBackgroundTabDetection() {
    if (global && global.document) {
        global.document.addEventListener('visibilitychange', function () {
            var activeTransaction = getActiveTransaction();
            if (global.document.hidden && activeTransaction) {
                logger.log("[Tracing] Transaction: " + SpanStatus.Cancelled + " -> since tab moved to the background, op: " + activeTransaction.op);
                // We should not set status if it is already set, this prevent important statuses like
                // error or data loss from being overwritten on transaction.
                if (!activeTransaction.status) {
                    activeTransaction.setStatus(SpanStatus.Cancelled);
                }
                activeTransaction.setTag('visibilitychange', 'document.hidden');
                activeTransaction.finish();
            }
        });
    }
    else {
        logger.warn('[Tracing] Could not set up background tab detection due to lack of global document');
    }
}
//# sourceMappingURL=backgroundtab.js.map{"version":3,"file":"backgroundtab.js","sourceRoot":"","sources":["../../src/browser/backgroundtab.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,eAAe,EAAE,MAAM,EAAE,MAAM,eAAe,CAAC;AAGxD,OAAO,EAAE,UAAU,EAAE,MAAM,eAAe,CAAC;AAC3C,OAAO,EAAE,oBAAoB,EAAE,MAAM,UAAU,CAAC;AAEhD,IAAM,MAAM,GAAG,eAAe,EAAU,CAAC;AAEzC;;;GAGG;AACH,MAAM,UAAU,8BAA8B;IAC5C,IAAI,MAAM,IAAI,MAAM,CAAC,QAAQ,EAAE;QAC7B,MAAM,CAAC,QAAQ,CAAC,gBAAgB,CAAC,kBAAkB,EAAE;YACnD,IAAM,iBAAiB,GAAG,oBAAoB,EAAqB,CAAC;YACpE,IAAI,MAAM,CAAC,QAAQ,CAAC,MAAM,IAAI,iBAAiB,EAAE;gBAC/C,MAAM,CAAC,GAAG,CACR,4BAA0B,UAAU,CAAC,SAAS,mDAA8C,iBAAiB,CAAC,EAAI,CACnH,CAAC;gBACF,sFAAsF;gBACtF,4DAA4D;gBAC5D,IAAI,CAAC,iBAAiB,CAAC,MAAM,EAAE;oBAC7B,iBAAiB,CAAC,SAAS,CAAC,UAAU,CAAC,SAAS,CAAC,CAAC;iBACnD;gBACD,iBAAiB,CAAC,MAAM,CAAC,kBAAkB,EAAE,iBAAiB,CAAC,CAAC;gBAChE,iBAAiB,CAAC,MAAM,EAAE,CAAC;aAC5B;QACH,CAAC,CAAC,CAAC;KACJ;SAAM;QACL,MAAM,CAAC,IAAI,CAAC,oFAAoF,CAAC,CAAC;KACnG;AACH,CAAC","sourcesContent":["import { getGlobalObject, logger } from '@sentry/utils';\n\nimport { IdleTransaction } from '../idletransaction';\nimport { SpanStatus } from '../spanstatus';\nimport { getActiveTransaction } from '../utils';\n\nconst global = getGlobalObject<Window>();\n\n/**\n * Add a listener that cancels and finishes a transaction when the global\n * document is hidden.\n */\nexport function registerBackgroundTabDetection(): void {\n  if (global && global.document) {\n    global.document.addEventListener('visibilitychange', () => {\n      const activeTransaction = getActiveTransaction() as IdleTransaction;\n      if (global.document.hidden && activeTransaction) {\n        logger.log(\n          `[Tracing] Transaction: ${SpanStatus.Cancelled} -> since tab moved to the background, op: ${activeTransaction.op}`,\n        );\n        // We should not set status if it is already set, this prevent important statuses like\n        // error or data loss from being overwritten on transaction.\n        if (!activeTransaction.status) {\n          activeTransaction.setStatus(SpanStatus.Cancelled);\n        }\n        activeTransaction.setTag('visibilitychange', 'document.hidden');\n        activeTransaction.finish();\n      }\n    });\n  } else {\n    logger.warn('[Tracing] Could not set up background tab detection due to lack of global document');\n  }\n}\n"]}import { Hub } from '@sentry/hub';
import { EventProcessor, Integration, Transaction, TransactionContext } from '@sentry/types';
import { RequestInstrumentationOptions } from './request';
export declare const DEFAULT_MAX_TRANSACTION_DURATION_SECONDS = 600;
/** Options for Browser Tracing integration */
export interface BrowserTracingOptions extends RequestInstrumentationOptions {
    /**
     * The time to wait in ms until the transaction will be finished. The transaction will use the end timestamp of
     * the last finished span as the endtime for the transaction.
     * Time is in ms.
     *
     * Default: 1000
     */
    idleTimeout: number;
    /**
     * Flag to enable/disable creation of `navigation` transaction on history changes.
     *
     * Default: true
     */
    startTransactionOnLocationChange: boolean;
    /**
     * Flag to enable/disable creation of `pageload` transaction on first pageload.
     *
     * Default: true
     */
    startTransactionOnPageLoad: boolean;
    /**
     * The maximum duration of a transaction before it will be marked as "deadline_exceeded".
     * If you never want to mark a transaction set it to 0.
     * Time is in seconds.
     *
     * Default: 600
     */
    maxTransactionDuration: number;
    /**
     * Flag Transactions where tabs moved to background with "cancelled". Browser background tab timing is
     * not suited towards doing precise measurements of operations. By default, we recommend that this option
     * be enabled as background transactions can mess up your statistics in nondeterministic ways.
     *
     * Default: true
     */
    markBackgroundTransactions: boolean;
    /**
     * beforeNavigate is called before a pageload/navigation transaction is created and allows users to modify transaction
     * context data, or drop the transaction entirely (by setting `sampled = false` in the context).
     *
     * Note: For legacy reasons, transactions can also be dropped by returning `undefined`.
     *
     * @param context: The context data which will be passed to `startTransaction` by default
     *
     * @returns A (potentially) modified context object, with `sampled = false` if the transaction should be dropped.
     */
    beforeNavigate?(context: TransactionContext): TransactionContext | undefined;
    /**
     * Instrumentation that creates routing change transactions. By default creates
     * pageload and navigation transactions.
     */
    routingInstrumentation<T extends Transaction>(startTransaction: (context: TransactionContext) => T | undefined, startTransactionOnPageLoad?: boolean, startTransactionOnLocationChange?: boolean): void;
}
/**
 * The Browser Tracing integration automatically instruments browser pageload/navigation
 * actions as transactions, and captures requests, metrics and errors as spans.
 *
 * The integration can be configured with a variety of options, and can be extended to use
 * any routing library. This integration uses {@see IdleTransaction} to create transactions.
 */
export declare class BrowserTracing implements Integration {
    /**
     * @inheritDoc
     */
    static id: string;
    /** Browser Tracing integration options */
    options: BrowserTracingOptions;
    /**
     * @inheritDoc
     */
    name: string;
    private _getCurrentHub?;
    private readonly _metrics;
    private readonly _emitOptionsWarning