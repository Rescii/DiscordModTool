p://wicg.github.io/netinfo/#savedata-attribute\n  readonly saveData?: boolean;\n  // http://wicg.github.io/netinfo/#handling-changes-to-the-underlying-connection\n  onchange?: EventListener;\n}\n\n// https://w3c.github.io/device-memory/#sec-device-memory-js-api\nexport interface NavigatorDeviceMemory {\n  readonly deviceMemory?: number;\n}\n\nexport type NavigationTimingPolyfillEntry = Omit<\n  PerformanceNavigationTiming,\n  | 'initiatorType'\n  | 'nextHopProtocol'\n  | 'redirectCount'\n  | 'transferSize'\n  | 'encodedBodySize'\n  | 'decodedBodySize'\n  | 'toJSON'\n>;\n"]}/**
 * Configures global error listeners
 */
export declare function registerErrorInstrumentation(): void;
//# sourceMappingURL=errors.d.ts.map{"version":3,"file":"errors.d.ts","sourceRoot":"","sources":["../src/errors.ts"],"names":[],"mappings":"AAKA;;GAEG;AACH,wBAAgB,4BAA4B,IAAI,IAAI,CASnD"}import { addInstrumentationHandler, logger } from '@sentry/utils';
import { SpanStatus } from './spanstatus';
import { getActiveTransaction } from './utils';
/**
 * Configures global error listeners
 */
export function registerErrorInstrumentation() {
    addInstrumentationHandler({
        callback: errorCallback,
        type: 'error',
    });
    addInstrumentationHandler({
        callback: errorCallback,
        type: 'unhandledrejection',
    });
}
/**
 * If an error or unhandled promise occurs, we mark the active transaction as failed
 */
function errorCallback() {
    var activeTransaction = getActiveTransaction();
    if (activeTransaction) {
        logger.log("[Tracing] Transaction: " + SpanStatus.InternalError + " -> Global error occured");
        activeTransaction.setStatus(SpanStatus.InternalError);
    }
}
//# sourceMappingURL=errors.js.map{"version":3,"file":"errors.js","sourceRoot":"","sources":["../src/errors.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,yBAAyB,EAAE,MAAM,EAAE,MAAM,eAAe,CAAC;AAElE,OAAO,EAAE,UAAU,EAAE,MAAM,cAAc,CAAC;AAC1C,OAAO,EAAE,oBAAoB,EAAE,MAAM,SAAS,CAAC;AAE/C;;GAEG;AACH,MAAM,UAAU,4BAA4B;IAC1C,yBAAyB,CAAC;QACxB,QAAQ,EAAE,aAAa;QACvB,IAAI,EAAE,OAAO;KACd,CAAC,CAAC;IACH,yBAAyB,CAAC;QACxB,QAAQ,EAAE,aAAa;QACvB,IAAI,EAAE,oBAAoB;KAC3B,CAAC,CAAC;AACL,CAAC;AAED;;GAEG;AACH,SAAS,aAAa;IACpB,IAAM,iBAAiB,GAAG,oBAAoB,EAAE,CAAC;IACjD,IAAI,iBAAiB,EAAE;QACrB,MAAM,CAAC,GAAG,CAAC,4BAA0B,UAAU,CAAC,aAAa,6BAA0B,CAAC,CAAC;QACzF,iBAAiB,CAAC,SAAS,CAAC,UAAU,CAAC,aAAa,CAAC,CAAC;KACvD;AACH,CAAC","sourcesContent":["import { addInstrumentationHandler, logger } from '@sentry/utils';\n\nimport { SpanStatus } from './spanstatus';\nimport { getActiveTransaction } from './utils';\n\n/**\n * Configures global error listeners\n */\nexport function registerErrorInstrumentation(): void {\n  addInstrumentationHandler({\n    callback: errorCallback,\n    type: 'error',\n  });\n  addInstrumentationHandler({\n    callback: errorCallback,\n    type: 'unhandledrejection',\n  });\n}\n\n/**\n * If an error or unhandled promise occurs, we mark the active transaction as failed\n */\nfunction errorCallback(): void {\n  const activeTransaction = getActiveTransaction();\n  if (activeTransaction) {\n    logger.log(`[Tracing] Transaction: ${SpanStatus.InternalError} -> Global error occured`);\n    activeTransaction.setStatus(SpanStatus.InternalError);\n  }\n}\n"]}import { Hub } from '@sentry/hub';
import { TransactionContext } from '@sentry/types';
import { IdleTransaction } from './idletransaction';
/**
 * Create new idle transaction.
 */
export declare function startIdleTransaction(hub: Hub, transactionContext: TransactionContext, idleTimeout?: number, onScope?: boolean): IdleTransaction;
/**
 * @private
 */
export declare function _addTracingExtensions(): void;
/**
 * This patches the global object and injects the Tracing extensions methods
 */
export declare function addExtensionMethods(): void;
//# sourceMappingURL=hubextensions.d.ts.map{"version":3,"file":"hubextensions.d.ts","sourceRoot":"","sources":["../src/hubextensions.ts"],"names":[],"mappings":"AAAA,OAAO,EAAmC,GAAG,EAAE,MAAM,aAAa,CAAC;AACnE,OAAO,EAA0C,kBAAkB,EAA6B,MAAM,eAAe,CAAC;AAWtH,OAAO,EAAE,eAAe,EAAE,MAAM,mBAAmB,CAAC;AAiNpD;;GAEG;AACH,wBAAgB,oBAAoB,CAClC,GAAG,EAAE,GAAG,EACR,kBAAkB,EAAE,kBAAkB,EACtC,WAAW,CAAC,EAAE,MAAM,EACpB,OAAO,CAAC,EAAE,OAAO,GAChB,eAAe,CAGjB;AAED;;GAEG;AACH,wBAAgB,qBAAqB,IAAI,IAAI,CAW5C;AAED;;GAEG;AACH,wBAAgB,mBAAmB,IAAI,IAAI,CAK1C"}import { __assign } from "tslib";
import { getActiveDomain, getMainCarrier } from '@sentry/hub';
import { TransactionSamplingMethod } from '@sentry/types';
import { dynamicRequire, extractNodeRequestData, getGlobalObject, isInstanceOf, isNodeEnv, logger, } from '@sentry/utils';
import { registerErrorInstrumentation } from './errors';
import { IdleTransaction } from './idletransaction';
import { Transaction } from './transaction';
import { hasTracingEnabled } from './utils';
/** Returns all trace headers that are currently on the top scope. */
function traceHeaders() {
    var scope = this.getScope();
    if (scope) {
        var span = scope.getSpan();
        if (span) {
            return {
                'sentry-trace': span.toTraceparent(),
            };
        }
    }
    return {};
}
/**
 * Makes a sampling decision for the given transaction and stores it on the transaction.
 *
 * Called every time a transaction is created. Only transactions which emerge with a `sampled` value of `true` will be
 * sent to Sentry.
 *
 * @param hub: The hub off of which to read config options
 * @param transaction: The transaction needing a sampling decision
 * @param samplingContext: Default and user-provided data which may be used to help make the decision
 *
 * @returns The given transaction with its `sampled` value set
 */
function sample(hub, transaction, samplingContext) {
    var _a;
    var client = hub.getClient();
    var options = (client && client.getOptions()) || {};
    // nothing to do if there's no client or if tracing is disabled
    if (!client || !hasTracingEnabled(options)) {
        transaction.sampled = false;
        return transaction;
    }
    // if the user has forced a sampling decision by passing a `sampled` value in their transaction context, go with that
    if (transaction.sampled !== undefined) {
        transaction.tags = __assign(__assign({}, transaction.tags), { __sentry_samplingMethod: TransactionSamplingMethod.Explicit });
        return transaction;
    }
    // we would have bailed already if neither `tracesSampler` nor `tracesSampleRate` were defined, so one of these should
    // work; prefer the hook if so
    var sampleRat