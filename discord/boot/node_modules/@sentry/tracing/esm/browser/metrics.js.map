s.init = browser_3.init;
exports.lastEventId = browser_3.lastEventId;
exports.onLoad = browser_3.onLoad;
exports.showReportDialog = browser_3.showReportDialog;
exports.flush = browser_3.flush;
exports.close = browser_3.close;
exports.wrap = browser_3.wrap;
var browser_4 = require("@sentry/browser");
exports.SDK_NAME = browser_4.SDK_NAME;
exports.SDK_VERSION = browser_4.SDK_VERSION;
var browser_5 = require("@sentry/browser");
var utils_1 = require("@sentry/utils");
var browser_6 = require("./browser");
var hubextensions_1 = require("./hubextensions");
exports.addExtensionMethods = hubextensions_1.addExtensionMethods;
var span_1 = require("./span");
exports.Span = span_1.Span;
var windowIntegrations = {};
// This block is needed to add compatibility with the integrations packages when used with a CDN
var _window = utils_1.getGlobalObject();
if (_window.Sentry && _window.Sentry.Integrations) {
    windowIntegrations = _window.Sentry.Integrations;
}
var INTEGRATIONS = tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, windowIntegrations), browser_5.Integrations), { BrowserTracing: browser_6.BrowserTracing });
exports.Integrations = INTEGRATIONS;
// We are patching the global object with our hub extension methods
hubextensions_1.addExtensionMethods();
//# sourceMappingURL=index.bundle.js.map{"version":3,"file":"index.bundle.js","sourceRoot":"","sources":["../src/index.bundle.ts"],"names":[],"mappings":";;AAAA,uCAauB;AANrB,2BAAA,QAAQ,CAAA;AAGR,yBAAA,MAAM,CAAA;AAKR,2CAoByB;AAnBvB,4CAAA,uBAAuB,CAAA;AACvB,kCAAA,aAAa,CAAA;AACb,qCAAA,gBAAgB,CAAA;AAChB,iCAAA,YAAY,CAAA;AACZ,mCAAA,cAAc,CAAA;AACd,mCAAA,cAAc,CAAA;AACd,sCAAA,iBAAiB,CAAA;AACjB,kCAAA,aAAa,CAAA;AACb,wBAAA,GAAG,CAAA;AACH,0BAAA,KAAK,CAAA;AACL,+BAAA,UAAU,CAAA;AACV,6BAAA,QAAQ,CAAA;AACR,8BAAA,SAAS,CAAA;AACT,2BAAA,MAAM,CAAA;AACN,4BAAA,OAAO,CAAA;AACP,4BAAA,OAAO,CAAA;AACP,qCAAA,gBAAgB,CAAA;AAChB,+BAAA,UAAU,CAAA;AACV,8BAAA,SAAS,CAAA;AAIX,2CAAqE;AAA5D,kCAAA,aAAa,CAAA;AACtB,2CAUyB;AATvB,wCAAA,mBAAmB,CAAA;AACnB,8BAAA,SAAS,CAAA;AACT,yBAAA,IAAI,CAAA;AACJ,gCAAA,WAAW,CAAA;AACX,2BAAA,MAAM,CAAA;AACN,qCAAA,gBAAgB,CAAA;AAChB,0BAAA,KAAK,CAAA;AACL,0BAAA,KAAK,CAAA;AACL,yBAAA,IAAI,CAAA;AAEN,2CAAwD;AAA/C,6BAAA,QAAQ,CAAA;AAAE,gCAAA,WAAW,CAAA;AAE9B,2CAAsE;AACtE,uCAAgD;AAEhD,qCAA2C;AAC3C,iDAAsD;AAuB7C,8BAvBA,mCAAmB,CAuBA;AArB5B,+BAA8B;AAArB,sBAAA,IAAI,CAAA;AAEb,IAAI,kBAAkB,GAAG,EAAE,CAAC;AAE5B,gGAAgG;AAChG,IAAM,OAAO,GAAG,uBAAe,EAAU,CAAC;AAC1C,IAAI,OAAO,CAAC,MAAM,IAAI,OAAO,CAAC,MAAM,CAAC,YAAY,EAAE;IACjD,kBAAkB,GAAG,OAAO,CAAC,MAAM,CAAC,YAAY,CAAC;CAClD;AAED,IAAM,YAAY,0DACb,kBAAkB,GAClB,sBAAmB,KACtB,cAAc,0BAAA,GACf,CAAC;AAEuB,oCAAY;AAErC,mEAAmE;AACnE,mCAAmB,EAAE,CAAC","sourcesContent":["export {\n  Breadcrumb,\n  Request,\n  SdkInfo,\n  Event,\n  Exception,\n  Response,\n  Severity,\n  StackFrame,\n  Stacktrace,\n  Status,\n  Thread,\n  User,\n} from '@sentry/types';\n\nexport {\n  addGlobalEventProcessor,\n  addBreadcrumb,\n  captureException,\n  captureEvent,\n  captureMessage,\n  configureScope,\n  getHubFromCarrier,\n  getCurrentHub,\n  Hub,\n  Scope,\n  setContext,\n  setExtra,\n  setExtras,\n  setTag,\n  setTags,\n  setUser,\n  startTransaction,\n  Transports,\n  withScope,\n} from '@sentry/browser';\n\nexport { BrowserOptions } from '@sentry/browser';\nexport { BrowserClient, ReportDialogOptions } from '@sentry/browser';\nexport {\n  defaultIntegrations,\n  forceLoad,\n  init,\n  lastEventId,\n  onLoad,\n  showReportDialog,\n  flush,\n  close,\n  wrap,\n} from '@sentry/browser';\nexport { SDK_NAME, SDK_VERSION } from '@sentry/browser';\n\nimport { Integrations as BrowserIntegrations } from '@sentry/browser';\nimport { getGlobalObject } from '@sentry/utils';\n\nimport { BrowserTracing } from './browser';\nimport { addExtensionMethods } from './hubextensions';\n\nexport { Span } from './span';\n\nlet windowIntegrations = {};\n\n// This block is needed to add compatibility with the integrations packages when used with a CDN\nconst _window = getGlobalObject<Window>();\nif (_window.Sentry && _window.Sentry.Integrations) {\n  windowIntegrations = _window.Sentry.Integrations;\n}\n\nconst INTEGRATIONS = {\n  ...windowIntegrations,\n  ...BrowserIntegrations,\n  BrowserTracing,\n};\n\nexport { INTEGRATIONS as Integrations };\n\n// We are patching the global object with our hub extension methods\naddExtensionMethods();\n\nexport { addExtensionMethods };\n"]}import { BrowserTracing } from './browser';
import { addExtensionMethods } from './hubextensions';
import * as TracingIntegrations from './integrations';
declare const Integrations: {
    BrowserTracing: typeof BrowserTracing;
    Express: typeof TracingIntegrations.Express;
    Postgres: typeof TracingIntegrations.Postgres;
    Mysql: typeof TracingIntegrations.Mysql;
    Mongo: typeof TracingIntegrations.Mongo;
};
export { Integrations };
export { Span } from './span';
export { Transaction } from './transaction';
export { registerRequestInstrumentation, RequestInstrumentationOptions, defaultRequestInstrumentationOptions, } from './browser';
export { SpanStatus } from './spanstatus';
export { IdleTransaction } from './idletransaction';
export { startIdleTransaction } from './hubextensions';
export { addExtensionMethods };
export { extractTraceparentData, getActiveTransaction, hasTracingEnabled, stripUrlQueryAndFragment, TRACEPARENT_REGEXP, } from './utils';
//# sourceMappingURL=index.d.ts.map{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,cAAc,EAAE,MAAM,WAAW,CAAC;AAC3C,OAAO,EAAE,mBAAmB,EAAE,MAAM,iBAAiB,CAAC;AACtD,OAAO,KAAK,mBAAmB,MAAM,gBAAgB,CAAC;AAEtD,QAAA,MAAM,YAAY;;;;;;CAA6C,CAAC;AAEhE,OAAO,EAAE,YAAY,EAAE,CAAC;AACxB,OAAO,EAAE,IAAI,EAAE,MAAM,QAAQ,CAAC;AAC9B,OAAO,EAAE,WAAW,EAAE,MAAM,eAAe,CAAC;AAC5C,OAAO,EACL,8BAA8B,EAC9B,6BAA6B,EAC7B,oCAAoC,GACrC,MAAM,WAAW,CAAC;AACnB,OAAO,EAAE,UAAU,EAAE,MAAM,cAAc,CAAC;AAC1C,OAAO,EAAE,eAAe,EAAE,MAAM,mBAAmB,CAAC;AACpD,OAAO,EAAE,oBAAoB,EAAE,MAAM,iBAAiB,CAAC;AAKvD,OAAO,EAAE,mBAAmB,EAAE,CAAC;AAE/B,OAAO,EACL,sBAAsB,EACtB,oBAAoB,EACpB,iBAAiB,EACjB,wBAAwB,EACxB,kBAAkB,GACnB,MAAM,SAAS,CAAC"}Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var browser_1 = require("./browser");
var hubextensions_1 = require("./hubextensions");
exports.addExtensionMethods = hubextensions_1.addExtensionMethods;
var TracingIntegrations = require("./integrations");
var Integrations = tslib_1.__assign(tslib_1.__assign({}, TracingIntegrations), { BrowserTracing: browser_1.BrowserTracing });
exports.Integrations = Integrations;
var span_1 = require("./span");
exports.Span = span_1.Span;
var transaction_1 = require("./transaction");
exports.Transaction = transaction_1.Transaction;
var browser_2 = require("./browser");
exports.registerRequestInstrumentation = browser_2.registerRequestInstrumentation;
exports.defaultRequestInstrumentationOptions = browser_2.defaultRequestInstrumentationOptions;
var spanstatus_1 = require("./spanstatus");
exports.SpanStatus = spanstatus_1.SpanStatus;
var idletransaction_1 = require("./idletransaction");
exports.IdleTransaction = idletransaction_1.IdleTransaction;
var hubextensions_2 = require("./hubextensions");
exports.startIdleTransaction = hubextensions_2.startIdleTransaction;
// We are patching the global object with our hub extension methods
hubextensions_1.addExtensionMethods();
var utils_1 = require("./utils");
exports.extractTraceparentData = utils_1.extractTraceparentData;
exports.getActiveTransaction = utils_1.getActiveTransaction;
exports.hasTracingEnabled = utils_1.hasTracingEnabled;
exports.stripUrlQueryAndFragment = utils_1.stripUrlQueryAndFragment;
exports.TRACEPARENT_REGEXP = utils_1.TRACEPARENT_REGEXP;
//# sourceMappingURL=index.js.map{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":";;AAAA,qCAA2C;AAC3C,iDAAsD;AAoB7C,8BApBA,mCAAmB,CAoBA;AAnB5B,oDAAsD;AAEtD,IAAM,YAAY,yCAAQ,mBAAmB,KAAE,cAAc,0BAAA,GAAE,CAAC;AAEvD,oCAAY;AACrB,+BAA8B;AAArB,sBAAA,IAAI,CAAA;AACb,6CAA4C;AAAnC,oCAAA,WAAW,CAAA;AACpB,qCAImB;AAHjB,mDAAA,8BAA8B,CAAA;AAE9B,yDAAA,oCAAoC,CAAA;AAEtC,2CAA0C;AAAjC,kCAAA,UAAU,CAAA;AACnB,qDAAoD;AAA3C,4CAAA,eAAe,CAAA;AACxB,iDAAuD;AAA9C,+CAAA,oBAAoB,CAAA;AAE7B,mEAAmE;AACnE,mCAAmB,EAAE,CAAC;AAItB,iCAMiB;AALf,yCAAA,sBAAsB,CAAA;AACtB,uCAAA,oBAAoB,CAAA;AACpB,oCAAA,iBAAiB,CAAA;AACjB,2CAAA,wBAAwB,CAAA;AACxB,qCAAA,kBAAkB,CAAA","sourcesContent":["import { BrowserTracing } from './browser';\nimport { addExtensionMethods } from './hubextensions';\nimport * as TracingIntegrations from './integrations';\n\nconst Integrations = { ...TracingIntegrations, BrowserTracing };\n\nexport { Integrations };\nexport { Span } from './span';\nexport { Transaction } from './transaction';\nexport {\n  registerRequestInstrumentation,\n  RequestInstrumentationOptions,\n  defaultRequestInstrumentationOptions,\n} from './browser';\nexport { SpanStatus } from './spanstatus';\nexport { IdleTransaction } from './idletransaction';\nexport { startIdleTransaction } from './hubextensions';\n\n// We are patching the global object with our hub extension methods\naddExtensionMethods();\n\nexport { addExtensionMethods };\n\nexport {\n  extractTraceparentData,\n  getActiveTransaction,\n  hasTracingEnabled,\n  stripUrlQueryAndFragment,\n  TRACEPARENT_REGEXP,\n} from './utils';\n"]}import { Integration } from '@sentry/types';
declare type Method = 'all' | 'get' | 'post' | 'put' | 'delete' | 'patch' | 'options' | 'head' | 'checkout' | 'copy' | 'lock' | 'merge' | 'mkactivity' | 'mkcol' | 'move' | 'm-search' | 'notify' | 'purge' | 'report' | 'search' | 'subscribe' | 'trace' | 'unlock' | 'unsubscribe' | 'use';
declare type Router = {
    [method in Method]: (...args: any) => any;
};
/**
 * Express integration
 *
 * Provides an request and error handler for Express framework as well as tracing capabilities
 */
export declare class Express implements Integration {
    /**
     * @inheritDoc
     */
    static id: string;
    /**
     * @inheritDoc
     */
    name: string;
    /**
     * Express App instance
     */
    private readonly _router?;
    private readonly _methods?;
    /**
     * @inheritDoc
     */
    constructor(options?: {
        app?: Router;
        router?: Router;
        methods?: Method[];
    });
    /**
     * @inheritDoc
     */
    setupOnce(): void;
}
export {};
//# sourceMappingURL=express.d.ts.map{"version":3,"file":"express.d.ts","sourceRoot":"","sources":["../../src/integrations/express.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,WAAW,EAAe,MAAM,eAAe,CAAC;AAGzD,aAAK,MAAM,GACP,KAAK,GACL,KAAK,GACL,MAAM,GACN,KAAK,GACL,QAAQ,GACR,OAAO,GACP,SAAS,GACT,MAAM,GACN,UAAU,GACV,MAAM,GACN,MAAM,GACN,OAAO,GACP,YAAY,GACZ,OAAO,GACP,MAAM,GACN,UAAU,GACV,QAAQ,GACR,OAAO,GACP,QAAQ,GACR,QAAQ,GACR,WAAW,GACX,OAAO,GACP,QAAQ,GACR,aAAa,GACb,KAAK,CAAC;AAEV,aAAK,MAAM,GAAG;KACX,MAAM,IAAI,MAAM,GAAG,CAAC,GAAG,IAAI,EAAE,GAAG,KAAK,GAAG;CAC1C,CAAC;AAcF;;;;GAIG;AACH,qBAAa,OAAQ,YAAW,WAAW;IACzC;;OAEG;IACH,OAAc,EAAE,EAAE,MAAM,CAAa;IAErC;;OAEG;IACI,IAAI,EAAE,MAAM,CAAc;IAEjC;;OAEG;IACH,OAAO,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAS;IAClC,OAAO,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAW;IAErC;;OAEG;gBACgB,OAAO,GAAE;QAAE,GAAG,CAAC,EAAE,MAAM,CAAC;QAAC,MAAM,CAAC,EAAE,MAAM,CAAC;QAAC,OAAO,CAAC,EAAE,MAAM,EAAE,CAAA;KAAO;IAKtF;;OAEG;IACI,SAAS,IAAI,IAAI;CAOzB"}Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var utils_1 = require("@sentry/utils");
/**
 * Express integration
 *
 * Provides an request and error handler for Express framework as well as tracing capabilities
 */
var Express = /** @class */ (function () {
    /**
     * @inheritDoc
     */
    function Express(options) {
        if (options === void 0) { options = {}; }
        /**
         * @inheritDoc
         */
        this.name = Express.id;
        this._router = options.router || options.app;
        this._methods = (Array.isArray(options.methods) ? options.methods : []).concat('use');
    }
    /**
     * @inheritDoc
     */
    Express.prototype.setupOnce = function () {
        if (!this._router) {
            utils_1.logger.error('ExpressIntegration is missing an Express instance');
            return;
        }
        instrumentMiddlewares(this._router, this._methods);
    };
    /**
     * @inheritDoc
     */
    Express.id = 'Express';
    return Express;
}());
exports.Express = Express;
/**
 * Wraps original middleware function in a tracing call, which stores the info about the call as a span,
 * and finishes it once the middleware is done invoking.
 *
 * Express middlewares have 3 various forms, thus we have to take care of all of them:
 * // sync
 * app.use(function (req, res) { ... })
 * // async
 * app.use(function (req, res, next) { ... })
 * // error handler
 * app.use(function (err, req, res, next) { ... })
 *
 * They all internally delegate to the `router[method]` of the given application instance.
 */
// eslint-disable-next-line @typescript-eslint/ban-types, @typescript-eslint/no-explicit-any
function wrap(fn, method) {
    var arity = fn.length;
    switch (arity) {
        case 2: {
            return function (req, res) {
                var transaction = res.__sentry_transaction;
                if (transaction) {
                    var span_1 = transaction.startChild({
                        description: fn.name,
                        op: "middleware." + method,
                    });
                    res.once('finish', function () {
                        span_1.finish();
                    });
                }
                return fn.call(this, req, res);
            };
        }
        case 3: {
            return function (req, res, next) {
                var _a;
                var transaction = res.__sentry_transaction;
                var span = (_a = transaction) === null || _a === void 0 ? void 0 : _a.startChild({
                    description: fn.name,
                    op: "middleware." + method,
                });
                fn.call(this, req, res, function () {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    var _a;
                    (_a = span) === null || _a === void 0 ? void 0 : _a.finish();
                    next.call.apply(next, tslib_1.__spread([this], args));
                });
            };
        }
        case 4: {
            return function (err, req, res, next) {
                var _a;
                var transaction = res.__sentry_transaction;
                var span = (_a = transaction) === null || _a === void 0 ? void 0 : _a.startChild({
                    description: fn.name,
                    op: "middleware." + method,
                });
                fn.call(this, err, req, res, function () {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    var _a;
                    (_a = span) === null || _a === void 0 ? void 0 : _a.finish();
                    next.call.apply(next, tslib_1.__spread([this], args));
                });
            };
        }
        default: {
            throw new Error("Express middleware takes 2-4 arguments. Got: " + arity);
        }
    }
}
/**
 * Takes all the function arguments passed to the original `app` or `router` method, eg. `app.use` or `router.use`
 * and wraps every function, as well as array of functions with a call to our `wrap` method.
 * We have to take care of the arrays as well as iterate over all of the arguments,
 * as `app.use` can accept middlewares in few various forms.
 *
 * app.use([<path>], <fn>)
 * app.use([<path>], <fn>, ...<fn>)
 * app.use([<path>], ...<fn>[])
 */
function wrapMiddlewareArgs(args, method) {
    return args.map(function (arg) {
        if (typeof arg === 'function') {
            return wrap(arg, method);
        }
        if (Array.isArray(arg)) {
            return arg.map(function (a) {
                if (typeof a === 'function') {
                    return wrap(a, method);
                }
                return a;
            });
        }
        return arg;
    });
}
/**
 * Patches original router to utilize our tracing functionality
 */
function patchMiddleware(router, method) {
    var originalCallback = router[method];
    router[method] = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return originalCallback.call.apply(originalCallback, tslib_1.__spread([this], wrapMiddlewareArgs(args, method)));
    };
    return router;
}
/**
 * Patches original router methods
 */
function instrumentMiddlewares(router, methods) {
    if (methods === void 0) { methods = []; }
    methods.forEach(function (method) { return patchMiddleware(router, method); });
}
//# sourceMappingURL=express.js.map{"version":3,"file":"express.js","sourceRoot":"","sources":["../../src/integrations/express.ts"],"names":[],"mappings":"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","sourcesContent":["import { Integration, Transaction } from '@sentry/types';\nimport { logger } from '@sentry/utils';\n\ntype Method =\n  | 'all'\n  | 'get'\n  | 'post'\n  | 'put'\n  | 'delete'\n  | 'patch'\n  | 'options'\n  | 'head'\n  | 'checkout'\n  | 'copy'\n  | 'lock'\n  | 'merge'\n  | 'mkactivity'\n  | 'mkcol'\n  | 'move'\n  | 'm-search'\n  | 'notify'\n  | 'purge'\n  | 'report'\n  | 'search'\n  | 'subscribe'\n  | 'trace'\n  | 'unlock'\n  | 'unsubscribe'\n  | 'use';\n\ntype Router = {\n  [method in Method]: (...args: any) => any; // eslint-disable-line @typescript-eslint/no-explicit-any\n};\n\ninterface ExpressResponse {\n  once(name: string, callback: () => void): void;\n}\n\n/**\n * Internal helper for `__sentry_transaction`\n * @hidden\n */\ninterface SentryTracingResponse {\n  __sentry_transaction?: Transaction;\n}\n\n/**\n * Express integration\n *\n * Provides an request and error handler for Express framework as well as tracing capabilities\n */\nexport class Express implements Integration {\n  /**\n   * @inheritDoc\n   */\n  public static id: string = 'Express';\n\n  /**\n   * @inheritDoc\n   */\n  public name: string = Express.id;\n\n  /**\n   * Express App instance\n   */\n  private readonly _router?: Router;\n  private readonly _methods?: Method[];\n\n  /**\n   * @inheritDoc\n   */\n  public constructor(options: { app?: Router; router?: Router; methods?: Method[] } = {}) {\n    this._router = options.router || options.app;\n    this._methods = (Array.isArray(options.methods) ? options.methods : []).concat('use');\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setupOnce(): void {\n    if (!this._router) {\n      logger.error('ExpressIntegration is missing an Express instance');\n      return;\n    }\n    instrumentMiddlewares(this._router, this._methods);\n  }\n}\n\n/**\n * Wraps original middleware function in a tracing call, which stores the info about the call as a span,\n * and finishes it once the middleware is done invoking.\n *\n * Express middlewares have 3 various forms, thus we have to take care of all of them:\n * // sync\n * app.use(function (req, res) { ... })\n * // async\n * app.use(function (req, res, next) { ... })\n * // error handler\n * app.use(function (err, req, res, next) { ... })\n *\n * They all internally delegate to the `router[method]` of the given application instance.\n */\n// eslint-disable-next-line @typescript-eslint/ban-types, @typescript-eslint/no-explicit-any\nfunction wrap(fn: Function, method: Method): (...args: any[]) => void {\n  const arity = fn.length;\n\n  switch (arity) {\n    case 2: {\n      return function(this: NodeJS.Global, req: unknown, res: ExpressResponse & SentryTracingResponse): void {\n        const transaction = res.__sentry_transaction;\n        if (transaction) {\n          const span = transaction.startChild({\n            description: fn.name,\n            op: `middleware.${method}`,\n          });\n          res.once('finish', () => {\n            span.finish();\n          });\n        }\n        return fn.call(this, req, res);\n      };\n    }\n    case 3: {\n      return function(\n        this: NodeJS.Global,\n        req: unknown,\n        res: ExpressResponse & SentryTracingResponse,\n        next: () => void,\n      ): void {\n        const transaction = res.__sentry_transaction;\n        const span = transaction?.startChild({\n          description: fn.name,\n          op: `middleware.${method}`,\n        });\n        fn.call(this, req, res, function(this: NodeJS.Global, ...args: unknown[]): void {\n          span?.finish();\n          next.call(this, ...args);\n        });\n      };\n    }\n    case 4: {\n      return function(\n        this: NodeJS.Global,\n        err: Error,\n        req: Request,\n        res: Response & SentryTracingResponse,\n        next: () => void,\n      ): void {\n        const transaction = res.__sentry_transaction;\n        const span = transaction?.startChild({\n          description: fn.name,\n          op: `middleware.${method}`,\n        });\n        fn.call(this, err, req, res, function(this: NodeJS.Global, ...args: unknown[]): void {\n          span?.finish();\n          next.call(this, ...args);\n        });\n      };\n    }\n    default: {\n      throw new Error(`Express middleware takes 2-4 arguments. Got: ${arity}`);\n    }\n  }\n}\n\n/**\n * Takes all the function arguments passed to the original `app` or `router` method, eg. `app.use` or `router.use`\n * and wraps every function, as well as array of functions with a call to our `wrap` method.\n * We have to take care of the arrays as well as iterate over all of the arguments,\n * as `app.use` can accept middlewares in few various forms.\n *\n * app.use([<path>], <fn>)\n * app.use([<path>], <fn>, ...<fn>)\n * app.use([<path>], ...<fn>[])\n */\nfunction wrapMiddlewareArgs(args: unknown[], method: Method): unknown[] {\n  return args.map((arg: unknown) => {\n    if (typeof arg === 'function') {\n      return wrap(arg, method);\n    }\n\n    if (Array.isArray(arg)) {\n      return arg.map((a: unknown) => {\n        if (typeof a === 'function') {\n          return wrap(a, method);\n        }\n        return a;\n      });\n    }\n\n    return arg;\n  });\n}\n\n/**\n * Patches original router to utilize our tracing functionality\n */\nfunction patchMiddleware(router: Router, method: Method): Router {\n  const originalCallback = router[method];\n\n  router[method] = function(...args: unknown[]): void {\n    return originalCallback.call(this,