cision was inherited or tracesSampleRate is set to 0'));
        transaction.sampled = false;
        return transaction;
    }
    // Now we roll the dice. Math.random is inclusive of 0, but not of 1, so strict < is safe here. In case sampleRate is
    // a boolean, the < comparison will cause it to be automatically cast to 1 if it's true and 0 if it's false.
    transaction.sampled = Math.random() < sampleRate;
    // if we're not going to keep it, we're done
    if (!transaction.sampled) {
        logger.log("[Tracing] Discarding transaction because it's not included in the random sample (sampling rate = " + Number(sampleRate) + ")");
        return transaction;
    }
    // at this point we know we're keeping the transaction, whether because of an inherited decision or because it got
    // lucky with the dice roll
    transaction.initSpanRecorder((_a = options._experiments) === null || _a === void 0 ? void 0 : _a.maxSpans);
    logger.log("[Tracing] starting " + transaction.op + " transaction - " + transaction.name);
    return transaction;
}
/**
 * Gets the correct context to pass to the tracesSampler, based on the environment (i.e., which SDK is being used)
 *
 * @returns The default sample context
 */
function getDefaultSamplingContext(transactionContext) {
    // promote parent sampling decision (if any) for easy access
    var parentSampled = transactionContext.parentSampled;
    var defaultSamplingContext = { transactionContext: transactionContext, parentSampled: parentSampled };
    if (isNodeEnv()) {
        var domain = getActiveDomain();
        if (domain) {
            // for all node servers that we currently support, we store the incoming request object (which is an instance of
            // http.IncomingMessage) on the domain
            // the domain members are stored as an array, so our only way to find the request is to iterate through the array
            // and compare types
            var nodeHttpModule = dynamicRequire(module, 'http');
         