}
                default:
                // Ignore other entry types.
            }
        });
        if (entryScriptStartTimestamp !== undefined && tracingInitMarkStartTime !== undefined) {
            _startChild(transaction, {
                description: 'evaluation',
                endTimestamp: tracingInitMarkStartTime,
                op: 'script',
                startTimestamp: entryScriptStartTimestamp,
            });
        }
        this._performanceCursor = Math.max(performance.getEntries().length - 1, 0);
        this._trackNavigator(transaction);
        // Measurements are only available for pageload transactions
        if (transaction.op === 'pageload') {
            // normalize applicable web vital values to be relative to transaction.startTimestamp
            var timeOrigin_1 = msToSec(browserPerformanceTimeOrigin);
            ['fcp', 'fp', 'lcp', 'ttfb'].forEach(function (name) {
                if (!_this._measurements[name] || timeOrigin_1 >= transaction.startTimestamp) {
                    return;
                }
                // The web vitals, fcp, fp, lcp, and ttfb, all measure relative to timeOrigin.
                // Unfortunately, timeOrigin is not captured within the transaction span data, so these web vitals will need
                // to be adjusted to be relative to transaction.startTimestamp.
                var oldValue = _this._measurements[name].value;
                var measurementTimestamp = timeOrigin_1 + msToSec(oldValue);
                // normalizedValue should be in milliseconds
                var normalizedValue = Math.abs((measurementTimestamp - transaction.startTimestamp) * 1000);
                var delta = normalizedValue - oldValue;
                logger.log("[Measurements] Normalized " + name + " from " + oldValue + " to " + normalizedValue + " (" + delta + ")");
                _this._measurements[name].value = normalizedValue;
            });
            if (this._measurements['mark.fid'] && this._measurements['fid']) {
                // create span for FID
                _startChild(transaction, {
                    description: 'first input delay',
                    endTimestamp: this._measurements['mark.fid'].value + msToSec(this._measurements['fid'].value),
                    op: 'web.vitals',
                    startTimestamp: this._measurements['mark.fid'].value,
                });
            }
            transaction.setMeasurements(this._measurements);
        }
    };
    /** Starts tracking the Cumulative Layout Shift on the current page. */
    MetricsInstrumentation.prototype._trackCLS = function () {
        var _this = this;
        getCLS(function (metric) {
            var entry = metric.entries.pop();
            if (!entry) {
                return;
            }
            logger.log('[Measurements] Adding CLS');
            _this._measurements['cls'] = { value: metric.value };
        });
    };
    /**
     * Capture the information of the user agent.
     */
    MetricsInstrumentation.prototype._trackNavigator = function (transaction) {
        var navigator = global.navigator;
        if (!navigator) {
            return;
        }
        // track network connectivity
        var connection = navigator.connection;
        if (connection) {
            if (connection.effectiveType) {
                transaction.setTag('effectiveConnectionType', connection.effectiveType);
            }
            if (connection.type) {
                transaction.setTag('connectionType', connection.type);
            }
            if (isMeasurementValue(connection.rtt)) {
                this._measurements['connection.rtt'] = { value: connection.rtt };
            }
            if (isMeasurementValue(connection.downlink)) {
                this._measurements['connection.downlink'] = { value: connection.downlink };
            }
        }
        if (isMeasurementValue(navigator.deviceMemory)) {
            transaction.setTag('deviceMemory', String(navigator.deviceMemory));
        }
        if (isMeasurementValue(navigator.hardwareConcurrency)) {
            transaction.setTag('hardwareConcurrency', String(navigator.hardwareConcurrency));
        }
    };
    /** Starts tracking the Largest Contentful Paint on the current page. */
    MetricsInstrumentation.prototype._trackLCP = function () {
        var _this = this;
        getLCP(function (metric) {
            var entry = metric.entries.pop();
            if (!entry) {
                return;
            }
            var timeOrigin = msToSec(performance.timeOrigin);
            var startTime = msToSec(entry.startTime);
            logger.log('[Measurements] Adding LCP');
            _this._measurements['lcp'] = { value: metric.value };
            _this._measurements['mark.lcp'] = { value: timeOrigin + startTime };
        });
    };
    /** Starts tracking the First Input Delay on the current page. */
    MetricsInstrumentation.prototype._trackFID = function () {
        var _this = this;
        getFID(function (metric) {
            var entry = metric.entries.pop();
            if (!entry) {
                return;
            }
            var timeOrigin = msToSec(performance.timeOrigin);
            var startTime = msToSec(entry.startTime);
            logger.log('[Measurements] Adding FID');
            _this._measurements['fid'] = { value: metric.value };
            _this._measurements['mark.fid'] = { value: timeOrigin + startTime };
        });
    };
    /** Starts tracking the Time to First Byte on the current page. */
    MetricsInstrumentation.prototype._trackTTFB = function () {
        var _this = this;
        getTTFB(function (metric) {
            var _a;
            var entry = metric.entries.pop();
            if (!entry) {
                return;
            }
            logger.log('[Measurements] Adding TTFB');
            _this._measurements['ttfb'] = { value: metric.value };
            // Capture the time spent making the request and receiving the first byte of the response
            var requestTime = metric.value - (_a = metric.entries[0], (_a !== null && _a !== void 0 ? _a : entry)).requestStart;
            _this._measurements['ttfb.requestTime'] = { value: requestTime };
        });
    };
    return MetricsInstrumentation;
}());
export { MetricsInstrumentation };
/** Instrument navigation entries */
function addNavigationSpans(transaction, entry, timeOrigin) {
    addPerformanceNavigationTiming(transaction, entry, 'unloadEvent', timeOrigin);
    addPerformanceNavigationTiming(transaction, entry, 'redirect', timeOrigin);
    addPerformanceNavigationTiming(transaction, entry, 'domContentLoadedEvent', timeOrigin);
    addPerformanceNavigationTiming(transaction, entry, 'loadEvent', timeOrigin);
    addPerformanceNavigationTiming(transaction, entry, 'connect', timeOrigin);
    addPerformanceNavigationTiming(transaction, entry, 'secureConnection', timeOrigin, 'connectEnd');
    addPerformanceNavigationTiming(transaction, entry, 'fetch', timeOrigin, 'domainLookupStart');
    addPerformanceNavigationTiming(transaction, entry, 'domainLookup', timeOrigin);
    addRequest(transaction, entry, timeOrigin);
}
/** Create measure related spans */
function addMeasureSpans(transaction, entry, startTime, duration, timeOrigin) {
    var measureStartTimestamp = timeOrigin + startTime;
    var measureEndTimestamp = measureStartTimestamp + duration;
    _startChild(transaction, {
        description: entry.name,
        endTimestamp: measureEndTimestamp,
        op: entry.entryType,
        startTimestamp: measureStartTimestamp,
    });
    return measureStartTimestamp;
}
/** Create resource-related spans */
export function addResourceSpans(transaction, entry, resourceName, startTime, duration, timeOrigin) {
    // we already instrument based on fetch and xhr, so we don't need to
    // duplicate spans here.
    if (entry.initiatorType === 'xmlhttprequest' || entry.initiatorType === 'fetch') {
        return undefined;
    }
    var data = {};
    if ('transferSize' in entry) {
        data['Transfer Size'] = entry.transferSize;
    }
    if ('encodedBodySize' in entry) {
        data['Encoded Body Size'] = entry.encodedBodySize;
    }
    if ('decodedBodySize' in entry) {
        data['Decoded Body Size'] = entry.decodedBodySize;
    }
    var startTimestamp = timeOrigin + startTime;
    var endTimestamp = startTimestamp + duration;
    _startChild(transaction, {
        description: resourceName,
        endTimestamp: endTimestamp,
        op: entry.initiatorType ? "resource." + entry.initiatorType : 'resource',
        startTimestamp: startTimestamp,
        data: data,
    });
    return endTimestamp;
}
/** Create performance navigation related spans */
function addPerformanceNavigationTiming(transaction, entry, event, timeOrigin, eventEnd) {
    var end = eventEnd ? entry[eventEnd] : entry[event + "End"];
    var start = entry[event + "Start"];
    if (!start || !end) {
        return;
    }
    _startChild(transaction, {
        op: 'browser',
        description: event,
        startTimestamp: timeOrigin + msToSec(start),
        endTimestamp: timeOrigin + msToSec(end),
    });
}
/** Create request and response related spans */
function addRequest(transaction, entry, timeOrigin) {
    _startChild(transaction, {
        op: 'browser',
        description: 'request',
        startTimestamp: timeOrigin + msToSec(entry.requestStart),
        endTimestamp: timeOrigin + msToSec(entry.responseEnd),
    });
    _startChild(transaction, {
        op: 'browser',
        description: 'response',
        startTimestamp: timeOrigin + msToSec(entry.responseStart),
        endTimestamp: timeOrigin + msToSec(entry.responseEnd),
    });
}
/**
 * Helper function to start child on transactions. This function will make sure that the transaction will
 * use the start timestamp of the created child span if it is earlier than the transactions actual
 * start timestamp.
 */
export function _startChild(transaction, _a) {
    var startTimestamp = _a.startTimestamp, ctx = __rest(_a, ["startTimestamp"]);
    if (startTimestamp && transaction.startTimestamp > startTimestamp) {
        transaction.startTimestamp = startTimestamp;
    }
    return transaction.startChild(__assign({ startTimestamp: startTimestamp }, ctx));
}
/**
 * Checks if a given value is a valid measurement value.
 */
function isMeasurementValue(value) {
    return typeof value === 'number' && isFinite(value);
}
//# sourceMappingURL=metrics.js.map{"version":3,"file":"metrics.js","sourceRoot":"","sources":["../../src/browser/metrics.ts"],"names":[],"mappings":"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