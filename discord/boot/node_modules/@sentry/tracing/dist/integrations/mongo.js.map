int/no-explicit-any\n    const options = (handlerData.args[1] = (handlerData.args[1] as { [key: string]: any }) || {});\n    let headers = options.headers;\n    if (isInstanceOf(request, Request)) {\n      headers = (request as Request).headers;\n    }\n    if (headers) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      if (typeof headers.append === 'function') {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        headers.append('sentry-trace', span.toTraceparent());\n      } else if (Array.isArray(headers)) {\n        headers = [...headers, ['sentry-trace', span.toTraceparent()]];\n      } else {\n        headers = { ...headers, 'sentry-trace': span.toTraceparent() };\n      }\n    } else {\n      headers = { 'sentry-trace': span.toTraceparent() };\n    }\n    options.headers = headers;\n  }\n}\n\n/**\n * Create and track xhr request spans\n */\nexport function xhrCallback(\n  handlerData: XHRData,\n  shouldCreateSpan: (url: string) => boolean,\n  spans: Record<string, Span>,\n): void {\n  const currentClientOptions = getCurrentHub()\n    .getClient()\n    ?.getOptions();\n  if (\n    !(currentClientOptions && hasTracingEnabled(currentClientOptions)) ||\n    !(handlerData.xhr && handlerData.xhr.__sentry_xhr__ && shouldCreateSpan(handlerData.xhr.__sentry_xhr__.url)) ||\n    handlerData.xhr.__sentry_own_request__\n  ) {\n    return;\n  }\n\n  const xhr = handlerData.xhr.__sentry_xhr__;\n\n  // check first if the request has finished and is tracked by an existing span which should now end\n  if (handlerData.endTimestamp && handlerData.xhr.__sentry_xhr_span_id__) {\n    const span = spans[handlerData.xhr.__sentry_xhr_span_id__];\n    if (span) {\n      span.setHttpStatus(xhr.status_code);\n      span.finish();\n\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete spans[handlerData.xhr.__sentry_xhr_span_id__];\n    }\n    return;\n  }\n\n  // if not, create a new span to track it\n  const activeTransaction = getActiveTransaction();\n  if (activeTransaction) {\n    const span = activeTransaction.startChild({\n      data: {\n        ...xhr.data,\n        type: 'xhr',\n        method: xhr.method,\n        url: xhr.url,\n      },\n      description: `${xhr.method} ${xhr.url}`,\n      op: 'http',\n    });\n\n    handlerData.xhr.__sentry_xhr_span_id__ = span.spanId;\n    spans[handlerData.xhr.__sentry_xhr_span_id__] = span;\n\n    if (handlerData.xhr.setRequestHeader) {\n      try {\n        handlerData.xhr.setRequestHeader('sentry-trace', span.toTraceparent());\n      } catch (_) {\n        // Error: InvalidStateError: Failed to execute 'setRequestHeader' on 'XMLHttpRequest': The object's state must be OPENED.\n      }\n    }\n  }\n}\n"]}import { Transaction, TransactionContext } from '@sentry/types';
/**
 * Default function implementing pageload and navigation transactions
 */
export declare function defaultRoutingInstrumentation<T extends Transaction>(startTransaction: (context: TransactionContext) => T | undefined, startTransactionOnPageLoad?: boolean, startTransactionOnLocationChange?: boolean): void;
//# sourceMappingURL=router.d.ts.map{"version":3,"file":"router.d.ts","sourceRoot":"","sources":["../../src/browser/router.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,WAAW,EAAE,kBAAkB,EAAE,MAAM,eAAe,CAAC;AAKhE;;GAEG;AACH,wBAAgB,6BAA6B,CAAC,CAAC,SAAS,WAAW,EACjE,gBAAgB,EAAE,CAAC,OAAO,EAAE,kBAAkB,KAAK,CAAC,GAAG,SAAS,EAChE,0BAA0B,GAAE,OAAc,EAC1C,gCAAgC,GAAE,OAAc,GAC/C,IAAI,CA2CN"}Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = require("@sentry/utils");
var global = utils_1.getGlobalObject();
/**
 * Default function implementing pageload and navigation transactions
 */
function defaultRoutingInstrumentation(startTransaction, startTransactionOnPageLoad, startTransactionOnLocationChange) {
    if (startTransactionOnPageLoad === void 0) { startTransactionOnPageLoad = true; }
    if (startTransactionOnLocationChange === void 0) { startTransactionOnLocationChange = true; }
    if (!global || !global.location) {
        utils_1.logger.warn('Could not initialize routing instrumentation due to invalid location');
        return;
    }
    var startingUrl = global.location.href;
    var activeTransaction;
    if (startTransactionOnPageLoad) {
        activeTransaction = startTransaction({ name: global.location.pathname, op: 'pageload' });
    }
    if (startTransactionOnLocationChange) {
        utils_1.addInstrumentationHandler({
            callback: function (_a) {
                var to = _a.to, from = _a.from;
                /**
                 * This early return is there to account for some cases where a navigation transaction starts right after
                 * long-running pageload. We make sure that if `from` is undefined and a valid `startingURL` exists, we don't
                 * create an uneccessary navigation transaction.
                 *
                 * This was hard to duplicate, but this behavior stopped as soon as this fix was applied. This issue might also
                 * only be caused in certain development environments where the usage of a hot module reloader is causing
                 * errors.
                 */
                if (from === undefined && startingUrl && startingUrl.indexOf(to) !== -1) {
                    startingUrl = undefined;
                    return;
                }
                if (from !== to) {
                    startingUrl = undefined;
                    if (activeTransaction) {
                        utils_1.logger.log("[Tracing] Finishing current transaction with op: " + activeTransaction.op);
                        // If there's an open transaction on the scope, we need to finish it before creating an new one.
                        activeTransaction.finish();
                    }
                    activeTransaction = startTransaction({ name: global.location.pathname, op: 'navigation' });
                }
            },
            type: 'history',
        });
    }
}
exports.defaultRoutingInstrumentation = defaultRoutingInstrumentation;
//# sourceMappingURL=router.js.map{"version":3,"file":"router.js","sourceRoot":"","sources":["../../src/browser/router.ts"],"names":[],"mappings":";AACA,uCAAmF;AAEnF,IAAM,MAAM,GAAG,uBAAe,EAAU,CAAC;AAEzC;;GAEG;AACH,SAAgB,6BAA6B,CAC3C,gBAAgE,EAChE,0BAA0C,EAC1C,gCAAgD;IADhD,2CAAA,EAAA,iCAA0C;IAC1C,iDAAA,EAAA,uCAAgD;IAEhD,IAAI,CAAC,MAAM,IAAI,CAAC,MAAM,CAAC,QAAQ,EAAE;QAC/B,cAAM,CAAC,IAAI,CAAC,sEAAsE,CAAC,CAAC;QACpF,OAAO;KACR;IAED,IAAI,WAAW,GAAuB,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC;IAE3D,IAAI,iBAAgC,CAAC;IACrC,IAAI,0BAA0B,EAAE;QAC9B,iBAAiB,GAAG,gBAAgB,CAAC,EAAE,IAAI,EAAE,MAAM,CAAC,QAAQ,CAAC,QAAQ,EAAE,EAAE,EAAE,UAAU,EAAE,CAAC,CAAC;KAC1F;IAED,IAAI,gCAAgC,EAAE;QACpC,iCAAyB,CAAC;YACxB,QAAQ,EAAE,UAAC,EAA2C;oBAAzC,UAAE,EAAE,cAAI;gBACnB;;;;;;;;mBAQG;gBACH,IAAI,IAAI,KAAK,SAAS,IAAI,WAAW,IAAI,WAAW,CAAC,OAAO,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,EAAE;oBACvE,WAAW,GAAG,SAAS,CAAC;oBACxB,OAAO;iBACR;gBAED,IAAI,IAAI,KAAK,EAAE,EAAE;oBACf,WAAW,GAAG,SAAS,CAAC;oBACxB,IAAI,iBAAiB,EAAE;wBACrB,cAAM,CAAC,GAAG,CAAC,sDAAoD,iBAAiB,CAAC,EAAI,CAAC,CAAC;wBACvF,gGAAgG;wBAChG,iBAAiB,CAAC,MAAM,EAAE,CAAC;qBAC5B;oBACD,iBAAiB,GAAG,gBAAgB,CAAC,EAAE,IAAI,EAAE,MAAM,CAAC,QAAQ,CAAC,QAAQ,EAAE,EAAE,EAAE,YAAY,EAAE,CAAC,CAAC;iBAC5F;YACH,CAAC;YACD,IAAI,EAAE,SAAS;SAChB,CAAC,CAAC;KACJ;AACH,CAAC;AA/CD,sEA+CC","sourcesContent":["import { Transaction, TransactionContext } from '@sentry/types';\nimport { addInstrumentationHandler, getGlobalObject, logger } from '@sentry/utils';\n\nconst global = getGlobalObject<Window>();\n\n/**\n * Default function implementing pageload and navigation transactions\n */\nexport function defaultRoutingInstrumentation<T extends Transaction>(\n  startTransaction: (context: TransactionContext) => T | undefined,\n  startTransactionOnPageLoad: boolean = true,\n  startTransactionOnLocationChange: boolean = true,\n): void {\n  if (!global || !global.location) {\n    logger.warn('Could not initialize routing instrumentation due to invalid location');\n    return;\n  }\n\n  let startingUrl: string | undefined = global.location.href;\n\n  let activeTransaction: T | undefined;\n  if (startTransactionOnPageLoad) {\n    activeTransaction = startTransaction({ name: global.location.pathname, op: 'pageload' });\n  }\n\n  if (startTransactionOnLocationChange) {\n    addInstrumentationHandler({\n      callback: ({ to, from }: { to: string; from?: string }) => {\n        /**\n         * This early return is there to account for some cases where a navigation transaction starts right after\n         * long-running pageload. We make sure that if `from` is undefined and a valid `startingURL` exists, we don't\n         * create an uneccessary navigation transaction.\n         *\n         * This was hard to duplicate, but this behavior stopped as soon as this fix was applied. This issue might also\n         * only be caused in certain development environments where the usage of a hot module reloader is causing\n         * errors.\n         */\n        if (from === undefined && startingUrl && startingUrl.indexOf(to) !== -1) {\n          startingUrl = undefined;\n          return;\n        }\n\n        if (from !== to) {\n          startingUrl = undefined;\n          if (activeTransaction) {\n            logger.log(`[Tracing] Finishing current transaction with op: ${activeTransaction.op}`);\n            // If there's an open transaction on the scope, we need to finish it before creating an new one.\n            activeTransaction.finish();\n          }\n          activeTransaction = startTransaction({ name: global.location.pathname, op: 'navigation' });\n        }\n      },\n      type: 'history',\n    });\n  }\n}\n"]}import { ReportHandler } from './types';
export declare const getCLS: (onReport: ReportHandler, reportAllChanges?: boolean) => void;
//# sourceMappingURL=getCLS.d.ts.map{"version":3,"file":"getCLS.d.ts","sourceRoot":"","sources":["../../../src/browser/web-vitals/getCLS.ts"],"names":[],"mappings":"AAoBA,OAAO,EAAE,aAAa,EAAE,MAAM,SAAS,CAAC;AAQxC,eAAO,MAAM,MAAM,+DA2BlB,CAAC"}/*
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var bindReporter_1 = require("./lib/bindReporter");
var initMetric_1 = require("./lib/initMetric");
var observe_1 = require("./lib/observe");
var onHidden_1 = require("./lib/onHidden");
exports.getCLS = function (onReport, reportAllChanges) {
    if (reportAllChanges === void 0) { reportAllChanges = false; }
    var metric = initMetric_1.initMetric('CLS', 0);
    var report;
    var entryHandler = function (entry) {
        // Only count layout shifts without recent user input.
        if (!entry.hadRecentInput) {
            metric.value += entry.value;
            metric.entries.push(entry);
            report();
        }
    };
    var po = observe_1.observe('layout-shift', entryHandler);
    if (po) {
        report = bindReporter_1.bindReporter(onReport, metric, po, reportAllChanges);
        onHidden_1.onHidden(function (_a) {
            var isUnloading = _a.isUnloading;
            po.takeRecords().map(entryHandler);
            if (isUnloading) {
                metric.isFinal = true;
            }
            report();
        });
    }
};
//# sourceMappingURL=getCLS.js.map{"version":3,"file":"getCLS.js","sourceRoot":"","sources":["../../../src/browser/web-vitals/getCLS.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;GAcG;;AAEH,mDAAkD;AAClD,+CAA8C;AAC9C,yCAAiE;AACjE,2CAA0C;AAS7B,QAAA,MAAM,GAAG,UAAC,QAAuB,EAAE,gBAAwB;IAAxB,iCAAA,EAAA,wBAAwB;IACtE,IAAM,MAAM,GAAG,uBAAU,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;IAEpC,IAAI,MAAuC,CAAC;IAE5C,IAAM,YAAY,GAAG,UAAC,KAAkB;QACtC,sDAAsD;QACtD,IAAI,CAAC,KAAK,CAAC,cAAc,EAAE;YACxB,MAAM,CAAC,KAAgB,IAAI,KAAK,CAAC,KAAK,CAAC;YACxC,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YAC3B,MAAM,EAAE,CAAC;SACV;IACH,CAAC,CAAC;IAEF,IAAM,EAAE,GAAG,iBAAO,CAAC,cAAc,EAAE,YAAuC,CAAC,CAAC;IAC5E,IAAI,EAAE,EAAE;QACN,MAAM,GAAG,2BAAY,CAAC,QAAQ,EAAE,MAAM,EAAE,EAAE,EAAE,gBAAgB,CAAC,CAAC;QAE9D,mBAAQ,CAAC,UAAC,EAAe;gBAAb,4BAAW;YACrB,EAAE,CAAC,WAAW,EAAE,CAAC,GAAG,CAAC,YAAuC,CAAC,CAAC;YAE9D,IAAI,WAAW,EAAE;gBACf,MAAM,CAAC,OAAO,GAAG,IAAI,CAAC;aACvB;YACD,MAAM,EAAE,CAAC;QACX,CAAC,CAAC,CAAC;KACJ;AACH,CAAC,CAAC","sourcesContent":["/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { bindReporter } from './lib/bindReporter';\nimport { initMetric } from