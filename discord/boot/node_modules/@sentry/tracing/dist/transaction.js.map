ck,\n    type: 'unhandledrejection',\n  });\n}\n\n/**\n * If an error or unhandled promise occurs, we mark the active transaction as failed\n */\nfunction errorCallback(): void {\n  const activeTransaction = getActiveTransaction();\n  if (activeTransaction) {\n    logger.log(`[Tracing] Transaction: ${SpanStatus.InternalError} -> Global error occured`);\n    activeTransaction.setStatus(SpanStatus.InternalError);\n  }\n}\n"]}import { Hub } from '@sentry/hub';
import { TransactionContext } from '@sentry/types';
import { IdleTransaction } from './idletransaction';
/**
 * Create new idle transaction.
 */
export declare function startIdleTransaction(hub: Hub, transactionContext: TransactionContext, idleTimeout?: number, onScope?: boolean): IdleTransaction;
/**
 * @private
 */
export declare function _addTracingExtensions(): void;
/**
 * This patches the global object and injects the Tracing extensions methods
 */
export declare function addExtensionMethods(): void;
//# sourceMappingURL=hubextensions.d.ts.map{"version":3,"file":"hubextensions.d.ts","sourceRoot":"","sources":["../src/hubextensions.ts"],"names":[],"mappings":"AAAA,OAAO,EAAmC,GAAG,EAAE,MAAM,aAAa,CAAC;AACnE,OAAO,EAA0C,kBAAkB,EAA6B,MAAM,eAAe,CAAC;AAWtH,OAAO,EAAE,eAAe,EAAE,MAAM,mBAAmB,CAAC;AAiNpD;;GAEG;AACH,wBAAgB,oBAAoB,CAClC,GAAG,EAAE,GAAG,EACR,kBAAkB,EAAE,kBAAkB,EACtC,WAAW,CAAC,EAAE,MAAM,EACpB,OAAO,CAAC,EAAE,OAAO,GAChB,eAAe,CAGjB;AAED;;GAEG;AACH,wBAAgB,qBAAqB,IAAI,IAAI,CAW5C;AAED;;GAEG;AACH,wBAAgB,mBAAmB,IAAI,IAAI,CAK1C"}Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var hub_1 = require("@sentry/hub");
var types_1 = require("@sentry/types");
var utils_1 = require("@sentry/utils");
var errors_1 = require("./errors");
var idletransaction_1 = require("./idletransaction");
var transaction_1 = require("./transaction");
var utils_2 = require("./utils");
/** Returns all trace headers that are currently on the top scope. */
function traceHeaders() {
    var scope = this.getScope();
    if (scope) {
        var span = scope.getSpan();
        if (span) {
            return {
                'sentry-trace': span.toTraceparent(),
            };
        }
    }
    return {};
}
/**
 * Makes a sampling decision for the given transaction and stores it on the transaction.
 *
 * Called every time a transaction is created. Only transactions which emerge with a `sampled` value of `true` will be
 * sent to Sentry.
 *
 * @param hub: The hub off of which to read config options
 * @param transaction: The transaction needing a sampling decision
 * @param samplingContext: Default and user-provided data which may be used to help make the decision
 *
 * @returns The given transaction with its `sampled` value set
 */
function sample(hub, transaction, samplingContext) {
    var _a;
    var client = hub.getClient();
    var options = (client && client.getOptions()) || {};
    // nothing to do if there's no client or if tracing is disabled
    if (!client || !utils_2.hasTracingEnabled(options)) {
        transaction.sampled = false;
        return transaction;
    }
    // if the user has forced a sampling decision by passing a `sampled` value in their transaction context, go with that
    if (transaction.sampled !== undefined) {
        transaction.tags = tslib_1.__assign(tslib_1.__assign({}, transaction.tags), { __sentry_samplingMethod: types_1.TransactionSamplingMethod.Explicit });
        return transaction;
    }
    // we would have bailed already if neither `tracesSampler` nor `tracesSampleRate` were defined, so one of these should
    // work; prefer the hook if so
    var sampleRate;
    if (typeof options.tracesSampler === 'function') {
        sampleRate = options.tracesSampler(samplingContext);
        // cast the rate to a number first in case it's a boolean
        transaction.tags = tslib_1.__assign(tslib_1.__assign({}, transaction.tags), { __sentry_samplingMethod: types_1.TransactionSamplingMethod.Sampler, 
            // TODO kmclb - once tag types are loosened, don't need to cast to string here
            __sentry_sampleRate: String(Number(sampleRate)) });
    }
    else if (samplingContext.parentSampled !== undefined) {
        sampleRate = samplingContext.parentSampled;
        transaction.tags = tslib_1.__assign(tslib_1.__assign({}, transaction.tags), { __sentry_samplingMethod: types_1.TransactionSamplingMethod.Inheritance });
    }
    else {
        sampleRate = options.tracesSampleRate;
        // cast the rate to a number first in case it's a boolean
        transaction.tags = tslib_1.__assign(tslib_1.__assign({}, transaction.tags), { __sentry_samplingMethod: types_1.TransactionSamplingMethod.Rate, 
            // TODO kmclb - once tag types are loosened, don't need to cast to string here
            __sentry_sampleRate: String(Number(sampleRate)) });
    }
    // Since this is coming from the user (or from a function provided by the user), who knows what we might get. (The
    // only valid values are booleans or numbers between 0 and 1.)
    if (!isValidSampleRate(sampleRate)) {
        utils_1.logger.warn("[Tracing] Discarding transaction because of invalid sample rate.");
        transaction.sampled = false;
        return transaction;
    }
    // if the function returned 0 (or false), or if `tracesSampleRate` is 0, it's a sign the transaction should be dropped
    if (!sampleRate) {
        utils_1.logger.log("[Tracing] Discarding transaction because " + (typeof options.tracesSampler === 'function'
            ? 'tracesSampler returned 0 or false'
            : 'a negative sampling decision was inherited or tracesSampleRate is set to 0'));
        transaction.sampled = false;
        return transaction;
    }
    // Now we roll the dice. Math.random is inclusive of 0, but not of 1, so strict < is safe here. In case sampleRate is
    // a boolean, the < comparison will cause it to be automatically cast to 1 if it's true and 0 if it's false.
    transaction.sampled = Math.random() < sampleRate;
    // if we're not going to keep it, we're done
    if (!transaction.sampled) {
        utils_1.logger.log("[Tracing] Discarding transaction because it's not included in the random sample (sampling rate = " + Number(sampleRate) + ")");
        return transaction;
    }
    // at this point we know we're keeping the transaction, whether because of an inherited decision or because it got
    // lucky with t