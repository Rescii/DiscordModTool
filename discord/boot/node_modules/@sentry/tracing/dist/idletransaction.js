Starting ${finalContext.op} transaction on scope`);\n    idleTransaction.registerBeforeFinishCallback((transaction, endTimestamp) => {\n      this._metrics.addPerformanceEntries(transaction);\n      adjustTransactionDuration(secToMs(maxTransactionDuration), transaction, endTimestamp);\n    });\n\n    return idleTransaction as Transaction;\n  }\n}\n\n/**\n * Gets transaction context from a sentry-trace meta.\n *\n * @returns Transaction context data from the header or undefined if there's no header or the header is malformed\n */\nexport function getHeaderContext(): Partial<TransactionContext> | undefined {\n  const header = getMetaContent('sentry-trace');\n  if (header) {\n    return extractTraceparentData(header);\n  }\n\n  return undefined;\n}\n\n/** Returns the value of a meta tag */\nexport function getMetaContent(metaName: string): string | null {\n  const el = document.querySelector(`meta[name=${metaName}]`);\n  return el ? el.getAttribute('content') : null;\n}\n\n/** Adjusts transaction value based on max transaction duration */\nfunction adjustTransactionDuration(maxDuration: number, transaction: IdleTransaction, endTimestamp: number): void {\n  const diff = endTimestamp - transaction.startTimestamp;\n  const isOutdatedTransaction = endTimestamp && (diff > maxDuration || diff < 0);\n  if (isOutdatedTransaction) {\n    transaction.setStatus(SpanStatus.DeadlineExceeded);\n    transaction.setTag('maxTransactionDurationExceeded', 'true');\n  }\n}\n"]}export { BrowserTracing } from './browsertracing';
export { registerRequestInstrumentation, RequestInstrumentationOptions, defaultRequestInstrumentationOptions, } from './request';
//# sourceMappingURL=index.d.ts.map{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../../src/browser/index.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,cAAc,EAAE,MAAM,kBAAkB,CAAC;AAClD,OAAO,EACL,8BAA8B,EAC9B,6BAA6B,EAC7B,oCAAoC,GACrC,MAAM,WAAW,CAAC"}Object.defineProperty(exports, "__esModule", { value: true });
var browsertracing_1 = require("./browsertracing");
exports.BrowserTracing = browsertracing_1.BrowserTracing;
var request_1 = require("./request");
exports.registerRequestInstrumentation = request_1.registerRequestInstrumentation;
exports.defaultRequestInstrumentationOptions = request_1.defaultRequestInstrumentationOptions;
//# sourceMappingURL=index.js.map{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/browser/index.ts"],"names":[],"mappings":";AAAA,mDAAkD;AAAzC,0CAAA,cAAc,CAAA;AACvB,qCAImB;AAHjB,mDAAA,8BAA8B,CAAA;AAE9B,yDAAA,oCAAoC,CAAA","sourcesContent":["export { BrowserTracing } from './browsertracing';\nexport {\n  registerRequestInstrumentation,\n  RequestInstrumentationOptions,\n  defaultRequestInstrumentationOptions,\n} from './request';\n"]}import { SpanContext } from '@sentry/types';
import { Span } from '../span';
import { Transaction } from '../transaction';
/** Class tracking metrics  */
export declare class MetricsInstrumentation {
    private _measurements;
    private _performanceCursor;
    constructor();
    /** Add performance related spans to a transaction */
    addPerformanceEntries(transaction: Transaction): void;
    /** Starts tracking the Cumulative Layout Shift on the current page. */
    private _trackCLS;
    /**
     * Capture the information of the user agent.
     */
    private _trackNavigator;
    /** Starts tracking the Largest Contentful Paint on the current page. */
    private _trackLCP;
    /** Starts tracking the First Input Delay on the current page. */
    private _trackFID;
    /** Starts tracking the Time to First Byte on the current page. */
    private _trackTTFB;
}
export interface ResourceEntry extends Record<string, unknown> {
    initiatorType?: string;
    transferSize?: number;
    encodedBodySize?: number;
    decodedBodySize?: number;
}
/** Create resource-related spans */
export declare function addResourceSpans(transaction: Transaction, entry: ResourceEntry, resourceName: string, startTime: number, duration: number, timeOrigin: number): number | undefined;
/**
 * Helper function to start child on transactions. This function will make sure that the transaction will
 * use the start timestamp of the created child span if it is earlier than the transactions actual
 * start timestamp.
 */
export declare function _startChild(transaction: Transaction, { startTimestamp, ...ctx }: SpanContext): Span;
//# sourceMappingURL=metrics.d.ts.map{"version":3,"file":"metrics.d.ts","sourceRoot":"","sources":["../../src/browser/metrics.ts"],"names":[],"mappings":"AAEA,OAAO,EAAgB,WAAW,EAAE,MAAM,eAAe,CAAC;AAG1D,OAAO,EAAE,IAAI,EAAE,MAAM,SAAS,CAAC;AAC/B,OAAO,EAAE,WAAW,EAAE,MAAM,gBAAgB,CAAC;AAW7C,8BAA8B;AAC9B,qBAAa,sBAAsB;IACjC,OAAO,CAAC,aAAa,CAAoB;IAEzC,OAAO,CAAC,kBAAkB,CAAa;;IAevC,qDAAqD;IAC9C,qBAAqB,CAAC,WAAW,EAAE,WAAW,GAAG,IAAI;IA0I5D,uEAAuE;IACvE,OAAO,CAAC,SAAS;IAajB;;OAEG;IACH,OAAO,CAAC,eAAe;IAqCvB,wEAAwE;IACxE,OAAO,CAAC,SAAS;IAgBjB,iEAAiE;IACjE,OAAO,CAAC,SAAS;IAgBjB,kEAAkE;IAClE,OAAO,CAAC,UAAU;CAgBnB;AAoCD,MAAM,WAAW,aAAc,SAAQ,MAAM,CAAC,MAAM,EAAE,OAAO,CAAC;IAC5D,aAAa,CAAC,EAAE,MAAM,CAAC;IACvB,YAAY,CAAC,EAAE,MAAM,CAAC;IACtB,eAAe,CAAC,EAAE,MAAM,CAAC;IACzB,eAAe,CAAC,EAAE,MAAM,CAAC;CAC1B;AAED,oCAAoC;AACpC,wBAAgB,gBAAgB,CAC9B,WAAW,EAAE,WAAW,EACxB,KAAK,EAAE,aAAa,EACpB,YAAY,EAAE,MAAM,EACpB,SAAS,EAAE,MAAM,EACjB,QAAQ,EAAE,MAAM,EAChB,UAAU,EAAE,MAAM,GACjB,MAAM,GAAG,SAAS,CA8BpB;AAwCD;;;;GAIG;AACH,wBAAgB,WAAW,CAAC,WAAW,EAAE,WAAW,EAAE,EAAE,cAAc,EAAE,GAAG,GAAG,EAAE,EAAE,WAAW,GAAG,IAAI,CASnG"}Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var utils_1 = require("@sentry/utils");
var utils_2 = require("../utils");
var getCLS_1 = require("./web-vitals/getCLS");
var getFID_1 = require("./web-vitals/getFID");
var getLCP_1 = require("./web-vitals/getLCP");
var getTTFB_1 = require("./web-vitals/getTTFB");
var getFirstHidden_1 = require("./web-vitals/lib/getFirstHidden");
var global = utils_1.getGlobalObject();
/** Class tracking metrics  */
var MetricsInstrumentation = /** @class */ (function () {
    function MetricsInstrumentation() {
        this._measurements = {};
        this._performanceCursor = 0;
        if (global && global.performance) {
            if (global.performance.mark) {
                global.performance.mark('sentry-tracing-init');
            }
            this._trackCLS();
            this._trackLCP();
            this._trackFID();
            this._trackTTFB();
        }
    }
    /** Add performance related spans to a transaction */
    MetricsInstrumentation.prototype.addPerformanceEntries = function (transaction) {
        var _this = this;
        if (!global || !global.performance || !global.performance.getEntries || !utils_1.browserPerformanceTimeOrigin) {
            // Gatekeeper if performance API not available
            return;
        }
        utils_1.logger.log('[Tracing] Adding & adjusting spans using Performance API');
        var timeOrigin = utils_2.msToSec(utils_1.browserPerformanceTimeOrigin);
        var entryScriptSrc;
        if (global.document) {
            // eslint-disable-next-line @typescript-eslint/prefer-for-of
            for (var i = 0; i < document.scripts.length; i++) {
                // We go through all scripts on the page and look for 'data-entry'
                // We remember the name and measure the time between this script finished loading and
                // our mark 'sentry-tracing-init'
                if (document.scripts[i].dataset.entry === 'true') {
                    entryScriptSrc = document.scripts[i].src;
                    break;
                }
            }
        }
        var entryScriptStartTimestamp;
        var tracingInitMarkStartTime;
        global.performance
            .getEntries()
            .slice(this._performanceCursor)
            .forEach(function (entry) {
            var startTime = utils_2.msToSec(entry.startTime);
            var duration = utils_2.msToSec(entry.duration);
            if (transaction.op === 'navigation' && timeOrigin + startTime < transaction.startTimestamp) {
                return;
            }
            switch (entry.entryType) {
                case 'navigation':
                    addNavigationSpans(transaction, entry, timeOrigin);
                    break;
                case 'mark':
                case 'paint':
                case 'measure': {
                    var startTimestamp = addMeasureSpans(transaction, entry, startTime, duration, timeOrigin);
                    if (tracingInitMarkStartTime === undefined && entry.name === 'sentry-tracing-init') {
                        tracingInitMarkStartTime = startTimestamp;
                    }
                    // capture web vitals
                    var firstHidden = getFirstHidden_1.getFirstHidden();
                    // Only report if the page wasn't hidden prior to the web vital.
                    var shouldRecord = entry.startTime < firstHidden.timeStamp;
                    if (entry.name === 'first-paint' && shouldRecord) {
                        utils_1.logger.log('[Measurements] Adding FP');
                        _this._measurements['fp'] = { value: entry.startTime };
                        _this._measurements['mark.fp'] = { value: startTimestamp };
                    }
                    if (entry.name === 'first-contentful-paint' && shouldRecord) {
                        utils_1.logger.log('[Measurements] Adding FCP');
                        _this._measurements['fcp'] = { value: entry.startTime };
                        _this._measurements['mark.fcp'] = { value: startTimestamp };
                    }
                    break;
                }
                case 'resource': {
                    var resourceName = entry.name.replace(window.location.origin, '');
                    var endTimestamp = addResourceSpans(transaction, entry, resourceName, startTime, duration, timeOrigin);
                    // We remember the entry script end time to calculate the difference to the first init mark
                    if (entryScriptStartTimestamp === undefined && (entryScriptSrc || '').indexOf(resourceName) > -1) {
                        entryScriptStartTimestamp = endTimestamp;
                    }
                    break;
                }
                default:
                // Ignore other entry types.
            }
        });
        if (entryScriptStartTimestamp !== undefined && tracingInitMarkStartTime !== undefined) {
            _startChild(transaction, {
                description: 'evaluation',
                endTimestamp: tracingInitMarkStartTime,
                op: 'script',
                startTimestamp: entryScriptStartTimestamp,
            });
        }
        this._performanceCursor = Math.max(performance.getEntries().length - 1, 0);
        this._trackNavigator(transaction);
        // Measurements are only available for pageload transactions
        if (transaction.op === 'pageload') {
            // normalize applicable web vital values to be relative to transaction.startTimestamp
            var timeOrigin_1 = utils_2.msToSec(utils_1.browserPerformanceTimeOrigin);
            ['fcp', 'fp', 'lcp', 'ttfb'].forEach(function (name) {
                if (!_this._measurements[name] || timeOrigin_1 >= transaction.startTimestamp) {
