s
      }
    }, progressCallback);
  }

  updateToLatest(progressCallback) {
    return this.updateToLatestWithOptions(null, progressCallback);
  }

  updateToLatestWithOptions(options, progressCallback) {
    return this._sendRequest({
      UpdateToLatest: {
        options
      }
    }, progressCallback);
  } // If the running host is current, adopt the current installed modules and
  // set up the module search path accordingly. If the running host is not
  // current, start the new current host and exit this process.


  async startCurrentVersion(options) {
    const versions = await this.queryCurrentVersions();
    await this.setRunningManifest(versions.last_successful_update);

    this._startCurrentVersionInner(options, versions);
  }

  startCurrentVersionSync(options) {
    const versions = this.queryCurrentVersionsSync();

    this._startCurrentVersionInner(options, versions);
  }

  async commitModules(versions) {
    if (this.committedHostVersion == null) {
      throw new Error('Cannot commit modules before host version.');
    }

    if (versions == null) {
      versions = await this.queryCurrentVersions();
    }

    this._commitModulesInner(versions);
  }

  setRunningInBackground() {
    this.isRunningI