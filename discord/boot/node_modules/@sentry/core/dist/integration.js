     encoding: 'utf-8'
      }).trim();
    } catch (_) {} // just in case lsb_release doesn't exist

  }

  const config = getCrashReporterArgs(metadata);
  electron.crashReporter.start(config);
  initialized = true;
}

function isInitialized() {
  return initialized;
}"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.flatten = flatten;
exports.reconcileCrashReporterMetadata = reconcileCrashReporterMetadata;

const {
  getElectronMajorVersion
} = require('./processUtils');

function flatten(metadata, prefix, root) {
  root = root ? root : {};
  prefix = prefix ? prefix : '';

  if (typeof metadata === 'object') {
    for (const key in metadata) {
      const next_prefix = prefix === '' ? key : `${prefix}[${key}]`;
      flatten(metadata[key], next_prefix, root);
    }
  } else {
    root[prefix] = metadata;
  }

  return root;
}

function reconcileCrashReporterMetadata(crashReporter, metadata) {
  if (getElectronMajorVersion() < 8) {
    return;
  }

  const new_metadata = flatten(metadata);
  const old_metadata = crashReporter.getParameters();

  for (const key in old_metadata) {
    if (!new_metadata.hasOwnProperty(key)) {
      crashReporter.removeExtraParameter(key);
    }
  }

  for (const key in new_metadata) {
    if (!old_metadata.hasOwnProperty(key)) {
      crashReporter.addExtraParameter(key, new_metadata[key]);
    }
  }
}"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

class FeatureFlags {
  constructor() {
    this.flags = new Set();
  }

  getSupported() {
    return Array.from(this.flags);
  }

  supports(feature) {
    return this.flags.has(feature);
  }

  declareSupported(feature) {
    if (this.supports(feature)) {
      console.error('Feature redeclared; is this a duplicate flag? ', feature);
      return;
    }

    this.flags.add(feature);
  }

}

exports.default = FeatureFlags;
module.exports = exports.default;"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.UPDATE_MANUALLY = exports.UPDATE_CHECK_FINISHED = exports.NO_PENDING_UPDATES = exports.INSTALLING_MODULE_PROGRESS = exports.INSTALLING_MODULES_FINISHED = exports.INSTALLING_MODULE = exports.INSTALLED_MODULE = exports.DOWNLOADING_MODULE_PROGRESS = exports.DOWNLOADING_MODULES_FINISHED = exports.DOWNLOADING_MODULE = exports.DOWNLOADED_MODULE = exports.CHECKING_FOR_UPDATES = void 0;
exports.checkForUpdates = checkForUpdates;
exports.events = void 0;
exports.getInstalled = getInstalled;
exports.init = init;
exports.initPathsOnly = initPathsOnly;
exports.install = install;
exports.installPendingUpdates = installPendingUpdates;
exports.isInstalled = isInstalled;
exports.quitAndInstallUpdates = quitAndInstallUpdates;
exports.setInBackground = setInBackground;
exports.supportsEventObjects = void 0;

var _fs = _interopRequireDefault(require("fs"));

var _path = _interopRequireDefault(require("path"));

var _module = _interopRequireDefault(require("module"));

var _events = require("events");

var _mkdirp = _interopRequireDefault(require("mkdirp"));

var _process = require("process");

var _yauzl = _interopRequireDefault(require("yauzl"));

var _Backoff = _interopRequireDefault(require("./Backoff"));

var paths = _interopRequireWildcard(require("./paths"));

function _getRequi