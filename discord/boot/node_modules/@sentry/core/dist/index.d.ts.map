Process.on('error', err => {
    // TODO: there should always be an error
    if (err != null) {
      err = err;
    }
  }); // TODO: don't listen to close, but listen to exit instead

  spawnedProcess.on('close', (code, signal) => {
    if (err === null && code !== 0) {
      err = new Error('Command failed: ' + (signal || code));
    }

    if (err != null) {
      err.code = err.code || code;
      err.stdout = err.stdout || stdout;
    }

    if (callback != null) {
      callback(err, stdout);
    }
  });
} // Spawn reg.exe and callback when it completes


function spawnReg(args, callback) {
  return spawn(regExe, args, callback);
} // TODO: since we're doing this one by one, we could have a more graceful way of processing the queue
//       