,GAAG,KAAK,CAAC;IACtB,OAAO,GAAuB,CAAC;AACjC,CAAC;AAED;;GAEG;AACH,wDAAwD;AACxD,SAAS,eAAe,CAAiC,GAAY,EAAE,KAAa;IAClF,KAAK,IAAM,IAAI,IAAI,KAAK,EAAE;QACxB,iDAAiD;QACjD,IAAI,CAAC,GAAG,CAAC,cAAc,CAAC,IAAI,CAAC,EAAE;YAC7B,8DAA8D;YAC9D,GAAG,CAAC,IAAI,CAAC,GAAG,KAAK,CAAC,IAAI,CAAC,CAAC;SACzB;KACF;IAED,OAAO,GAAuB,CAAC;AACjC,CAAC","sourcesContent":["export const setPrototypeOf =\n  Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? setProtoOf : mixinProperties);\n\n/**\n * setPrototypeOf polyfill using __proto__\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction setProtoOf<TTarget extends object, TProto>(obj: TTarget, proto: TProto): TTarget & TProto {\n  // @ts-ignore __proto__ does not exist on obj\n  obj.__proto__ = proto;\n  return obj as TTarget & TProto;\n}\n\n/**\n * setPrototypeOf polyfill using mixin\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction mixinProperties<TTarget extends object, TProto>(obj: TTarget, proto: TProto): TTarget & TProto {\n  for (const prop in proto) {\n    // eslint-disable-next-line no-prototype-builtins\n    if (!obj.hasOwnProperty(prop)) {\n      // @ts-ignore typescript complains about indexing so we remove\n      obj[prop] = proto[prop];\n    }\n  }\n\n  return obj as TTarget & TProto;\n}\n"]}/** A simple queue that holds promises. */
export declare class PromiseBuffer<T> {
    protected _limit?: number | undefined;
    /** Internal set of queued Promises */
    private readonly _buffer;
    constructor(_limit?: number | undefined);
    /**
     * Says if the buffer is ready to take more requests
     */
    isReady(): boolean;
    /**
     * Add a promise to the queue.
     *
     * @param task Can be any PromiseLike<T>
     * @returns The original promise.
     */
    add(task: PromiseLike<T>): PromiseLike<T>;
    /**
     * Remove a promise to the queue.
     *
     * @param task Can be any PromiseLike<T>
     * @returns Removed promise.
     */
    remove(task: PromiseLike<T>): PromiseLike<T>;
    /**
     * This function returns the number of unresolved promises in the queue.
     */
    length(): number;
    /**
     * This will drain the whole queue, returns true if queue is empty or drained.
     * If timeout is provided and the queue takes longer to drain, the promise still resolves but with false.
     *
     * @param timeout Number in ms to wait until it resolves with false.
     */
    drain(timeout?: number): PromiseLike<boolean>;
}
//# sourceMappingURL=promisebuffer.d.ts.mapObject.defineProperty(exports, "__esModule", { value: true });
var error_1 = require("./error");
var syncpromise_1 = require("./syncpromise");
/** A simple queue that holds promises. */
var PromiseBuffer = /** @class */ (function () {
    function PromiseBuffer(_limit) {
        this._limit = _limit;
        /** 