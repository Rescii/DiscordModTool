urcesContent":["import { getCurrentHub } from '@sentry/core';\nimport { Integration, Span } from '@sentry/types';\nimport { fill, logger, parseSemver } from '@sentry/utils';\nimport * as http from 'http';\nimport * as https from 'https';\n\nimport {\n  cleanSpanDescription,\n  extractUrl,\n  isSentryRequest,\n  normalizeRequestArgs,\n  RequestMethod,\n  RequestMethodArgs,\n} from './utils/http';\n\nconst NODE_VERSION = parseSemver(process.versions.node);\n\n/** http module integration */\nexport class Http implements Integration {\n  /**\n   * @inheritDoc\n   */\n  public static id: string = 'Http';\n\n  /**\n   * @inheritDoc\n   */\n  public name: string = Http.id;\n\n  /**\n   * @inheritDoc\n   */\n  private readonly _breadcrumbs: boolean;\n\n  /**\n   * @inheritDoc\n   */\n  private readonly _tracing: boolean;\n\n  /**\n   * @inheritDoc\n   */\n  public constructor(options: { breadcrumbs?: boolean; tracing?: boolean } = {}) {\n    this._breadcrumbs = typeof options.breadcrumbs === 'undefined' ? true : options.breadcrumbs;\n    this._tracing = typeof options.tracing === 'undefined' ? false : options.tracing;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setupOnce(): void {\n    // No need to instrument if we don't want to track anything\n    if (!this._breadcrumbs && !this._tracing) {\n      return;\n    }\n\n    const wrappedHandlerMaker = _createWrappedRequestMethodFactory(this._breadcrumbs, this._tracing);\n\n    const httpModule = require('http');\n    fill(httpModule, 'get', wrappedHandlerMaker);\n    fill(httpModule, 'request', wrappedHandlerMaker);\n\n    // NOTE: Prior to Node 9, `https` used internals of `http` module, thus we don't patch it.\n    // If we do, we'd get double breadcrumbs and double spans for `https` calls.\n    // It has been changed in Node 9, so for all versions equal and above, we patch `https` separately.\n    if (NODE_VERSION.major && NODE_VERSION.major > 8) {\n      const httpsModule = require('https');\n      fill(httpsModule, 'get', wrappedHandlerMaker);\n      fill(httpsModule, 'request', wrappedHandlerMaker);\n    }\n  }\n}\n\n// for ease of reading below\ntype OriginalRequestMethod = RequestMethod;\ntype WrappedRequestMethod = RequestMethod;\ntype WrappedRequestMethodFactory = (original: OriginalRequestMethod) => WrappedRequestMethod;\n\n/**\n * Function which creates a function which creates wrapped versions of internal `request` and `get` calls within `http`\n * and `https` modules. (NB: Not a typo - this is a creator^2!)\n *\n * @param breadcrumbsEnabled Whether or not to record outgoing requests as breadcrumbs\n * @param tracingEnabled Whether or not to record outgoing requests as tracing spans\n *\n * @returns A function which accepts the exiting handler and returns a wrapped handler\n */\nfunction _createWrappedRequestMethodFactory(\n  breadcrumbsEnabled: boolean,\n  tracingEnabled: boolean,\n): WrappedRequestMethodFactory {\n  return function wrappedRequestMethodFactory(originalRequestMethod: OriginalRequestMethod): WrappedRequestMethod {\n    return function wrappedMethod(this: typeof http | typeof https, ...args: RequestMethodArgs): http.ClientRequest {\n      // eslint-disable-next-line @typescript-eslint/no-this-alias\n      const httpModule = this;\n\n      const requestArgs = normalizeRequestArgs(args);\n      const requestOptions = requestArgs[0];\n      const requestUrl = extractUrl(requestOptions);\n\n      // we don't want to record requests to Sentry as either breadcrumbs or spans, so just use the original method\n      if (isSentryRequest(requestUrl)) {\n        return originalRequestMethod.apply(httpModule, requestArgs);\n      }\n\n      let span: Span | undefined;\n      let parentSpan: Span | undefined;\n\n      const scope = getCurrentHub().getScope();\n      if (scope && tracingEnabled) {\n        parentSpan = scope.getSpan();\n        if (parentSpan) {\n          span = parentSpan.startChild({\n            description: `${requestOptions.method || 'GET'} ${requestUrl}`,\n            op: 'request',\n          });\n\n          const sentryTraceHeader = span.toTraceparent();\n          logger.log(`[Tracing] Adding sentry-trace header to outgoing request: ${sentryTraceHeader}`);\n          requestOptions.headers = { ...requestOptions.headers, 'sentry-trace': sentryTraceHeader };\n        }\n      }\n\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      return originalRequestMethod\n        .apply(httpModule, requestArgs)\n        .once('response', function(this: http.ClientRequest, res: http.IncomingMessage): void {\n          // eslint-disable-next-line @typescript-eslint/no-this-alias\n          const req = this;\n          if (breadcrumbsEnabled) {\n            addRequestBreadcrumb('response', requestUrl, req, res);\n          }\n          if (tracingEnabled && span) {\n            if (res.statusCode) {\n              span.setHttpStatus(res.statusCode);\n            }\n            span.description = cleanSpanDescription(span.description, requestOptions, req);\n            span.finish();\n          }\n        })\n        .once('error', function(this: http.ClientRequest): void {\n          // eslint-disable-next-line @typescript-eslint/no-this-alias\n          const req = this;\n\n          if (breadcrumbsEnabled) {\n            addRequestBreadcrumb('error', requestUrl, req);\n          }\n          if (tracingEnabled && span) {\n            span.setHttpStatus(500);\n            span.description = cleanSpanDescription(span.description, requestOptions, req);\n            span.finish();\n          }\n        });\n    };\n  };\n}\n\n/**\n * Captures Breadcrumb based on provided request/response pair\n */\nfunction addRequestBreadcrumb(event: string, url: string, req: http.ClientRequest, res?: http.IncomingMessage): void {\n  if (!getCurrentHub().getIntegration(Http)) {\n    return;\n  }\n\n  getCurrentHub().addBreadcrumb(\n    {\n      category: 'http',\n      data: {\n        method: req.method,\n        status_code: res && res.statusCode,\n        url,\n      },\n      type: 'http',\n    },\n    {\n      event,\n      request: req,\n      response: res,\n    },\n  );\n}\n"]}export { Console } from './console';
export { Http } from './http';
export { OnUncaughtException } from './onuncaughtexception';
export { OnUnhandledRejection } from './onunhandledrejection';
export { LinkedErrors } from './linkederrors';
export { Modules } from './modules';
//# sourceMappingURL=index.d.ts.map{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../../src/integrations/index.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,OAAO,EAAE,MAAM,WAAW,CAAC;AACpC,OAAO,EAAE,IAAI,EAAE,MAAM,QAAQ,CAAC;AAC9B,OAAO,EAAE,mBAAmB,EAAE,MAAM,uBAAuB,CAAC;AAC5D,OAAO,EAAE,oBAAoB,EAAE,MAAM,wBAAwB,CAAC;AAC9D,OAAO,EAAE,YAAY,EAAE,MAAM,gBAAgB,CAAC;AAC9C,OAAO,EAAE,OAAO,EAAE,MAAM,WAAW,CAAC"}Object.defineProperty(exports, "__esModule", { value: true });
var console_1 = require("./console");
exports.Console = console_1.Console;
var http_1 = require("./http");
exports.Http = http_1.Http;
var onuncaughtexception_1 = require("./onuncaughtexception");
exports.OnUncaughtException = onuncaughtexception_1.OnUncaughtException;
var onunhandledrejection_1 = require("./onunhandledrejection");
exports.OnUnhandledRejection = onunhandledrejection_1.OnUnhandledRejection;
var linkederrors_1 = require("./linkederrors");
exports.LinkedErrors = linkederrors_1.LinkedErrors;
var modules_1 = require("./modules");
exports.Modules = modules_1.Modules;
//# sourceMappingURL=index.js.map{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/integrations/index.ts"],"names":[],"mappings":";AAAA,qCAAoC;AAA3B,4BAAA,OAAO,CAAA;AAChB,+BAA8B;AAArB,sBAAA,IAAI,CAAA;AACb,6DAA4D;AAAnD,oDAAA,mBAAmB,CAAA;AAC5B,+DAA8D;AAArD,sDAAA,oBAAoB,CAAA;AAC7B,+CAA8C;AAArC,sCAAA,YAAY,CAAA;AACrB,qCAAoC;AAA3B,4BAAA,OAAO,CAAA","sourcesContent":["export { Console } from './console';\nexport { Http } from './http';\nexport { OnUncaughtException } from './onuncaughtexception';\nexport { OnUnhandledRejection } from './onunhandledrejection';\nexport { LinkedErrors } from './linkederrors';\nexport { Modules } from './modules';\n"]}import { Integration } from '@sentry/types';
/** Adds SDK info to an event. */
export declare class LinkedErrors implements Integration {
    /**
     * @inheritDoc
     */
    static id: string;
    /**
     * @inheritDoc
     */
    readonly name: string;
    /**
     * @inheritDoc
     */
    private readonly _key;
    /**
     * @inheritDoc
     */
    private readonly _limit;
    /**
     * @inheritDoc
     */
    constructor(options?: {
        key?: string;
        limit?: number;
    });
    /**
     * @inheritDoc
     */
    setupOnce(): void;
    /**
     * @inheritDoc
     */
    private _handler;
    /**
     * @inheritDoc
     */
    private _walkErrorTree;
}
//# sourceMappingURL=linkederrors.d.ts.map{"version":3,"file":"linkederrors.d.ts","sourceRoot":"","sources":["../../src/integrations/linkederrors.ts"],"names":[],"mappings":"AACA,OAAO,EAA8C,WAAW,EAAE,MAAM,eAAe,CAAC;AAQxF,iCAAiC;AACjC,qBAAa,YAAa,YAAW,WAAW;IAC9C;;OAEG;IACH,OAAc,EAAE,EAAE,MAAM,CAAkB;IAE1C;;OAEG;IACH,SAAgB,IAAI,EAAE,MAAM,CAAmB;IAE/C;;OAEG;IACH,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAS;IAE9B;;OAEG;IACH,OAAO,CAAC,QAAQ,CAAC,MAAM,CAAS;IAEhC;;OAEG;gBACgB,OAAO,GAAE;QAAE,GAAG,CAAC,EAAE,MAAM,CAAC;QAAC,KAAK,CAAC,EAAE,MAAM,CAAA;KAAO;IAKjE;;OAEG;IACI,SAAS,IAAI,IAAI;IAWxB;;OAEG;IACH,OAAO,CAAC,QAAQ;IAmBhB;;OAEG;IACH,OAAO,CAAC,cAAc;CAkBvB"}Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var core_1 = require("@sentry/core");
var utils_1 = require("@sentry/utils");
var parsers_1 = require("../parsers");
var DEFAULT_KEY = 'cause';
var DEFAULT_LIMIT = 5;
/** Adds SDK info to an event. */
var LinkedErrors = /** @class */ (function () {
    /**
     * @inheritDoc
     */
    function LinkedErrors(options) {
        if (options === void 0) { options = {}; }
        /**
         * @inheritDoc
         */
        this.name = LinkedErrors.id;
        this._key = options.key || DEFAULT_KEY;
        this._limit = op