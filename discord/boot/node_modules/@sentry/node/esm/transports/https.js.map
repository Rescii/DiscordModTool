n\n  // client ip:\n  //   node: req.connection.remoteAddress\n  //   express, koa: req.ip\n  if (options.ip) {\n    const ip = req.ip || (req.connection && req.connection.remoteAddress);\n    if (ip) {\n      event.user = {\n        ...event.user,\n        ip_address: ip,\n      };\n    }\n  }\n\n  if (options.transaction && !event.transaction) {\n    event.transaction = extractTransaction(req, options.transaction);\n  }\n\n  return event;\n}\n\nexport type RequestHandlerOptions = ParseRequestOptions & {\n  flushTimeout?: number;\n};\n\n/**\n * Express compatible request handler.\n * @see Exposed as `Handlers.requestHandler`\n */\nexport function requestHandler(\n  options?: RequestHandlerOptions,\n): (req: http.IncomingMessage, res: http.ServerResponse, next: (error?: any) => void) => void {\n  return function sentryRequestMiddleware(\n    req: http.IncomingMessage,\n    res: http.ServerResponse,\n    next: (error?: any) => void,\n  ): void {\n    if (options && options.flushTimeout && options.flushTimeout > 0) {\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      const _end = res.end;\n      res.end = function(chunk?: any | (() => void), encoding?: string | (() => void), cb?: () => void): void {\n        flush(options.flushTimeout)\n          .then(() => {\n            _end.call(this, chunk, encoding, cb);\n          })\n          .then(null, e => {\n            logger.error(e);\n          });\n      };\n    }\n    const local = domain.create();\n    local.add(req);\n    local.add(res);\n    local.on('error', next);\n    local.run(() => {\n      getCurrentHub().configureScope(scope =>\n        scope.addEventProcessor((event: Event) => parseRequest(event, req, options)),\n      );\n      next();\n    });\n  };\n}\n\n/** JSDoc */\ninterface MiddlewareError extends Error {\n  status?: number | string;\n  statusCode?: number | string;\n  status_code?: number | string;\n  output?: {\n    statusCode?: number | string;\n  };\n}\n\n/**