D;QACD,IAAI,GAAG,CAAC,QAAQ,KAAK,MAAM,EAAE;YAC3B,OAAO,IAAI,aAAa,CAAC,gBAAgB,CAAC,CAAC;SAC5C;QACD,OAAO,IAAI,cAAc,CAAC,gBAAgB,CAAC,CAAC;IAC9C,CAAC;IACH,kBAAC;AAAD,CAAC,AA1GD,CAAiC,WAAW,GA0G3C","sourcesContent":["import { BaseBackend, getCurrentHub } from '@sentry/core';\nimport { Event, EventHint, Mechanism, Options, Severity, Transport, TransportOptions } from '@sentry/types';\nimport {\n  addExceptionMechanism,\n  addExceptionTypeValue,\n  Dsn,\n  extractExceptionKeysForMessage,\n  isError,\n  isPlainObject,\n  normalizeToSize,\n  SyncPromise,\n} from '@sentry/utils';\n\nimport { extractStackFromError, parseError, parseStack, prepareFramesForEvent } from './parsers';\nimport { HTTPSTransport, HTTPTransport } from './transports';\n\n/**\n * Configuration options for the Sentry Node SDK.\n * @see NodeClient for more information.\n */\nexport interface NodeOptions extends Options {\n  /** Sets an optional server name (device name) */\n  serverName?: string;\n\n  /** Maximum time in milliseconds to wait to drain the request queue, before the process is allowed to exit. */\n  shutdownTimeout?: number;\n\n  /** Set a HTTP proxy that should be used for outbound requests. */\n  httpProxy?: string;\n\n  /** Set a HTTPS proxy that should be used for outbound requests. */\n  httpsProxy?: string;\n\n  /** HTTPS proxy certificates path */\n  caCerts?: string;\n\n  /** Sets the number of context lines for each frame when loading a file. */\n  frameContextLines?: number;\n\n  /** Callback that is executed when a fatal global error occurs. */\n  onFatalError?(error: Error): void;\n}\n\n/**\n * The Sentry Node SDK Backend.\n * @hidden\n */\nexport class NodeBackend extends BaseBackend<NodeOptions> {\n  /**\n   * @inheritDoc\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\n  public eventFromException(exception: any, hint?: EventHint): PromiseLike<Event> {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let ex: any = exception;\n    const mechanism: Mechanism = {\n      handled: true,\n      type: 'generic',\n    };\n\n    if (!isError(exception)) {\n      if (isPlainObject(exception)) {\n        // This will allow us to group events based on top-level keys\n        // which is much better than creating new group when any key/value change\n        const message = `Non-Error exception captured with keys: ${extractExceptionKeysForMessage(exception)}`;\n\n        getCurrentHub().configureScope(scope => {\n          scope.setExtra('__serialized__', normalizeToSize(exception as Record<string, unknown>));\n        });\n\n        ex = (hint && hint.syntheticException) || new Error(message);\n        (ex as Error).message = message;\n      } else {\n        // This handles when someone does: `throw \"something awesome\";`\n        // We use synthesized Error here so we can extract a (rough) stack trace.\n        ex = (hint && hint.syntheticException) || new Error(exception as string);\n        (ex as Error).message = exception;\n      }\n      mechanism.synthetic = true;\n    }\n\n    return new SyncPromise<Event>((resolve, reject) =>\n      parseError(ex as Error, this._options)\n        .then(event => {\n          addExceptionTypeValue(event, undefined, undefined);\n          addExceptionMechanism(event, mechanism);\n\n          resolve({\n            ...event,\n            event_id: hint && hint.event_id,\n          });\n        })\n        .then(null, reject),\n    );\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public eventFromMessage(message: string, level: Severity = Severity.Info, hint?: EventHint): PromiseLike<Event> {\n    const event: Event = {\n      event_id: hint && hint.event_id,\n      level,\n      message,\n    };\n\n    return new SyncPromise<Event>(resolve => {\n      if (this._options.attachStacktrace && hint && hint.syntheticException) {\n        const stack = hint.syntheticException ? extractStackFromError(hint.syntheticException) : [];\n        parseStack(stack, this._options)\n          .then(frames => {\n            event.stacktrace = {\n              frames: prepareFramesForEvent(frames),\n            };\n            resolve(event);\n          })\n          .then(null, () => {\n            resolve(event);\n          });\n      } else {\n        resolve(event);\n      }\n    });\n  }\n\n  /**\n   * @inheritDoc\n   */\n  protected _setupTransport(): Transport {\n    if (!this._options.dsn) {\n      // We return the noop transport here in case there is no Dsn.\n      return super._setupTransport();\n    }\n\n    const dsn = new Dsn(this._options.dsn);\n\n    const transportOptions: TransportOptions = {\n      ...this._options.transportOptions,\n      ...(this._options.httpProxy && { httpProxy: this._options.httpProxy }),\n      ...(this._options.httpsProxy && { httpsProxy: this._options.httpsProxy }),\n      ...(this._options.caCerts && { caCerts: this._options.caCerts }),\n      dsn: this._options.dsn,\n      _metadata: this._options._metadata,\n    };\n\n    if (this._options.transport) {\n      return new this._options.transport(transportOptions);\n    }\n    if (dsn.protocol === 'http') {\n      return new HTTPTransport(transportOptions);\n    }\n    return new HTTPSTransport(transportOptions);\n  }\n}\n"]}import { BaseClient, Scope } from '@sentry/core';
import { Event, EventHint } from '@sentry/types';
import { NodeBackend, NodeOptions } from './backend';
/**
 * The Sentry Node SDK Client.
 *
 * @see NodeOptions for documentation on configuration options.
 * @see SentryClient for usage documentation.
 */
export declare class NodeClient extends BaseClient<NodeBackend, NodeOptions> {
    /**
     * Creates a new Node SDK instance.
     * @param options Configuration options for this SDK.
     */
    constructor(options: NodeOptions);
    /**
     * @inheritDoc
     */
    protected _prepareEvent(event: Event, scope?: Scope, hint?: EventHint): PromiseLike<Event | null>;
}
//# sourceMappingURL=client.d.ts.map{"version":3,"file":"client.d.ts","sourceRoot":"","sources":["../src/client.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,UAAU,EAAE,KAAK,EAAE,MAAM,cAAc,CAAC;AACjD,OAAO,EAAE,KAAK,EAAE,SAAS,EAAE,MAAM,eAAe,CAAC;AAEjD,OAAO,EAAE,WAAW,EAAE,WAAW,EAAE,MAAM,WAAW,CAAC;AAErD;;;;;GAKG;AACH,qBAAa,UAAW,SAAQ,UAAU,CAAC,WAAW,EAAE,WAAW,CAAC;IAClE;;;OAGG;gBACgB,OAAO,EAAE,WAAW;IAIvC;;OAEG;IACH,SAAS,CAAC,aAAa,CAAC,KAAK,EAAE,KAAK,EAAE,KAAK,CAAC,EAAE,KAAK,EAAE,IAAI,CAAC,EAAE,SAAS,GAAG,WAAW,CAAC,KAAK,GAAG,IAAI,CAAC;CAOlG"}import { __extends } from "tslib";
import { BaseClient } from '@sentry/core';
import { NodeBackend } from './backend';
/**
 * The Sentry Node SDK Client.
 *
 * @see NodeOptions for documentation on configuration options.
 * @see SentryClient for usage documentation.
 */
var NodeClient = /** @class */ (function (_super) {
    __extends(NodeClient, _super);
    /**
     * Creates a new Node SDK instance.
     * @param options Configuration options for this SDK.
     */
    function NodeClient(options) {
        return _super.call(this, NodeBackend, options) || this;
    }
    /**
     * @inheritDoc
     */
    NodeClient.prototype._prepareEvent = function (event, scope, hint) {
        event.platform = event.platform || 'node';
        if (this.getOptions().serverName) {
            event.server_name = this.g