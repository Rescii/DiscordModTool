ore them - they don't matter to us, we're just waiting for the second error timeout to finish\n        caughtSecondError = true;\n        setTimeout(() => {\n          if (!calledFatalError) {\n            // it was probably case 1, let's treat err as the sendErr and call onFatalError\n            calledFatalError = true;\n            onFatalError(firstError, error);\n          } else {\n            // it was probably case 2, our first error finished capturing while we waited, cool, do nothing\n          }\n        }, timeout); // capturing could take at least sendTimeout to fail, plus an arbitrary second for how long it takes to collect surrounding source etc\n      }\n    };\n  }\n}\n"]}import { Integration } from '@sentry/types';
declare type UnhandledRejectionMode = 'none' | 'warn' | 'strict';
/** Global Promise Rejection handler */
export declare class OnUnhandledRejection implements Integration {
    private readonly _options;
    /**
     * @inheritDoc
     */
    static id: string;
    /**
     * @inheritDoc
     */
    name: string;
    /**
     * @inheritDoc
     */
    constructor(_options?: {
        /**
         * Option deciding what to do after capturing unhandledRejection,
         * that mimicks behavior of node's --unhandled-rejection flag.
         */
        mode: UnhandledRejectionMode;
    });
    /**
     * @inheritDoc
     */
    setupOnce(): void;
    /**
     * Send an exception with reason
     * @param reason string
     * @param promise promise
     */
    sendUnhandledPromise(reason: any, promise: any): void;
    /**
     * Handler for `mode` option
     */
    private _handleRejection;
}
export {};
//# sourceMappingURL=onunhandledrejection.d.ts.map{"version":3,"file":"onunhandledrejection.d.ts","sourceRoot":"","sources":["../../src/integrations/onunhandledrejection.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,WAAW,EAAE,MAAM,eAAe,CAAC;AAK5C,aAAK,sBAAsB,GAAG,MAAM,GAAG,MAAM,GAAG,QAAQ,CAAC;AAEzD,uCAAuC;AACvC,qBAAa,oBAAqB,YAAW,WAAW;IAepD,OAAO,CAAC,QAAQ,CAAC,QAAQ;IAd3B;;OAEG;IACH,OAAc,EAAE,EAAE,MAAM,CAA0B;IAElD;;OAEG;IACI,IAAI,EAAE,MAAM,CAA2B;IAE9C;;OAEG;gBAEgB,QAAQ,GAAE;QACzB;;;WAGG;QACH,IAAI,EAAE,sBAAsB,CAAC;KACX;IAGtB;;OAEG;IACI,SAAS,IAAI,IAAI;IAIxB;;;;OAIG;IAEI,oBAAoB,CAAC,MAAM,EAAE,GAAG,EAAE,OAAO,EAAE,GAAG,GAAG,IAAI;IAgC5D;;OAEG;IAEH,OAAO,CAAC,gBAAgB;CAuBzB"}Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = require("@sentry/core");
var utils_1 = require("@sentry/utils");
var handlers_1 = require("../handlers");
/** Global Promise Rejection handler */
var OnUnhandledRejection = /** @class */ (function () {
    /**
     * @inheritDoc
     */
    function OnUnhandledRejection(_options) {
        if (_options === void 0) { _options = { mode: 'warn' }; }
        this._options = _options;
        /**
         * @inheritDoc
         */
        this.name = OnUnhandledRejection.id;
    }
    /**
     * @inheritDoc
     */
    OnUnhandledRejection.prototype.setupOnce = function () {
        global.process.on('unhandledRejection', this.sendUnhandledPromise.bind(this));
    };
    /**
     * Send an exception with reason
     * @param reason string
     * @param promise promise
     */
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/no-explicit-any
    OnUnhandledRejection.prototype.sendUn