\n  }\n\n  if (options.environment === undefined && process.env.SENTRY_ENVIRONMENT) {\n    options.environment = process.env.SENTRY_ENVIRONMENT;\n  }\n\n  options._metadata = options._metadata || {};\n  options._metadata.sdk = {\n    name: 'sentry.javascript.node',\n    packages: [\n      {\n        name: 'npm:@sentry/node',\n        version: SDK_VERSION,\n      },\n    ],\n    version: SDK_VERSION,\n  };\n\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any\n  if ((domain as any).active) {\n    setHubOnCarrier(getMainCarrier(), getCurrentHub());\n  }\n\n  initAndBind(NodeClient, options);\n}\n\n/**\n * This is the getter for lastEventId.\n *\n * @returns The last event id of a captured event.\n */\nexport function lastEventId(): string | undefined {\n  return getCurrentHub().lastEventId();\n}\n\n/**\n * A promise that resolves when all current events have been sent.\n * If you provide a timeout and the queue takes longer to drain the promise returns false.\n *\n * @param timeout Maximum time in ms the client should wait.\n */\nexport async function flush(timeout?: number): Promise<boolean> {\n  const client = getCurrentHub().getClient<NodeClient>();\n  if (client) {\n    return client.flush(timeout);\n  }\n  return Promise.reject(false);\n}\n\n/**\n * A promise that resolves when all current events have been sent.\n * If you provide a timeout and the queue takes longer to drain the promise returns false.\n *\n * @param timeout Maximum time in ms the client should wait.\n */\nexport async function close(timeout?: number): Promise<boolean> {\n  const client = getCurrentHub().getClient<NodeClient>();\n  if (client) {\n    return client.close(timeout);\n  }\n  return Promise.reject(false);\n}\n"]}/**
 * stack-trace - Parses node.js stack traces
 *
 * This was originally forked to fix this issue:
 * https://github.com/felixge/node-stack-trace/issues/31
 *
 * Mar 19,2019 - #4fd379e
 *
 * https://github.com/felixge/node-stack-trace/
 * @license MIT
 */
/** Decoded StackFrame */
export interface StackFrame {
    fileName: string;
    lineNumber: number;
    functionName: string;
    typeName: string;
    methodName: string;
    native: boolean;
    columnNumber: number;
}
/** Extracts StackFrames from the Error */
export declare function parse(err: Error): StackFrame[];
//# sourceMappingURL=stacktrace.d.ts.map{"version":3,"file":"stacktrace.d.ts","sourceRoot":"","sources":["../src/stacktrace.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;GAUG;AAEH,yBAAyB;AACzB,MAAM,WAAW,UAAU;IACzB,QAAQ,EAAE,MAAM,CAAC;IACjB,UAAU,EAAE,MAAM,CAAC;IACnB,YAAY,EAAE,MAAM,CAAC;IACrB,QAAQ,EAAE,MAAM,CAAC;IACjB,UAAU,EAAE,MAAM,CAAC;IACnB,MAAM,EAAE,OAAO,CAAC;IAChB,YAAY,EAAE,MAAM,CAAC;CACtB;AAED,0CAA0C;AAC1C,wBAAgB,KAAK,CAAC,GAAG,EAAE,KAAK,GAAG,UAAU,EAAE,CA2E9C"}/**
 * stack-trace - Parses node.js stack traces
 *
 * This was originally forked to fix this issue:
 * https://github.com/felixge/node-stack-trace/issues/31
 *
 * Mar 19,2019 - #4fd379e
 *
 * https://github.com/felixge/node-stack-trace/
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
/** Extracts StackFrames from the Error */
function parse(err) {
    if (!err.stack) {
        return [];
    }
    var lines = err.stack.split('\n').slice(1);
    return lines
        .map(function (line) {
        if (line.match(/^\s*[-]{4,}$/)) {
            return {
                columnNumber: null,
                fileName: line,
                functionName: null,
                lineNumber: null,
                methodName: null,
                native: null,
                typeName: null,
            };
        }
        var lineMatch = line.match(/at (?:(.+?)\s+\()?(?:(.+?):(\d+)(?::(\d+))?|([^)]+))\)?/);
        if (!lineMatch) {
            return undefined;
        }
        var object = null;
        var method = null;
        var functionName = null;
        var typeName = null;
        var methodName = null;
        var isNative = lineMatch[5] === 'native';
        if (lineMatch[1]) {
            functionName = lineMatch[1];
            var methodStart = functionName.lastIndexOf('.');
            if (functionName[methodStart - 1] === '.') {
                // eslint-disable-next-line no-plusplus
                methodStart--;
            }
            if (methodStart > 0) {
                object = functionName.substr(0, methodStart);
                method = functionName.substr(methodStart + 1);
                var objectEnd = object.indexOf('.Module');
                if (objectEnd > 0) {
                    functionName = functionName.substr(objectEnd + 1);
                    object = object.substr(0, objectEnd);
                }
            }
            typeName = null;
        }
        if (method) {
            typeName = object;
            methodName = method;
        }
        if (method === '<anonymous>') {
            methodName = null;
            functionName = null;
        }
        var properties = {
            columnNumber: parseInt(lineMatch[4], 10) || null,
            fileName: lineMatch[2] || null,
            functionName: functionName,
            lineNumber: parseInt(lineMatch[3], 10) || null,
            methodName: methodName,
            native: isNative,
            typeName: typeName,
    