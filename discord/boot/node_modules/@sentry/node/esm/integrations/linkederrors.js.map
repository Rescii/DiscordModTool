 rather than a single one\n  if (requestUrl?.startsWith('///')) {\n    requestUrl = requestUrl.slice(2);\n  }\n\n  return `${method} ${requestUrl}`;\n}\n\n// the node types are missing a few properties which node's `urlToOptions` function spits out\nexport type RequestOptions = http.RequestOptions & { hash?: string; search?: string; pathname?: string; href?: string };\ntype RequestCallback = (response: http.IncomingMessage) => void;\nexport type RequestMethodArgs =\n  | [RequestOptions | string | URL, RequestCallback?]\n  | [string | URL, RequestOptions, RequestCallback?];\nexport type RequestMethod = (...args: RequestMethodArgs) => http.ClientRequest;\n\n/**\n * Convert a URL object into a RequestOptions object.\n *\n * Copied from Node's internals (where it's used in http(s).request() and http(s).get()), modified only to use the\n * RequestOptions type above.\n *\n * See https://github.com/nodejs/node/blob/master/lib/internal/url.js.\n */\nexport function urlToOptions(url: URL): RequestOptions {\n  const options: RequestOptions = {\n    protocol: url.protocol,\n    hostname:\n      typeof url.hostname === 'string' && url.hostname.startsWith('[') ? url.hostname.slice(1, -1) : url.hostname,\n    hash: url.hash,\n    search: url.search,\n    pathname: url.pathname,\n    path: `${url.pathname || ''}${url.search || ''}`,\n    href: url.href,\n  };\n  if (url.port !== '') {\n    options.port = Number(url.port);\n  }\n  if (url.username || url.password) {\n    options.auth = `${url.username}:${url.password}`;\n  }\n  return options;\n}\n\n/**\n * Normalize inputs to `http(s).request()` and `http(s).get()`.\n *\n * Legal inputs to `http(s).request()` and `http(s).get()` can take one of ten forms:\n *     [ RequestOptions | string | URL ],\n *     [ RequestOptions | string | URL, RequestCallback ],\n *     [ string | URL, RequestOptions ], and\n *     [ string | URL, RequestOptions, RequestCallback ].\n *\n * This standardizes to one of two forms: [ RequestOptions ] and [ RequestOptions, RequestCallback ]. A similar thing is\n * done as the first step of `http(s).request()` and `http(s).get()`; this just does it early so that we can interact\n * with the args in a standard way.\n *\n * @param requestArgs The inputs to `http(s).request()` or `http(s).get()`, as an array.\n *\n * @returns Equivalent args of the form [ RequestOptions ] or [ RequestOptions, RequestCallback ].\n */\nexport function normalizeRequestArgs(\n  requestArgs: RequestMethodArgs,\n): [RequestOptions] | [RequestOptions, RequestCallback] {\n  let callback, requestOptions;\n\n  // pop off the callback, if there is one\n  if (typeof requestArgs[requestArgs.length - 1] === 'function') {\n    callback = requestArgs.pop() as RequestCallback;\n  }\n\n  // create a RequestOptions object of whatever's at index 0\n  if (typeof requestArgs[0] === 'string') {\n    requestOptions = urlToOptions(new URL(requestArgs[0]));\n  } else if (requestArgs[0] instanceof URL) {\n    requestOptions = urlToOptions(requestArgs[0]);\n  } else {\n    requestOptions = requestArgs[0];\n  }\n\n  // if the options were given separately from the URL, fold them in\n  if (requestArgs.length === 2) {\n    requestOptions = { ...requestOptions, ...requestArgs[1] };\n  }\n\n  // return args in standardized form\n  if (callback) {\n    return [requestOptions, callback];\n  } else {\n    return [requestOptions];\n  }\n}\n"]}import { Event, Exception, ExtendedError, StackFrame } from '@sentry/types';
import { NodeOptions } from './backend';
import * as stacktrace from './stacktrace';
/**
 * Resets the file cache. Exists for testing purposes.
 * @hidden
 */
export declare function resetFileContentCache(): void;
/**
 * @hidden
 */
export declare function extractStackFromError(error: Error): stacktrace.StackFrame[];
/**
 * @hidden
 */
export declare function parseStack(stack: stacktrace.StackFrame[], options?: NodeOptions): PromiseLike<StackFrame[]>;
/**
 * @hidden
 */
export declare function getExceptionFromError(error: Error, options?: NodeOptions): PromiseLike<Exception>;
/**
 * @hidden
 */
export declare function parseError(error: ExtendedError, options?: NodeOptions): PromiseLike<Event>;
/**
 * @hidden
 */
export declare function prepareFramesForEvent(stack: StackFrame[]): StackFrame[];
//# sourceMappingURL=parsers.d.ts.map{"version":3,"file":"parsers.d.ts","sourceRoot":"","sources":["../src/parsers.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,KAAK,EAAE,SAAS,EAAE,aAAa,EAAE,UAAU,EAAE,MAAM,eAAe,CAAC;AAK5E,OAAO,EAAE,WAAW,EAAE,MAAM,WAAW,CAAC;AACxC,OAAO,KAAK,UAAU,MAAM,cAAc,CAAC;AAK3C;;;GAGG;AACH,wBAAgB,qBAAqB,IAAI,IAAI,CAE5C;AA0GD;;GAEG;AACH,wBAAgB,qBAAqB,CAAC,KAAK,EAAE,KAAK,GAAG,UAAU,CAAC,UAAU,EAAE,CAM3E;AAED;;GAEG;AACH,wBAAgB,UAAU,CAAC,KAAK,EAAE,UAAU,CAAC,UAAU,EAAE,EAAE,OAAO,CAAC,EAAE,WAAW,GAAG,WAAW,CAAC,UAAU,EAAE,CAAC,CAmD3G;AAkCD;;GAEG;AACH,wBAAgB,qBAAqB,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,EAAE,WAAW,GAAG,WAAW,CAAC,SAAS,CAAC,CAejG;AAED;;GAEG;AACH,wBAAgB,UAAU,CAAC,KAAK,EAAE,aAAa,EAAE,OAAO,CAAC,EAAE,WAAW,GAAG,WAAW,CAAC,KAAK,CAAC,CAU1F;AAED;;GAEG;AACH,wBAAgB,qBAAqB,CAAC,KAAK,EAAE,UAAU,EAAE,GAAG,UAAU,EAAE,CAcvE"}Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = requir