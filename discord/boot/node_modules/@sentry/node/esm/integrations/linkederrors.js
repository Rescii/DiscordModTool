C,cAAc,GAAG,YAAY,CAAC,IAAI,SAAG,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;KACxD;SAAM,IAAI,WAAW,CAAC,CAAC,CAAC,YAAY,SAAG,EAAE;QACxC,cAAc,GAAG,YAAY,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC;KAC/C;SAAM;QACL,cAAc,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC;KACjC;IAED,kEAAkE;IAClE,IAAI,WAAW,CAAC,MAAM,KAAK,CAAC,EAAE;QAC5B,cAAc,yCAAQ,cAAc,GAAK,WAAW,CAAC,CAAC,CAAC,CAAE,CAAC;KAC3D;IAED,mCAAmC;IACnC,IAAI,QAAQ,EAAE;QACZ,OAAO,CAAC,cAAc,EAAE,QAAQ,CAAC,CAAC;KACnC;SAAM;QACL,OAAO,CAAC,cAAc,CAAC,CAAC;KACzB;AACH,CAAC;AA9BD,oDA8BC","sourcesContent":["import { getCurrentHub } from '@sentry/core';\nimport * as http from 'http';\nimport { URL } from 'url';\n\n/**\n * Checks whether given url points to Sentry server\n * @param url url to verify\n */\nexport function isSentryRequest(url: string): boolean {\n  const dsn = getCurrentHub()\n    .getClient()\n    ?.getDsn();\n  return dsn ? url.includes(dsn.host) : false;\n}\n\n/**\n * Assemble a URL to be used for breadcrumbs and spans.\n *\n * @param requestOptions RequestOptions object containing the component parts for a URL\n * @returns Fully-formed URL\n */\nexport function extractUrl(requestOptions: RequestOptions): string {\n  const protocol = requestOptions.protocol || '';\n  const hostname = requestOptions.hostname || requestOptions.host || '';\n  // Don't log standard :80 (http) and :443 (https) ports to reduce the noise\n  const port =\n    !requestOptions.port || requestOptions.port === 80 || requestOptions.port === 443 ? '' : `:${requestOptions.port}`;\n  const path = requestOptions.path ? requestOptions.path : '/';\n\n  return `${protocol}//${hostname}${port}${path}`;\n}\n\n/**\n * Handle various edge cases in the span description (for spans representing http(s) requests).\n *\n * @param description current `description` property of the span representing the request\n * @param requestOptions Configuration data for the request\n * @param Request Request object\n *\n * @returns The cleaned description\n */\nexport function cleanSpanDescription(\n  description: string | undefined,\n  requestOptions: RequestOptions,\n  request: http.ClientRequest,\n): string | undefined {\n  // nothing to clean\n  if (!description) {\n    return description;\n  }\n\n  // eslint-disable-next-line prefer-const\n  let [method, requestUrl] = description.split(' ');\n\n  // superagent sticks the protocol in a weird place (we check for host because if both host *and* protocol are missing,\n  // we're likely dealing with an internal route and this doesn't apply)\n  if (requestOptions.host && !requestOptions.protocol) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any\n    requestOptions.protocol = (request as any)?.agent?.protocol; // worst comes to worst, this is undefined and nothing changes\n    requestUrl = extractUrl(requestOptions);\n  }\n\n  // internal routes can end up starting with a triple slash