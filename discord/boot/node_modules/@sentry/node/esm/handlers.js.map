tions.limit || DEFAULT_LIMIT;
    }
    /**
     * @inheritDoc
     */
    LinkedErrors.prototype.setupOnce = function () {
        core_1.addGlobalEventProcessor(function (event, hint) {
            var self = core_1.getCurrentHub().getIntegration(LinkedErrors);
            if (self) {
                var handler = self._handler && self._handler.bind(self);
                return typeof handler === 'function' ? handler(event, hint) : event;
            }
            return event;
        });
    };
    /**
     * @inheritDoc
     */
    LinkedErrors.prototype._handler = function (event, hint) {
        var _this = this;
        if (!event.exception || !event.exception.values || !hint || !utils_1.isInstanceOf(hint.originalException, Error)) {
            return utils_1.SyncPromise.resolve(event);
        }
        return new utils_1.SyncPromise(function (resolve) {
            _this._walkErrorTree(hint.originalException, _this._key)
                .then(function (linkedErrors) {
                if (event && event.exception && event.exception.values) {
                    event.exception.values = tslib_1.__spread(linkedErrors, event.exception.values);
                }
                resolve(event);
            })
                .then(null, function () {
                resolve(event);
            });
        });
    };
    /**
     * @inheritDoc
     */
    LinkedErrors.prototype._walkErrorTree = function (error, key, stack) {
        var _this = this;
        if (stack === void 0) { stack = []; }
        if (!utils_1.isInstanceOf(error[key], Error) || stack.length + 1 >= this._limit) {
            return utils_1.SyncPromise.resolve(stack);
        }
        return new utils_1.SyncPromise(function (resolve, reject) {
            parsers_1.getExceptionFromError(error[key])
                .then(function (exception) {
                _this._walkErrorTree(error[key], key, tslib_1.__spread([exception], stack))
                    .then(resolve)
                    .then(null, function () {
                    reject();
                });
            })
                .then(null, function () {
                reject();
            });
        });
    };
    /**
     * @inheritDoc
     */
    LinkedErrors.id = 'LinkedErrors';
    return LinkedErrors;
}());
exports.LinkedErrors = LinkedErrors;
//# sourceMappingURL=linkederrors.js.map{"version":3,"file":"linkederrors.js","sourceRoot":"","sources":["../../src/integrations/linkederrors.ts"],"names":[],"mappings":"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","sourcesContent":["import { addGlobalEventProcessor, getCurrentHub } from '@sentry/core';\nimport { Event, EventHint, Exception, ExtendedError, Integration } from '@sentry/types';\nimport { isInstanceOf, SyncPromise } from '@sentry/utils';\n\nimport { getExceptionFromError } from '../parsers';\n\nconst DEFAULT_KEY = 'cause';\nconst DEFAULT_LIMIT = 5;\n\n/** Adds SDK info to an event. */\nexport class LinkedErrors implements Integration {\n  /**\n   * @inheritDoc\n   */\n  public static id: string = 'LinkedErrors';\n\n  /**\n   * @inheritDoc\n   */\n  public readonly name: string = LinkedErrors.id;\n\n  /**\n   * @inheritDoc\n   */\n  private readonly _key: string;\n\n  /**\n   * @inheritDoc\n   */\n  private readonly _limit: number;\n\n  /**\n   * @inheritDoc\n   */\n  public constructor(options: { key?: string; limit?: number } = {}) {\n    this._key = options.key || DEFAULT_KEY;\n    this._limit = options.limit || DEFAULT_LIMIT;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setupOnce(): void {\n    addGlobalEventProcessor((event: Event, hint?: EventHint) => {\n      const self = getCurrentHub().getIntegration(LinkedErrors);\n      if (self) {\n        const handler = self._handler && self._handler.bind(self);\n        return typeof handler === 'function' ? handler(event, hint) : event;\n      }\n      return event;\n    });\n  }\n\n  /**\n   * @inheritDoc\n   */\n  private _handler(event: Event, hint?: EventHint): PromiseLike<Event> {\n    if (!event.exception || !event.exception.values || !hint || !isInstanceOf(hint.originalException, Error)) {\n      return SyncPromise.resolve(event);\n    }\n\n    return new SyncPromise<Event>(resolve => {\n      this._walkErrorTree(hint.originalException as Error, this._key)\n        .then((linkedErrors: Exception[]) => {\n          if (event && event.exception && event.exception.values) {\n            event.exception.values = [...linkedErrors, ...event.exception.values];\n          }\n          resolve(event);\n        })\n        .then(null, () => {\n          resolve(event);\n        });\n    });\n  }\n\n  /**\n   * @inheritDoc\n   */\n  private _walkErrorTree(error: ExtendedError, key: string, stack: Exception[] = []): PromiseLike<Exception[]> {\n    if (!isInstanceOf(error[key], Error) || stack.length + 1 >= this._limit) {\n      return SyncPromise.resolve(stack);\n    }\n    return new SyncPromise<Exception[]>((resolve, reject) => {\n      getExceptionFromError(error[key])\n        .then((exception: Exception) => {\n          this._walkErrorTree(error[key], key, [exception, ...stack])\n            .then(resolve)\n            .then(null, () => {\n              reject();\n            });\n        })\n        .then(null, () => {\n          reject();\n        });\n    });\n  }\n}\n"]}import { EventProcessor, Hub, Integration } from '@sentry/types';
/** Add node modules / packages to the event */
export declare class Modules implements Integration {
    /**
     * @inheritDoc
     */
    static id: string;
    /**
     * @inheritDoc
     */
    name: string;
    /**
     * @inheritDoc
     */
    setupOnce(addGlobalEventProcessor: (callback: EventProcessor) => void, getCurrentHub: () => Hub): void;
    /** Fetches the list of modules and the versions loaded by the entry file for your node.js app. */
    private _getModules;
}
//# sourceMappingURL=modules.d.ts.map{"version":3,"file":"modules.d.ts","sourceRoot":"","sources":["../../src/integrations/modules.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,cAAc,EAAE,GAAG,EAAE,WAAW,EAAE,MAAM,eAAe,CAAC;AAmEjE,+CAA+C;AAC/C,qBAAa,OAAQ,YAAW,WAAW;IACzC;;OAEG;IACH,OAAc,EAAE,EAAE,MAAM,CAAa;IAErC;;OAEG;IACI,IAAI,EAAE,MAAM,CAAc;IAEjC;;OAEG;IACI,SAAS,CAAC,uBAAuB,EAAE,CAAC,QAAQ,EAAE,cAAc,KAAK,IAAI,EAAE,aAAa,EAAE,MAAM,GAAG,GAAG,IAAI;IAY7G,kGAAkG;IAClG,OAAO,CAAC,WAAW;CAMpB"}Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var fs_1 = require("fs");
var path_1 = require("path");
var moduleCache;
/** Extract information about paths */
function getPaths() {
    try {
        return require.cache ? Object.keys(require.cache) : [];
    }
    catch (e) {
        return [];
    }
}
/** Extract information about package.json modules */
function collectModules() {
    var mainPaths = (require.main && require.main.paths) || [];
    var paths = getPaths();
    var infos = {};
    var seen = {};
    paths.forEach(function (path) {
        var dir = path;
        /** Traverse directories upward in the search of package.json file */
        var updir = function () {
            var orig = dir;
            dir = path_1.dirname(orig);
            if (!dir || orig === dir || seen[orig]) {
                return undefined;
            }
            if (mainPaths.indexOf(dir) < 0) {
                return updir();
            }
            var pkgfile = path_1.join(orig, 'package.json');
            seen[orig] = true;
            if (!fs_1.existsSync(pkgfile)) {
                return updir();
            }
            try {
                var info = JSON.parse(fs_1.readFileSync(pkgfile, 'utf8'));
                infos[info.name] = info.version;
            }
            catch (_oO) {
                // no-empty
            }
        };
        updir();
    });
    return infos;
}
/** Add node modules / packages to the event */
var Modules = /** @class */ (function () {
    function Modules() {
        /**
         * @inheritDoc
         */
        this.name = Modules.id;
    }
    /**
     * @inheritDoc
     */
    Modules.prototype.setupOnce = function (addGlobalEventProcessor, getCurrentHub) {
        var _this = this;
        addGlobalEventProcessor(function (event) {
            if (!getCurrentHub().getIntegration(Modules)) {
                return event;
            }
            return tslib_1.__assign(tslib_1.__assign({}, event), { modules: _this._getModules() });
        });
    };
    /** Fetches the list of modules and the versions loaded by the entry file for your node.js app. */
    Modules.prototype._getModules = function () {
        if (!moduleCache) {
            moduleCache = collectModules();
        }
        return moduleCache;
    };
    /**
     * @inheritDoc
     */
    Modules.id = 'Modules';
    return Modules;
}());
exports.Modules = Modules;
//# sourceMappingURL=modules.js.map{"version":3,"file":"modules.js","sourceRoot":"","sources":["../../src/integrations/modules.ts"],"names":[],"mappings":";;AACA,yBAA8C;AAC9C,6BAAqC;AAErC,IAAI,WAAsC,CAAC;AAE3C,sCAAsC;AACtC,SAAS,QAAQ;IACf,IAAI;QACF,OAAO,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,KAAgC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;KACnF;IAAC,OAAO,CAAC,EAAE;QACV,OAAO,EAAE,CAAC;KACX;AACH,CAAC;AAED,qDAAqD;AACrD,SAAS,cAAc;IAGrB,IAAM,SAAS,GAAG,CAAC,OAAO,CAAC,IAAI,IAAI,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC;IAC7D,IAAM,KAAK,GAAG,QAAQ,EAAE,CAAC;IACzB,IAAM,KAAK,GAEP,EAAE,CAAC;IACP,IAAM,IAAI,GAEN,EAAE,CAAC;IAEP,KAAK,CAAC,OAAO,CAAC,UAAA,IAAI;QAChB,IAAI,GAAG,GAAG,IAAI,CAAC;QAEf,qEAAqE;QACrE,IAAM,KAAK,GAAG;YACZ,IAAM,IAAI,GAAG,GAAG,CAAC;YACjB,GAAG,GAAG,cAAO,CAAC,IAAI,CAAC,CAAC;YAEpB,IAAI,CAAC,GAAG,IAAI,IAAI,KAAK,GAAG,IAAI,IAAI,CAAC,IAAI,CAAC,EAAE;gBACtC,OAAO,SAAS,CAAC;aAClB;YACD,IAAI,SAAS,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;gBAC9B,OAAO,KAAK,EAAE,CAAC;aAChB;YAED,IAAM,OAAO,GAAG,WAAI,CAAC,IAAI,EAAE,cAAc,CAAC,CAAC;YAC3C,IAAI,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC;YAElB,IAAI,CAAC,eAAU,CAAC,OAAO,CAAC,EAAE;gBACxB,OAAO,KAAK,EAAE,CAAC;aAChB;YAED,IAAI;gBACF,IAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,iBAAY,CAAC,OAAO,EAAE,MAAM,CAAC,CAGpD,CAAC;gBACF,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,OAAO,CAAC;aACjC;YAAC,OAAO,GAAG,EAAE;gBACZ,WAAW;aACZ;QACH,CAAC,CAAC;QAEF,KAAK,EAAE,CAAC;IACV,CAAC,CAAC,CAAC;IAEH,OAAO,KAAK,CAAC;AACf,CAAC;AAED,+CAA+C;AAC/C;IAAA;QAME;;WAEG;QACI,SAAI,GAAW,OAAO,CAAC,EAAE,CAAC;IAwBnC,CAAC;IAtBC;;OAEG;IACI,2BAAS,GAAhB,UAAiB,uBAA2D,EAAE,aAAwB;QAAtG,iBAUC;QATC,uBAAuB,CAAC,UAAA,KAAK;YAC3B,IAAI,CAAC,aAAa,EAAE,CAAC,cAAc,CAAC,OAAO,CAAC,EAAE;gBAC5C,OAAO,KAAK,CAAC;aACd;YACD,6CACK,KAAK,KACR,OAAO,EAAE,KAAI,CAAC,WAAW,EAAE,IAC3B;QACJ,CAAC,CAAC,CAAC;IACL,CAAC;IAED,kGAAkG;IAC1F,6BAAW,GAAnB;QACE,IAAI,CAAC,WAAW,EAAE;YAChB,WAAW,GAAG,cAAc,EAAE,CAAC;SAChC;QACD,OAAO,WAAW,CAAC;IACrB,CAAC;IA/BD;;OAEG;IACW,UAAE,GAAW,SAAS,CAAC;IA6BvC,cAAC;CAAA,AAjCD,IAiCC;AAjCY,0BAAO","sourcesContent":["import { EventProcessor, Hub, Integration } from '@sentry/types';\nimport { existsSync, readFileSync } from 'fs';\nimport { dirname, join } from 'path';\n\nlet moduleCache: { [key: string]: string };\n\n/** Extract information about paths */\nfunction getPaths(): string[] {\n  try {\n    return require.cache ? Object.keys(require.cache as Record<string, unknown>) : [];\n  } catch (e) {\n    return [];\n  }\n}\n\n/** Extract information about package.json modules */\nfunction collectModules(): {\n  [name: string]: string;\n} {\n  const mainPaths = (require.main && require.main.paths) || [];\n  const paths = getPaths();\n  const infos: {\n    [name: string]: string;\n  } = {};\n  const seen: {\n    [path: string]: boolean;\n  } = {};\n\n  paths.forEach(path => {\n    let dir = path;\n\n    /** Traverse directories upward in the search of package.json file */\n    const updir = (): void | (() => void) => {\n      const orig = dir;\n      dir = dirname(orig);\n\n      if (!dir || orig === dir || seen[orig]) {\n        return undefined;\n      }\n      if (mainPaths.indexOf(dir) < 0) {\n        return updir();\n      }\n\n      const pkgfile = join(orig, 'package.json');\n      seen[orig] = true;\n\n      if (!existsSync(pkgfile)) {\n        return updir();\n      }\n\n      try {\n        const info = JSON.parse(readFileSync(pkgfile, 'utf8')) as {\n          name: string;\n          version: string;\n        };\n        infos[info.name] = info.version;\n      } catch (_oO) {\n        // no-empty\n      }\n    };\n\n    updir();\n  });\n\n  return infos;\n}\n\n/** Add node modules / packages to the event */\nexport class Modules implements Integration {\n  /**\n   * @inheritDoc\n   */\n  public static id: string = 'Modules';\n\n  /**\n   * @inheritDoc\n   */\n  public name: string = Modules.id;\n\n  /**\n   * @inheritDoc\n   */\n  public setupOnce(addGlobalEventProcessor: (callback: EventProcessor) => void, getCurrentHub: () => Hub): void {\n    addGlobalEventProcessor(event => {\n      if (!getCurrentHub().getIntegration(Modules)) {\n        return event;\n      }\n      return {\n        ...event,\n        modules: this._getModules(),\n      };\n    });\n  }\n\n  /** Fetches the list of modules and the versions loaded by the entry file for your node.js app. */\n  private _getModules(): { [key: string]: string } {\n    if (!moduleCache) {\n      moduleCache = collectModules();\n    }\n    return moduleCache;\n  }\n}\n"]}import { Integration } from '@sentry/types';
/** Global Promise Rejection handler */
export declare class OnUncaughtException implements Integration {
    private readonly _options;
    /**
     * @inheritDoc
     */
    static id: string;
    /**
     * @inheritDoc
     */
    name: string;
    /**
     * @inheritDoc
     */
    readonly handler: (error: Error) => void;
    /**
     * @inheritDoc
     */
    constructor(_options?: {
        /**
         * Default onFatalError handler
         * @param firstError Error that has been thrown
         * @param secondError If this was called multiple times this will be set
         */
        onFatalError?(firstError: Error, secondError?: Error): void;
    });
    /**
     * @inheritDoc
     */
    setupOnce(): void;
    /**
     * @hidden
     */
    private _makeErrorHandler;
}
//# sourceMappingURL=onuncaughtexception.d.ts.map{"version":3,"file":"onuncaughtexception.d.ts","sourceRoot":"","sources":["../../src/integrations/onuncaughtexception.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,WAAW,EAAY,MAAM,eAAe,CAAC;AAMtD,uCAAuC;AACvC,qBAAa,mBAAoB,YAAW,WAAW;IAoBnD,OAAO,CAAC,QAAQ,CAAC,QAAQ;IAnB3B;;OAEG;IACH,OAAc,EAAE,EAAE,MAAM,CAAyB;IAEjD;;OAEG;IACI,IAAI,EAAE,MAAM,CAA0B;IAE7C;;OAEG;IACH,SAAgB,OAAO,EAAE,CAAC,KAAK,EAAE,KAAK,KAAK,IAAI,CAA4B;IAE3E;;OAEG;gBAEgB,QAAQ,GAAE;QACzB;;;;WAIG;QACH,YAAY,CAAC,CAAC,UAAU,EAAE,KAAK,EAAE,WAAW,CAAC,EAAE,KAAK,GAAG,IAAI,CAAC;KACxD;IAER;;OAEG;IACI,SAAS,IAAI,IAAI;IAIxB;;OAEG;IACH,OAAO,CAAC,iBAAiB;CA6E1B"}Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = require("@sentry/core");
var types_1 = require("@sentry/types");
var utils_1 = require("@sentry/utils");
var handlers_1 = require("../handlers");
/** Global Promise Rejection handler */
var OnUncaughtException = /** @class */ (function () {
    /**
     * @inheritDoc
     */
    function OnUncaughtException(_options) {
        if (_options === void 0) { _options = {}; }
        this._options = _options;
        /**
         * @inheritDoc
         */
        this.name = OnUncaughtException.id;
        /**
         * @inheritDoc
         */
        this.handler = this._makeErrorHandler();
    }
    /**
     * @inheritDoc
     */
    OnUncaughtException.prototype.setupOnce = function () {
        global.process.on('uncaughtException', this.handler.bind(this));
    };
    /**
     * @hidden
     */
    OnUncaughtException.prototype._makeErrorHandler = function () {
        var _this = this;
        var timeout = 2000;
        var caughtFirstError = false;
        var caughtSecondError = false;
        var calledFatalError = false;
        var firstError;
        return function (error) {
            var onFatalError = handlers_1.logAndExitProcess;
            var client = core_1.getCurrentHub().getClient();
            if (_this._options.onFatalError) {
                // eslint-disable-next-line @typescript-eslint/unbound-method
                onFatalError = _this._options.onFatalError;
            }
            else if (client && client.getOptions().onFatalError) {
                // eslint-disable-next-line @typescript-eslint/unbound-method
                onFatalError = client.getOptions().onFatalError;
            }
            if (!caughtFirstError) {
                var hub_1 = core_1.getCurrentHub();
                // this is the first uncaught error and the ultimate reason for shutting down
                // we want to do absolutely everything possible to ensure it gets captured
                // also we want to make sure we don't go recursion crazy if more errors happen after this one
                firstError = error;
                caughtFirstError = true;
                if (hub_1.getIntegration(OnUncaughtException)) {
                    hub_1.withScope(function (scope) {
                        scope.setLevel(types_1.Severity.Fatal);
                        hub_1.captureException(error, { originalException: error });
                        if (!calledFatalError) {
                            calledFatalError = true;
                            onFatalError(error);
                        }
                    });
                }
                else {
                    if (!calledFatalError) {
                        calledFatalError = true;
                        onFatalError(error);
                    }
                }
            }
            else if (calledFatalError) {
             