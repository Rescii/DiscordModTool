erned with describing a JSON structure and specifying valid elements
				in the structure. The second definition is the Hyper Schema specification
				which is intended define elements in a structure that can be interpreted as
				hyperlinks.
				Hyper Schema builds on JSON Schema to describe the hyperlink structure of 
				other JSON documents and elements of interaction. This allows user agents to be able to successfully navigate
				JSON documents based on their schemas.
			</t>
			<t>
				Cumulatively JSON Schema acts as a meta-document that can be used to define the required type and constraints on
				property values, as well as define the meaning of the property values
				for the purpose of describing a resource and determining hyperlinks
				within the representation. 
			</t>
			<figure>
				<preamble>An example JSON Schema that describes products might look like:</preamble>
				<artwork>
<![CDATA[	
{
	"title": "Product",
	"properties": {
		"id": {
			"type": "number",
			"description": "Product identifier",
			"required": true
		},
		"name": {
			"description": "Name of the product",
			"type": "string",
			"required": true
		},
		"price": {
			"required": true,
			"type": "number",
			"minimum": 0,
			"required": true
		},
		"tags": {
			"type": "array",
			"items": {
				"type": "string"
			}
		}
	},
	"links": [{
		"rel": "full",
		"href": "{id}"
	}, {
		"rel": "comments",
		"href": "comments/?id={id}"
	}]
}
]]>
				</artwork>
				<postamble>
					This schema defines the properties of the instance JSON documents, 
					the required properties (id, name, and price), as well as an optional
					property (tags). This also defines the link relations of the instance
					JSON documents.
				</postamble>
			</figure>
			
			<section title="Terminology">
				<t>
					For this specification, <spanx style="strong">schema</spanx> will be used to denote a JSON Schema 
					definition, and an <spanx style="strong">instance</spanx> refers to a JSON value that the schema 
					will be describing and validating.
				</t>
			</section>
			
			<section title="Design Considerations">
				<t>
					The JSON Schema media type does not attempt to dictate the structure of JSON
					representations that contain data, but rather provides a separate format
					for flexibly communicating how a JSON representation should be
					interpreted and validated, such that user agents can properly understand
					acceptable structures and extrapolate hyperlink information
					with the JSON document. It is acknowledged that JSON documents come
					in a variety of structures, and JSON is unique in that the structure
					of stored data structures often prescribes a non-ambiguous definite
					JSON representation. Attempting to force a specific structure is generally
					not viable, and therefore JSON Schema allows for a great flexibility
					in the structure of the JSON data that it describes.
				</t>
				<t>
					This specification is protocol agnostic.
					The underlying protocol (such as HTTP) should sufficiently define the
					semantics of the client-server interface, the retrieval of resource
					representations linked to by JSON representations, and modification of 
					those resources. The goal of this
					format is to sufficiently describe JSON structures such that one can
					utilize existing information available in existing JSON
					representations from a large variety of services that leverage a representational state transfer
					architecture using existing protocols.
				</t>
			</section>
		</section>
		
		<section title="Schema/Instance Association">
			<t>
				JSON Schema instances are correlated to their schema by the "describedby"
				relation, where the schema is defined to be the target of the relation.
				Instance representations may be of the "application/json" media type or
				any other subtype. Consequently, dictating how an instance
				representation should specify the relation to the schema is beyond the normative scope
				of this document (since this document specifically defines the JSON
				Schema media type, and no other), but it is recommended that instances
				specify their schema so that user agents can interpret the instance
				representation and messages may retain the self-descriptive
				characteristic, avoiding the need for out-of-band information about
				instance data. Two approaches are recommended for declaring the
				relation to the schema that describes the meaning of a JSON instance's (or collection 
				of instances) structure. A MIME type parameter named
				"profile" or a relation of "describedby" (which could be defined by a Link header) may be used:
				
				<figure>
					<artwork>
<![CDATA[	
Content-Type: application/my-media-type+json;
              profile=http://json.com/my-hyper-schema
]]>
					</artwork>
				</figure>
				
				or if the content is being transferred by a protocol (such as HTTP) that
				provides headers, a Link header can be used:
				
				<figure>
					<artwork>
<![CDATA[
Link: <http://json.com/my-hyper-schema>; rel="describedby"
]]>
					</artwork>
				</figure>
				
				Instances MAY specify multiple schemas, to indicate all the schemas that 
				are applicable to the data, and the data SHOULD be valid by all the schemas. 
				The instance data MAY have multiple schemas 
				that it is defined by (the instance data SHOULD be valid for those schemas). 
				Or if the document is a collection of instances, the collection MAY contain 
				instances from different schemas. When collections contain heterogeneous 
				instances, the "pathStart" attribute MAY be specified in the 
				schema to disambiguate which schema should be applied for each item in the 
				collection. However, ultimately, the mechanism for referencing a schema is up to the
				media type of the instance documents (if they choose to specify that schemas
				can be referenced).
			</t>
			
			<section title="Self-Descriptive Schema">
				<t>
					JSON Schemas can themselves be described using JSON Schemas. 
					A self-describing JSON Schema for the core JSON Schema can
					be found at <eref target="http://json-schema.org/schema">http://json-schema.org/schema</eref> for the latest version or 
					<eref target="http://json-schema.org/draft-03/schema">http://json-schema.org/draft-03/schema</eref> for the draft-03 version. The hyper schema 
					self-description can be found at <eref target="http://json-schema.org/hyper-schema">http://json-schema.org/hyper-schema</eref> 
					or <eref target="http://json-schema.org/draft-03/hyper-schema">http://json-schema.org/draft-03/hyper-schema</eref>. All schemas
					used within a protocol with media type definitions
					SHOULD include a MIME parameter that refers to the self-descriptive
					hyper schema or another schema that extends this hyper schema:
					
					<figure>
						<artwork>
<![CDATA[	
Content-Type: application/json; 
              profile=http://json-schema.org/draft-03/hyper-schema
]]>
						</artwork>
					</figure>
				</t>
			</section>
		</section>
		
		<section title="Core Schema Definition">
			<t>
				A JSON Schema is a JSON Object that defines various attributes 
				(including usage and valid values) of a JSON value. JSON
				Schema has recursive capabilities; there are a number of elements
				in the structure that allow for nested JSON Schemas.
			</t>
			
			<figure>
				<preamble>An example JSON Schema definition could look like:</preamble>
				<artwork>
<![CDATA[
{
	"description": "A person",
	"type": "object",

	"properties": {
		"name": {
			"type": "string"
		},
		"age": {
			"type": "integer",
			"maximum": 125
		}
	}
}
]]>
				</artwork>
			</figure>
			
			<t>
				A JSON Sch