type == 'null' }}
      else if ({{=$data}} === '' || {{=$data}} === 0 || {{=$data}} === false)
        {{=$coerced}} = null;
    {{?? it.opts.coerceTypes == 'array' && $type == 'array' }}
      else if ({{=$dataType}} == 'string' || {{=$dataType}} == 'number' || {{=$dataType}} == 'boolean' || {{=$data}} == null)
        {{=$coerced}} = [{{=$data}}];
    {{?}}
  {{~}}
  else {
    {{# def.error:'type' }}
  }

  if ({{=$coerced}} !== undefined) {
    {{# def.setParentData }}
    {{=$data}} = {{=$coerced}};
    {{? !$dataLvl }}if ({{=$parentData}} !== undefined){{?}}
      {{=$parentData}}[{{=$parentDataProperty}}] = {{=$coerced}};
  }
#}}
{{# def.definitions }}
{{# def.setupKeyword }}

{{ var $comment = it.util.toQuotedString($schema); }}
{{? it.opts.$comment === true }}
  console.log({{=$comment}});
{{?? typeof it.opts.$comment == 'function' }}
  self._opts.$comment({{=$comment}}, {{=it.util.toQuotedString($errSchemaPath)}}, validate.root.schema);
{{?}}
{{# def.definitions }}
{{# def.errors }}
{{# def.setupKeyword }}
{{# def.$data }}

{{? !$isData }}
  var schema{{=$lvl}} = validate.schema{{=$schemaPath}};
{{?}}
var {{=$valid}} = equal({{=$data}}, schema{{=$lvl}});
{{# def.checkError:'const' }}
{{? $breakOnError }} else { {{?}}
{{# def.definitions }}
{{# def.errors }}
{{# def.setupKeyword }}
{{# def.setupNextLevel }}


{{
  var $idx = 'i' + $lvl
    , $dataNxt = $it.dataLevel = it.dataLevel + 1
    , $nextData = 'data' + $dataNxt
    , $currentBaseId = it.baseId
    , $nonEmptySchema = {{# def.nonEmptySchema:$schema }};
}}

var {{=$errs}} = errors;
var {{=$valid}};

{{? $nonEmptySchema }}
  {{# def.setCompositeRule }}

  {{
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
  }}

  var {{=$nextValid}} = false;

  for (var {{=$idx}} = 0; {{=$idx}} < {{=$data}}.length; {{=$idx}}++) {
    {{
      $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
      var $passData = $data + '[' + $idx + ']';
      $it.dataPathArr[$dataNxt] = $idx;
    }}

    {{# def.generateSubschemaCode }}
    {{# def.optimizeValidate }}

    if ({{=$nextValid}}) break;
  }

  {{# def.resetCompositeRule }}
  {{= $closingBraces }}

  if (!{{=$nextValid}}) {
{{??}}
  if ({{=$data}}.length == 0) {
{{?}}

    {{# def.error:'contains' }}
  } else {
    {{? $nonEmptySchema }}
      {{# def.resetErrors }}
    {{?}}
  {{? it.opts.allErrors }} } {{?}}
{{# def.definitions }}
{{# def.errors }}
{{# def.setupKeyword }}
{{# def.$data }}

{{
  var $rule = this
    , $definition = 'definition' + $lvl
    , $rDef = $rule.definition
    , $closingBraces = '';
  var $validate = $rDef.validate;
  var $compile, $inline, $macro, $ruleValidate, $validateCode;
}}

{{? $isData && $rDef.$data }}
  {{
    $validateCode = 'keywordValidate' + $lvl;
    var $validateSchema = $rDef.validateSchema;
  }}
  var {{=$definition}} = RULES.custom['{{=$keyword}}'].definition;
  var {{=$validateCode}} = {{=$definition}}.validate;
{{??}}
  {{
    $ruleValidate = it.useCustomRule($rule, $schema, it.schema, it);
    if (!$ruleValidate) return;
    $schemaValue = 'validate.schema' + $schemaPath;
    $validateCode = $ruleValidate.code;
    $compile = $rDef.compile;
    $inline = $rDef.inline;
    $macro = $rDef.macro;
  }}
{{?}}

{{
  var $ruleErrs = $validateCode + '.errors'
    , $i = 'i' + $lvl
    , $ruleErr = 'ruleErr' + $lvl
    , $asyncKeyword = $rDef.async;

  if ($asyncKeyword && !it.async)
    throw new Error('async keyword in sync schema');
}}


{{? !($inline || $macro) }}{{=$ruleErrs}} = null;{{?}}
var {{=$errs}} = errors;
var {{=$valid}};

{{## def.callRuleValidate:
  {{=$validateCode}}.call(
    {{? it.opts