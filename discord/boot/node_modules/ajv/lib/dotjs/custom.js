SAA2B7F,GACzB,IAAK,IAAIy6B,KAAQz6B,EAAKmC,MAAM0D,QAAS,CAEnC7F,EAAK68B,UAAUpC,EADFz6B,EAAKmC,MAAM0D,QAAQ40B,KA1YhBiE,CAAkBz+B,MAChC2I,EAAKkJ,UA+YX,SAA4B9R,GAC1B,IAAK,IAAIy6B,KAAQz6B,EAAKmC,MAAM2P,SAAU,CAEpC9R,EAAK09B,WAAWjD,EADFz6B,EAAKmC,MAAM2P,SAAS2oB,KAjZjBkE,CAAmB1+B,MAiXxC,SAA8BD,GAC5B,IAAI4+B,EACA5+B,EAAKmC,MAAM8S,QACb2pB,EAAcl+B,EAAQ,oBACtBV,EAAKi8B,cAAc2C,EAAaA,EAAYnoB,KAAK,IAEnD,IAAwB,IAApBzW,EAAKmC,MAAMF,KAAgB,OAC/B,IAAIiU,EAAaxV,EAAQ,oCACrBV,EAAKmC,MAAM8S,QAAOiB,EAAa0lB,EAAgB1lB,EAAY4nB,IAC/D99B,EAAKi8B,cAAc/lB,EAAYmmB,GAAgB,GAC/Cr8B,EAAKuD,MAAM,iCAAmC84B,EA1X9CwC,CAAqB5+B,MACG,iBAAb2I,EAAK3G,MAAkBhC,KAAKg8B,cAAcrzB,EAAK3G,MACtD2G,EAAK+c,UAAU1lB,KAAKy9B,WAAW,WAAY,CAACxnB,WAAY,CAACpF,KAAM,aA4XrE,SAA2B9Q,GACzB,IAAI8+B,EAAc9+B,EAAKmC,MAAM48B,QAC7B,IAAKD,EAAa,OAClB,GAAI9uB,MAAMC,QAAQ6uB,GAAc9+B,EAAKsD,UAAUw7B,QAC1C,IAAK,IAAIv9B,KAAOu9B,EAAa9+B,EAAKsD,UAAUw7B,EAAYv9B,GAAMA,GA/XnEy9B,CAAkB/+B,MA2JpB,SAASs8B,EAAcv8B,EAAMs8B,GAE3B,OADAA,EAASx4B,EAAQM,YAAYk4B,GACtBt8B,EAAKwD,SAAS84B,IAAWt8B,EAAKuD,MAAM+4B,IAAWt8B,EAAKw8B,WAAWF,GA8CxE,SAASK,EAAkB38B,EAAM++B,EAAS13B,GACxC,IAAK,IAAIi1B,KAAUyC,EAAS,CAC1B,IAAIv8B,EAAYu8B,EAAQzC,GACnB95B,EAAUP,MAAUoF,IAASA,EAAMS,KAAKw0B,KAC3Ct8B,EAAKoB,OAAOM,IAAIc,EAAUo6B,iBACnBmC,EAAQzC,KAqGrB,SAASnuB,EAAOnM,GAEd,OADIA,EAAOyU,KAAKxW,KAAK+K,OAAOkT,KAAK,qBAAsBlc,EAAOyU,KACvDzU,EAAOqM,GAIhB,SAASgwB,EAAQr8B,GAEf,OADIA,EAAOqM,IAAIpO,KAAK+K,OAAOkT,KAAK,oBAAqBlc,EAAOqM,IACrDrM,EAAOyU,IAIhB,SAAS2nB,EAAYp8B,GACnB,GAAIA,EAAOyU,KAAOzU,EAAOqM,IAAMrM,EAAOyU,KAAOzU,EAAOqM,GAClD,MAAM,IAAIxN,MAAM,mCAClB,OAAOmB,EAAOyU,KAAOzU,EAAOqM,GA+E9B,SAAS2tB,EAAYh8B,EAAMqO,GACzB,GAAIrO,EAAKwD,SAAS6K,IAAOrO,EAAKuD,MAAM8K,GAClC,MAAM,IAAIxN,MAAM,0BAA4BwN,EAAK,oBAyBrD,SAAS2vB,OAEP,CAACiB,UAAU,EAAEC,YAAY,EAAEC,kBAAkB,EAAEC,0BAA0B,EAAEC,oBAAoB,EAAEC,oBAAoB,EAAEC,kBAAkB,EAAEC,uBAAuB,EAAEC,iBAAiB,GAAGC,SAAS,GAAGC,YAAY,GAAGC,mBAAmB,GAAGxoB,mCAAmC,GAAG3J,6BAA6B,MAAM,GAAG,GAnhOoD,CAmhOhD"}declare var ajv: {
  (options?: ajv.Options): ajv.Ajv;
  new(options?: ajv.Options): ajv.Ajv;
  ValidationError: typeof AjvErrors.ValidationError;
  MissingRefError: typeof AjvErrors.MissingRefError;
  $dataMetaSchema: object;
}

declare namespace AjvErrors {
  class ValidationError extends Error {
    constructor(errors: Array<ajv.ErrorObject>);

    message: string;
    errors: Array<ajv.ErrorObject>;
    ajv: true;
    validation: true;
  }

  class MissingRefError extends Error {
    constructor(baseId: string, ref: string, message?: string);
    static message: (baseId: string, ref: string) => string;

    message: string;
    missingRef: string;
    missingSchema: string;
  }
}

declare namespace ajv {
  type ValidationError = AjvErrors.ValidationError;

  type MissingRefError = AjvErrors.MissingRefError;

  interface Ajv {
    /**
    * Validate data using schema
    * Schema will be compiled and cached (using serialized JSON as key, [fast-json-stable-stringify](https://github.com/epoberezkin/fast-json-stable-stringify) is used to serialize by default).
    * @param  {string|object|Boolean} schemaKeyRef key, ref or schema object
    * @param  {Any} data to be validated
    * @return {Boolean} validation result. Errors from the last validation will be available in `ajv.errors` (and also in compiled schema: `schema.errors`).
    */
    validate(schemaKeyRef: object | string | boolean, data: any): boolean | PromiseLike<any>;
    /**
    * Create validating function for passed schema.
    * @param  {object|Boolean} schema schema object
    * @return {Function} validating function
    */
    compile(schema: object | boolean): ValidateFunction;
    /**
    * Creates validating function for passed schema with asynchronous loading of missing schemas.
    * `loadSchema` option should be a function that accepts schema uri and node-style callback.
    * @this  Ajv
    * @param {object|Boolean} schema schema object
    * @param {Boolean} meta optional true to compile meta-schema; this parameter can be skipped
    * @param {Function} callback optional node-style callback, it is always called with 2 parameters: error (or null) and validating function.
    * @return {PromiseLike<ValidateFunction>} validating function
    */
    compileAsync(schema: object | boolean, meta?: Boolean, callback?: (err: Error, validate: ValidateFunction) => any): PromiseLike<ValidateFunction>;
    /**
    * Adds schema to the instance.
    * @param {object|Array} schema schema or array of schemas. If array is passed, `key` and other parameters will be ignored.
    * @param {string} key Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.
    * @return {Ajv} this for method chaining
    */
    addSchema(schema: Array<object> | object, key?: string): Ajv;
    /**
    * Add schema that will be used to validate other schemas
    * options in META_IGNORE_OPTIONS are alway set to false
    * @param {object} schema schema object
    * @param {string} key optional schema key
    * @return {Ajv} this for method chaining
    */
    addMetaSchema(schema: object, key?: string): Ajv;
    /**
    * Validate schema
    * @param {object|Boolean} schema schema to validate
    * @return {Boolean} true if schema is valid
    */
    validateSchema(schema: object | boolean): boolean;
    /**
    * Get compiled schema from the instance by `key` or `ref`.
    * @param  {string} keyRef `key` that was passed to `addSchema` or full schema reference (`schema.id` or resolved id).
    * @return {Function} schema validating function (with property `schema`). Returns undefined if keyRef can't be resolved to an existing schema.
    */
    getSchema(keyRef: string): ValidateFunction | undefined;
    /**
    * Remove cached schema(s).
    * If no parameter is passed all schemas but meta-schemas are removed.
    * If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
    * Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
    * @param  {string|object|RegExp|Boolean} schemaKeyRef key, ref, pattern to match key/ref or schema object
    * @return {Ajv} this for method chaining
    */
    removeSchema(schemaKeyRef?: object | string | RegExp | boolean): Ajv;
    /**
    * Add custom format
    * @param {string} name format name
    * @param {string|RegExp|Function} format string is converted to RegExp; function should return boolean (true when valid)
    * @return {Ajv} this for method chaining
    */
    addFormat(name: string, format: FormatValidator | FormatDefinition): Ajv;
    /**
    * Define custom keyword
    * @this  Ajv
    * @param {string} keyword custom keyword, should be a valid identifier, should be different from all standard, custom and macro keywords.
    * @param {object} definition keyword definition object with properties `type` (type(s) which the keyword applies to), `validate` or `compile`.
    * @return {Ajv} this for method chaining
    */
    addKeyword(keyword: string, definition: KeywordDefinition): Ajv;
    /**
    * Get keyword definition
    * @this  Ajv
    * @param {string} keyword pre-defined or custom keyword.
    * @return {object|Boolean} custom keyword definition, `true` if it is a predefined keyword, `false` otherwise.
    */
    getKeyword(keyword: string): object | boolean;
    /**
    * Remove keyword
    * @this  Ajv
    * @param {string} keyword pre-defined or custom keyword.
    * @return {Ajv} this for method chaining
    */
    removeKeyword(keyword: string): Ajv;
    /**
    * Validate keyword
    * @this  Ajv
    * @param {object} definition keyword definition object
    * @param {boolean} throwError true to throw exception if definition is invalid
    * @return {boolean} validation result
    */
    validateKeyword(definition: KeywordDefinition, throwError: boolean): boolean;
    /**
    * Convert array of error message objects to string
    * @param  {Array<object>} errors optional array of validation errors, if not passed errors from the instance are used.
    * @param  {object} options optional options with properties `separator` and `dataVar`.
    * @return {string} human readable string with all errors descriptions
    */
    errorsText(errors?: Array<ErrorObject> | null, options?: ErrorsTextOptions): string;
    errors?: Array<ErrorObject> | null;
    _opts: Options;
  }

  interface CustomLogger {
    log(...args: any[]): any;
    warn(...args: any[]): any;
    error(...args: any[]): any;
  }

  interface ValidateFunction {
    (
      data: any,
      dataPath?: string,
      parentData?: object | Array<any>,
      parentDataProperty?: string | number,
      rootData?: object | Array<any>
    ): boolean | PromiseLike<any>;
    schema?: object | boolean;
    errors?: null | Array<ErrorObject>;
    refs?: object;
    refVal?: Array<any>;
    root?: ValidateFunction | object;
    $async?: true;
    source?: object;
  }

  interface Options {
    $data?: boolean;
    allErrors?: boolean;
    verbose?: boolean;
    jsonPointers?: boolean;
    uniqueItems?: boolean;
    unicode?: boolean;
    format?: false | string;
    formats?: object;
    keywords?: object;
    unknownFormats?: true | string[] | 'ignore';
    schemas?: Array<object> | object;
    schemaId?: '$id' | 'id' | 'auto';
    missingRefs?: true | 'ignore' | 'fail';
    extendRefs?: true | 'ignore' | 'fail';
    loadSchema?: (uri: string, cb?: (err: Error, schema: object) => void) => PromiseLike<object | boolean>;
    removeAdditional?: boolean | 'all' | 'failing';
    useDefaults?: boolean | 'empty' | 'shared';
    coerceTypes?: boolean | 'array';
    strictDefaults?: boolean | 'log';
    strictKeywords?: boolean | 'log';
    strictNumbers?: boolean;
    async?: boolean | strin