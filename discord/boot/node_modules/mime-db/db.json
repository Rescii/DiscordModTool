 normative link description schema is: 
						<eref target="http://json-schema.org/links">http://json-schema.org/links</eref> (latest version) or
						<eref target="http://json-schema.org/draft-03/links">http://json-schema.org/draft-03/links</eref> (draft-03 version).
					</t>
					
					<section title="href">
						<t>
							The value of the "href" link description property
							indicates the target URI of the related resource. The value
							of the instance property SHOULD be resolved as a URI-Reference per <xref target="RFC3986">RFC 3986</xref>
							and MAY be a relative URI. The base URI to be used for relative resolution
							SHOULD be the URI used to retrieve the instance object (not the schema)
							when used within a schema. Also, when links are used within a schema, the URI 
							SHOULD be parametrized by the property values of the instance 
							object, if property values exist for the corresponding variables
							in the template (otherwise they MAY be provided from alternate sources, like user input).
						</t>
						
						<t>
							Instance property values SHOULD be substituted into the URIs where
							matching braces ('{', '}') are found surrounding zero or more characters,
							creating an expanded URI. Instance property value substitutions are resolved
							by using the text between the braces to denote the property name
							from the instance to get the value to substitute. 
							
							<figure>
								<preamble>For example, if an href value is defined:</preamble>
								<artwork>
<![CDATA[
http://somesite.com/{id}
]]>
								</artwork>
								<postamble>Then it would be resolved by replace the value of the "id" property value from the instance object.</postamble>
							</figure>
							
							<figure>
								<preamble>If the value of the "id" property was "45", the expanded URI would be:</preamble>
								<artwork>
<![CDATA[
http://somesite.com/45
]]>
								</artwork>
							</figure>
							
							If matching braces are found with the string "@" (no quotes) between the braces, then the 
							actual instance value SHOULD be used to replace the braces, rather than a property value.
							This should only be used in situations where the instance is a scalar (string, 
							boolean, or number), and not for objects or arrays.
						</t>
					</section>
					
					<section title="rel">
						<t>
							The value of the "rel" property indicates the name of the 
							relation to the target resource. The relation to the target SHOULD be interpreted as specifically from the instance object that the schema (or sub-schema) applies to, not just the top level resource that contains the object within its hierarchy. If a resource JSON representation contains a sub object with a property interpreted as a link, that sub-object holds the relation with the target. A relation to target from the top level resource MUST be indicated with the schema describing the top level JSON representation.
						</t>
						
						<t>
							Relationship definitions SHOULD NOT be media type dependent, and users are encouraged to utilize existing accepted relation definitions, including those in existing relation registries (see <xref target="RFC4287">RFC 4287</xref>). However, we define these relations here for clarity of normative interpretation within the context of JSON hyper schema defined relations:
							
							<list style="hanging">
								<t hangText="self">
									If the relation value is "self", when this property is encountered in
									the instance object, the object represents a resource and the instance object is
									treated as a full representation of the target resource identified by
									the specified URI.
								</t>
								
								<t hangText="full">
									This indicates that the target of the link is the full representation for the instance object. The object that contains this link possibly may not be the full representation.
								</t>
								
								<t hangText="describedby">
									This indicates the target of the link is the schema for the instance object. This MAY be used to specifically denote the schemas of objects within a JSON object hierarchy, facilitating polymorphic type data structures.
								</t>
								
								<t hangText="root">
									This relation indicates that the target of the link
									SHOULD be treated as the root or the body of the representation for the
									purposes of user agent interaction or fragment resolution. All other
									properties of the instance objects can be regarded as meta-data
									descriptions for the data.
								</t>
							</list>
						</t>
						
						<t>
							The following relations are applicable for schemas (the schema as the "from" resource in the relation):

							<list style="hanging">
								<t hangText="instances">This indicates the target resource that represents collection of instances of a schema.</t>
								<t hangText="create">This indicates a target to use for creating new instances of a schema. This link definition SHOULD be a submission link with a non-safe method (like POST).</t>
							</list>
						</t>
						
						<t>
							<figure>
								<preamble>For example, if a schema is defined:</preamble>
								<artwork>
<![CDATA[
{
	"links": [{
		"rel": "self",
		"href": "{id}"
	}, {
		"rel": "up",
		"href": "{upId}"
	}, {
		"rel": "children",
		"href": "?upId={id}"
	}]
}
]]>
								</artwork>
							</figure>
							
							<figure>
								<preamble>And if a collection of instance resource's JSON representation was retrieved:</preamble>
								<artwork>
<![CDATA[
GET /Resource/

[{
	"id": "thing",
	"upId": "parent"
}, {
	"id": "thing2",
	"upId": "parent"
}]
]]>
								</artwork>
							</figure>

							This would indicate that for the first item in the collection, its own
							(self) URI would resolve to "/Resource/thing" and the first item's "up"
							relation SHOULD be resolved to the resource at "/Resource/parent".
							The "children" collection would be located at "/Resource/?upId=thing".
						</t>
					</section>
					
					<section title="targetSchema">
						<t>This property value is a schema that defines the expected structure of the JSON representation of the target of the link.</t>
					</section>
					
					<section title="Submission Link Properties">
						<t>
							The following properties also apply to link definition objects, and 
							provide functionality analogous to HTML forms, in providing a 
							means for submitting extra (often user supplied) information to send to a server.
						</t>
						
						<section title="method">
							<t>
								This attribute defines which method can be used to access the target resource. 
								In an HTTP environment, this would be "GET" or "POST" (other HTTP methods 
								such as "PUT" and "DELETE" have semantics that are clearly implied by 
								accessed resources, and do not need to be defined here). 
								This defaults to "GET".
							</t>
						</section>
						
						<section title="enctype">
							<t>
								If present, this property indicates a query media type format that the server
								supports for querying or posting to the collection of instances at the target 
								resource. The query can be 
								suffixed to the target URI to query the collection with
								property-based constraints on the resources that SHOULD be returned from
								the server or used to post data to the resource (depending on the method).
								
								<figure>
									<preamble>For example, with the following schema:</preamble>
									<artwork>
<![CDATA[
{
	"links": [{
		"enctype": "application/x-www-form-urlencoded",
		"method": "GET",
		"href": "/Product/",
		"properties": {
			"name": {
				"description": "name of the product"
			}
		}
	}]
}
]]>
									</artwork>
									<postamble>This indicates that the client can query the server for instances that have a specific name.</postamble>
								</figure>
								
								<figure>
									<preamble>For example:</preamble>
									<artwork>
<![CDATA[
/Product/?name=Slinky
]]>
									</artwork>
								</figure>

								If no enctype or method is specified, only the single URI specified by 
								the href property is defined. If the method is POST, "application/json" is 
								the default media type.
							</t>
						</section>
						
						<section title="schema">
							<t>
								This attribute contains a schema which defines the acceptable structure of the submitted
								request (for a GET request, this schema would define the properties for the query string 
								and for a POST request, this would define the body).
							</t>
						</section>
					</section>
				</section>
			</section>
			
			<section title="fragmentResolution">
				<t>
					This property indicates the fragment resolution protocol to use for
					resolving fragment identifiers in URIs within the instance
					representations. This applies to the instance object URIs and all
					children of the instance object's URIs. The default fragment resolution
					protocol is "slash-delimited", which is defined below. Other fragment
					resolution protocols MAY be used, but are not defined in this document.
				</t>
				
				<t>
					The fragment identifier is based on <xref target="RFC2396">RFC 2396, Sec 5</xref>, and defines the
					mechanism for resolving references to entities within a document.
				</t>
				
				<section title="slash-delimited fragment resolution">
					<t>
						With the slash-delimited fragment resolution protocol, the fragment
						identifier is interpreted as a series of property reference tokens that start with and
						are delimited by the "/" character (\x2F). Each property reference token
						is a series of unreserved or escaped URI characters. Each property
						reference token SHOULD be interpreted, starting from the beginning of
						the fragment identifier, as a path reference in the target JSON
						structure. The final target value of the fragment can be determined by
						starting with the root of the JSON structure from the representation of
						the resource identified by the pre-fragment URI. If the target is a JSON
						object, then the new target is the value of the property with the name
						identified by the next property reference token in the fragment. If the
						target is a JSON array, then the target is determined by finding the
						item in array the array with the index defined by the next property
						reference token (which MUST be a number). The target is successively
						updated for each property reference token, until the entire fragment has
						been traversed. 
					</t>
					
					<t>
						Property names SHOULD be URI-encoded. In particular, any "/" in a 
						property name MUST be encoded to avoid being interpreted as a property 
						delimiter.
					</t>
					
					<t>
						<figure>
							<preamble>For example, for the following JSON representation:</preamble>
							<artwork>
<![CDATA[
{
	"foo": {
		"anArray": [{
			"prop": 44
		}],
		"another prop": {
			"baz": "A string"
		}
	}
}
]]>
							</artwork>
						</figure>
						
						<figure>
							<preamble>The following fragment identifiers would be resolved:</preamble>
							<artwork>
<![CDATA[
fragment identifier      resolution
-------------------      ----------
#                        self, the root of the resource itself
#/foo                    the object referred to by the foo property
#/foo/another%20prop     the object referred to by the "another prop"
                         property of the object referred to by the 
                         "foo" property
#/foo/another%20prop/baz the string referred to by the value of "baz"
                         property of the "another prop" property of 
                         the object referred to by the "foo" property
#/foo/anArray/0          the first object in the "anArray" array
]]>
							</artwork>
						</figure>
					</t>
				</section>
				
				<section title="dot-delimited fragment resolution">
					<t>
						The dot-delimited fragment resolution protocol is the same as 
						slash-delimited fragment resolution protocol except that the "." character 
						(\x2E) is used as the delimiter between property names (instead of "/") and 
						the path does not need to start with a ".". For example, #.foo and #foo are a valid fragment
						identifiers for referencing the value of the foo propery.
					</t>
				</section>
			</section>
			
			<section title="readonly">
				<t>This attribute indicates that the instance property SHOULD NOT be changed. Attempts by a user agent to modify the value of this property are expected to be rejected by a server.</t>
			</section>
			
			<section title="contentEncoding">
				<t>If the instance property value is a string, this attribute defines that the string SHOULD be interpreted as binary data and decoded using the encoding named by this schema property. <xref target="RFC2045">RFC 2045, Sec 6.1</xref> lists the possible values for this property.</t>
			</section>
			
			<section title="pathStart">
				<t>
					This attribute is a URI that defines what the instance's URI MUST start with in order to validate. 
					The value of the "pathStart" attribute MUST be resolved as per <xref target="RFC3986">RFC 3986, Sec 5</xref>, 
					and is relative to the instance's URI.
				</t>
				
				<t>
					When multiple schemas have been referenced for an instance, the user agent 
					can determine if this schema is applicable for a particular instance by 
					determining if the URI of the instance begins with the the value of the "pathStart"
					attribute. If the URI of the instance does not start with this URI, 
					or if another schema specifies a starting URI that is longer and also matches the 
					instance, this schema SHOULD NOT be applied to the instance. Any schema 
					that does not have a pathStart attribute SHOULD be considered applicable 
					to all the instances for which it is referenced.
				</t>
			</section>
			
			<section title="mediaType">
				<t>This attribute defines the media type of the instance representations that this schema is defining.</t>
			</section>
		</section>
		
		<section title="Security Considerations">
			<t>
				This specification is a sub-type of the JSON format, and 
				consequently the security considerations are generally the same as <xref target="RFC4627">RFC 4627</xref>. 
				However, an additional issue is that when link relation of "self"
				is used to denote a full representation of an object, the user agent 
				SHOULD NOT consider the representation to be the authoritative representation
				of the resource denoted by the target URI if the target URI is not
				equivalent to or a sub-path of the the URI used to request the resource 
				representation which contains the target URI with the "self" link.
				
				<figure>
					<preamble>For example, if a hyper schema was defined:</preamble>
					<artwork>
<![CDATA[
{
	"links": [{
		"rel": "self",
		"href": "{id}"
	}]
}
]]>
					</artwork>
				</figure>
				
				<figure>
					<preamble>And a resource was requested from somesite.com:</preamble>
					<artwork>
<![CDATA[
GET /foo/
]]>
					</artwork>
				</figure>

				<figure>
					<preamble>With a response of:</preamble>
					<artwork>
<![CDATA[
Content-Type: application/json; profile=/schema-for-this-data

[{
	"id": "bar",
	"name": "This representation can be safely treated \
		as authoritative "
}, {
	"id": "/baz",
	"name": "This representation should not be treated as \
		authoritative the user agent should make request the resource\
		from '/baz' to ensure it has the authoritative representation"
}, {
	"id": "http://othersite.com/something",
	"name": "This representation\
		should also not be treated as authoritative and the target\
		resource representation should be retrieved for the\
		authoritative representation"
}]
]]>
					</artwork>
				</figure>
			</t>
		</section>
		
		<section title="IANA Considerations">
			<t>The proposed MIME media type for JSON Schema is "application/schema+json".</t>
			<t>Type name: application</t>
			<t>Subtype name: schema+json</t>
			<t>Required parameters: profile</t>
			<t>
				The value of the profile parameter SHOULD be a URI (relative or absolute) that 
				refers to the schema used to define the structure of this structure (the 
				meta-schema). Normally the value would be http://json-schema.org/draft-03/hyper-schema,
				but it is allowable to use other schemas that extend the hyper schema's meta-
				schema.
			</t>
			<t>Optional parameters: pretty</t>
			<t>The value of the pretty parameter MAY be true or false to indicate if additional whitespace has been included to make the JSON representation easier to read.</t>
			
			<section title="Registry of Link Relations">
				<t>
					This registry is maintained by IANA per <xref target="RFC4287">RFC 4287</xref> and this specification adds
					four values: "full", "create", "instances", "root".  New
					assignments are subject to IESG Approval, as outlined in <xref target="RFC5226">RFC 5226</xref>.
					Requests should be made by email to IANA, which will then forward the
					request to the IESG, requesting approval.
				</t>
			</section>
		</section>
	</middle>
	
	<back>
		<!-- References Section -->
		<references title="Normative References">
			&rfc2045;
			&rfc2119;
			&rfc2396;
			&rfc3339;
			&rfc3986;
			&rfc4287;
		</references>
		<references title="Informative References">
			&rfc2616;
			&rfc4627;
			&rfc5226;
			&iddiscovery;
			&uritemplate;
			&linkheader;
			&html401;
			&css21;
		</references>

		<section title="Change Log">
			<t>
				<list style="hanging">
					<t hangText="draft-03">
						<list style="symbols">
							<t>Added example and verbiage to "extends" attribute.</t>
							<t>Defined slash-delimited to use a leading slash.</t>
							<t>Made "root" a relation instead of an attribute.</t>
							<t>Removed address values, and MIME media type from format to reduce confusion (mediaType already exists, so it can be used for MIME types).</t>
							<t>Added more explanation of nullability.</t>
							<t>Removed "alternate" attribute.</t>
							<t>Upper cased many normative usages of must, may, and should.</t>
							<t>Replaced the link submission "properties" attribute to "schema" attribute.</t>
							<t>Replaced "optional" attribute with "required" attribute.</t>
							<t>Replaced "maximumCanEqual" attribute with "exclusiveMaximum" attribute.</t>
							<t>Replaced "minimumCanEqual" attribute with "exclusiveMinimum" attribute.</t>
							<t>Replaced "requires" attribute with "dependencies" attribute.</t>
							<t>Moved "contentEncoding" attribute to hyper schema.</t>
							<t>Added "additionalItems" attribute.</t>
							<t>Added "id" attribute.</t>
							<t>Switched self-referencing variable substitution from "-this" to "@" to align with reserved characters in URI template.</t>
							<t>Added "patternProperties" attribute.</t>
							<t>Schema URIs are now namespace versioned.</t>
							<t>Added "$ref" and "$schema" attributes.</t>
						</list>
					</t>
					
					<t hangText="draft-02">
						<list style="symbols">
							<t>Replaced "maxDecimal" attribute with "divisibleBy" attribute.</t>
							<t>Added slash-delimited fragment resolution protocol and made it the default.</t>
							<t>Added language about using links outside of schemas by referencing its normative URI.</t>
							<t>Added "uniqueItems" attribute.</t>
							<t>Added "targetSchema" attribute to link description object.</t>
						</list>
					</t>
					
					<t hangText="draft-01">
						<list style="symbols">
							<t>Fixed category and updates from template.</t>
						</list>
					</t>
					
					<t hangText="draft-00">
						<list style="symbols">
							<t>Initial draft.</t>
						</list>
					</t>
				</list>
			</t>
		</section>
		
		<section title="Open Issues">
			<t>
				<list>
					<t>Should we give a preference to MIME headers over Link headers (or only use one)?</t>
					<t>Should "root" be a MIME parameter?</t>
					<t>Should "format" be renamed to "mediaType" or "contentType" to reflect the usage MIME media types that are allowed?</t>
					<t>How should dates be handled?</t>
				</list>
			</t>
		</section>
	</back>
</rfc>
<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY rfc4627 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4627.xml">
<!ENTITY rfc3986 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3986.xml">
<!ENTITY rfc2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY rfc4287 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4287.xml">
<!ENTITY rfc2616 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2616.xml">
<!ENTITY rfc3339 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3339.xml">
<!ENTITY rfc2045 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2045.xml">
<!ENTITY rfc5226 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5226.xml">
<!ENTITY iddiscovery SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.hammer-discovery.xml">
<!ENTITY uritemplate SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.gregorio-uritemplate.xml">
<!ENTITY linkheader SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.nottingham-http-link-header.xml">
<!ENTITY html401 SYSTEM "http://xml.resource.org/public/rfc/bibxml4/reference.W3C.REC-html401-19991224.xml">
<!ENTITY css21 SYSTEM "http://xml.resource.org/public/rfc/bibxml4/reference.W3C.CR-CSS21-20070719.xml">
]>
<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<?rfc strict="no"?>
<?rfc rfcedstyle="yes"?>
<rfc category="info" docName="draft-zyp-json-schema-04" ipr="trust200902">
	<front>
		<title abbrev="JSON Schema Media Type">A JSON Media Type for Describing the Structure and Meaning of JSON Documents</title>
		
		<author fullname="Kris Zyp" initials="K" role="editor" surname="Zyp">
			<organization>SitePen (USA)</organization>
			<address>
				<postal>
					<street>530 Lytton Avenue</street>
					<city>Palo Alto, CA 94301</city>
					<country>USA</country>
				</postal>
				<phone>+1 650 968 8787</phone>
				<email>kris@sitepen.com</email>
			</address>
		</author>
		
		<author fullname="Gary Court" initials="G" surname="Court">
			<address>
				<postal>
					<street></street>
					<city>Calgary, AB</city>
					<country>Canada</country>
				</postal>
				<email>gary.court@gmail.com</email>
			</address>
		</author>
		
		<date year="2011" />
		<workgroup>Internet Engineering Task Force</workgroup>
		<keyword>JSON</keyword>
		<keyword>Schema</keyword>
		<keyword>JavaScript</keyword>
		<keyword>Object</keyword>
		<keyword>Notation</keyword>
		<keyword>Hyper Schema</keyword>
		<keyword>Hypermedia</keyword>
		
		<abstract>
			<t>
				JSON (JavaScript Object Notation) Schema defines the media type "application/schema+json", 
				a JSON based format for defining the structure of JSON data. JSON Schema provides a contract for what JSON 
				data is required for a given application and how to interact with it. JSON 
				Schema is intended to define validation, documentation, hyperlink 
				navigation, and interaction control of JSON data. 
			</t>
		</abstract>
	</front>
	
	<middle>
		<section title="Introduction">
			<t>
				JSON (JavaScript Object Notation) Schema is a JSON media type for defining 
				the structure of JSON data. JSON Schema provides a contract for what JSON 
				data is required for a given application and how to interact with it. JSON 
				Schema is intended to define validation, documentation, hyperlink 
				navigation, and interaction control of JSON data. 
			</t>
		</section>
		
		<section title="Conventions and Terminology">
			<t>
				<!-- The text in this section has been copied from the official boilerplate, 
				and should not be modified.-->
				
				The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", 
				"SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be
				interpreted as described in <xref target="RFC2119">RFC 2119</xref>.
			</t>
			
			<t>
				The terms "JSON", "JSON text", "JSON value", "member", "element", "object", 
				"array", "number", "string", "boolean", "true", "false", and "null" in this 
				document are to be interpreted as defined in <xref target="RFC4627">RFC 4627</xref>.
			</t>
			
			<t>
				This specification also uses the following defined terms:
			
				<list style="hanging">
					<t hangText="schema">A JSON Schema object.</t>
					<t hangText="instance">Equivalent to "JSON value" as defined in <xref target="RFC4627">RFC 4627</xref>.</t>
					<t hangText="property">Equivalent to "member" as defined in <xref target="RFC4627">RFC 4627</xref>.</t>
					<t hangText="item">Equivalent to "element" as defined in <xref target="RFC4627">RFC 4627</xref>.</t>
					<t hangText="attribute">A property of a JSON Schema object.</t>
				</list>
			</t>
		</section>
		
		<section title="Overview">
			<t>
				JSON Schema defines the media type "application/schema+json" for 
				describing the structure of JSON text. JSON Schemas are also written in JSON and includes facilities 
				for describing the structure of JSON in terms of
				allowable values, descriptions, and interpreting relations with other resources.
			</t>
			<t>
				This document is organized into several separate definitions. The first 
				definition is the core schema specification. This definition is primary 
				concerned with describing a JSON structure and specifying valid elements
				in the structure. The second definition is the Hyper Schema specification
				which is intended to define elements in a structure that can be interpreted as
				hyperlinks.
				Hyper Schema builds on JSON Schema to describe the hyperlink structure of 
				JSON values. This allows user agents to be able to successfully navigate
				documents containing JSON based on their schemas.
			</t>
			<t>
				Cumulatively JSON Schema acts as meta-JSON that can be used to define the 
				required type and constraints on JSON values, as well as define the meaning
				of the JSON values for the purpose of describing a resource and determining
				hyperlinks within the representation. 
			</t>
			<figure>
				<preamble>An example JSON Schema that describes products might look like:</preamble>
				<artwork>
<![CDATA[	
{
	"title": "Product",
	"properties": {
		"id": {
			"title": "Product Identifier",
			"type": "number"
		},
		"name": {
			"title": "Product Name",
			"type": "string"
		},
		"price": {
			"type": "number",
			"minimum": 0
		},
		"tags": {
			"type": "array",
			"items": {
				"type": "string"
			}
		}
	},
	"required" : ["id", "name", "price"],
	"links": [{
		"rel": "full",
		"href": "{id}"
	}, {
		"rel": "comments",
		"href": "comments/?id={id}"
	}]
}
]]>
				</artwork>
				<postamble>
					This schema defines the properties of the instance, 
					the required properties (id, name, and price), as well as an optional
					property (tags). This also defines the link relations of the instance.
				</postamble>
			</figure>
			
			<section title="Design Considerations">
				<t>
					The JSON Schema media type does not attempt to dictate the structure of JSON
					values that contain data, but rather provides a separate format
					for flexibly communicating how a JSON value should be
					interpreted and validated, such that user agents can properly understand
					acceptable structures and extrapolate hyperlink information
					from the JSON. It is acknowledged that JSON values come
					in a variety of structures, and JSON is unique in that the structure
					of stored data structures often prescribes a non-ambiguous definite
					JSON representation. Attempting to force a specific structure is generally
					not viable, and therefore JSON Schema allows for a great flexibility
					in the structure of the JSON data that it describes.
				</t>
				<t>
					This specification is protocol agnostic.
					The underlying protocol (such as HTTP) should sufficiently define the
					semantics of the client-server interface, the retrieval of resource
					representations linked to by JSON representations, and modification of 
					those resources. The goal of this
					format is to sufficiently describe JSON structures such that one can
					utilize existing information available in existing JSON
					representations from a large variety of services that leverage a representational state transfer
					architecture using existing protocols.
				</t>
			</section>
		</section>
		
		<section title="Schema/Instance Association">
			<t>
				JSON values are correlated to their schema by the "describedby"
				relation, where the schema is the target of the relation.
				JSON values MUST be of the "application/json" media type or
				any other subtype. Consequently, dictating how a JSON value should 
				specify the relation to the schema is beyond the normative scope
				of this document since this document specifically defines the JSON
				Schema media type, and no other. It is RECOMMNENDED that JSON values
				specify their schema so that user agents can interpret the instance
				and retain the self-descriptive	characteristics. This avoides the need for out-of-band information about
				instance data. Two approaches are recommended for declaring the
				relation to the schema that describes the meaning of a JSON instance's (or collection 
				of instances) structure. A MIME type parameter named
				"profile" or a relation of "describedby" (which could be specified by a Link header) may be used:
				
				<figure>
					<artwork>
<![CDATA[	
Content-Type: application/my-media-type+json;
              profile=http://example.com/my-hyper-schema
]]>
					</artwork>
				</figure>
				
				or if the content is being transferred by a protocol (such as HTTP) that
				provides headers, a Link header can be used:
				
				<figure>
					<artwork>
<![CDATA[
Link: <http://example.com/my-hyper-schema>; rel="describedby"
]]>
					</artwork>
				</figure>
				
				Instances MAY specify multiple schemas, to indicate all the schemas that 
				are applicable to the data, and the data SHOULD be valid by all the schemas. 
				The instance data MAY have multiple schemas 
				that it is described by (the instance data SHOULD be valid for those schemas). 
				Or if the document is a collection of instances, the collection MAY contain 
				instances from different schemas. The mechanism for referencing a schema is 
				determined by the media type of the instance (if it provides a method for 
				referencing schemas).
			</t>
			
			<section title="Self-Descriptive Schema">
				<t>
					JSON Schemas can themselves be described using JSON Schemas. 
					A self-describing JSON Schema for the core JSON Schema can
					be found at <eref target="http://json-schema.org/schema">http://json-schema.org/schema</eref> for the latest version or 
					<eref target="http://json-schema.org/draft-04/schema">http://json-schema.org/draft-04/schema</eref> for the draft-04 version. The hyper schema 
					self-description can be found at <eref target="http://json-schema.org/hyper-schema">http://json-schema.org/hyper-schema</eref> 
					or <eref target="http://json-schema.org/draft-04/hyper-schema">http://json-schema.org/draft-04/hyper-schema</eref>. All schemas
					used within a protocol with a media type specified SHOULD include a MIME parameter that refers to the self-descriptive
					hyper schema or another schema that extends this hyper schema:
					
					<figure>
						<artwork>
<![CDATA[	
Content-Type: application/json; 
              profile=http://json-schema.org/draft-04/hyper-schema
]]>
						</artwork>
					</figure>
				</t>
			</section>
		</section>
		
		<section title="Core Schema Definition">
			<t>
				A JSON Schema is a JSON object that defines various attributes 
				(including usage and valid values) of a JSON value. JSON
				Schema has recursive capabilities; there are a number of elements
				in the structure that allow for nested JSON Schemas.
			</t>
			
			<figure>
				<preamble>An example JSON Schema could look like:</preamble>
				<artwork>
<![CDATA[
{
	"description": "A person",
	"type": "object",

	"properties": {
		"name": {
			"type": "string"
		},
		"age": {
			"type": "number",
			"divisibleBy": 1,
			"minimum": 0,
			"maximum": 125
		}
	}
}
]]>
				</artwork>
			</figure>
			
			<t>
				A JSON Schema object MAY have any of the following optional properties:
			</t>
			
			<!-- TODO: Break attributes up into type sections -->
			<!-- TODO: Add examples for (almost) every attribute -->
			
			<section title="type" anchor="type">
				<t>
					This attribute defines what the primitive type or the schema of the instance MUST be in order to validate. 
					This attribute can take one of two forms:

					<list style="hanging">
						<t hangText="Simple Types">
							A string indicating a primitive or simple type. The string MUST be one of the following values:

							<list style="hanging">
								<t hangText="object">Instance MUST be an object.</t>
								<t hangText="array">Instance MUST be an array.</t>
								<t hangText="string">Instance MUST be a string.</t>
								<t hangText="number">Instance MUST be a number, including floating point numbers.</t>
								<t hangText="boolean">Instance MUST be the JSON literal "true" or "false".</t>
								<t hangText="null">Instance MUST be the JSON literal "null". Note that without this type, null values are not allowed.</t>
								<t hangText="any">Instance MAY be of any type, including null.</t>
							</list>
						</t>
						
						<t hangText="Union Types">
							An array of one or more simple or schema types.
							The instance value is valid if it is of the same type as one of the simple types, or valid by one of the schemas, in the array. 
						</t>
					</list>
					
					If this attribute is not specified, then all value types are accepted. 
				</t>
				
				<figure>
					<preamble>For example, a schema that defines if an instance can be a string or a number would be:</preamble>
					<artwork>
<![CDATA[
{
	"type": ["string", "number"]
}
]]></artwork>
				</figure>
			</section>
			
			<section title="properties" anchor="properties">
				<t>
					This attribute is an object with properties that specify the schemas for the properties of the instance object.
					In this attribute's object, each property value MUST be a schema. 
					When the instance value is an object, the value of the instance's properties MUST be valid according to the schemas with the same property names specified in this attribute.
					Objects are unordered, so therefore the order of the instance properties or attribute properties MUST NOT determine validation success.
				</t>
			</section>
			
			<section title="patternProperties" anchor="patternProperties">
				<t>
					This attribute is an object that defines the schema for a set of property names of an object instance. 
					The name of each property of this attribute's object is a regular expression pattern in the ECMA 262/Perl 5 format, while the value is a schema. 
					If the pattern matches the name of a property on the instance object, the value of the instance's property MUST be valid against the pattern name's schema value.
				</t>
			</section>
			
			<section title="additionalProperties" anchor="additionalProperties">
				<t>This attribute specifies how any instance property that is not explicitly defined by either the <xref target="properties">"properties"</xref> or <xref target="patternProperties">"patternProperties"</xref> attributes (hereafter referred to as "additional properties") is handled. If specified, the value MUST be a schema or a boolean.</t> 
				<t>If a schema is provided, then all additional properties MUST be valid according to the schema.</t>
				<t>If false is provided, then no additional properties are allowed.</t>
				<t>The default value is an empty schema, which allows any value for additional properties.</t>
			</section>
			
			<section title="items" anchor="items">
				<t>This attribute provides the allowed items in an array instance. If specified, this attribute MUST be a schema or an array of schemas.</t>
				<t>When this attribute value is a schema and the instance value is an array, then all the items in the array MUST be valid according to the schema.</t>
				<t>When this attribute value is an array of schemas and the instance value is an array, each position in the instance array MUST be valid according to the schema in the corresponding position for this array. This called tuple typing. When tuple typing is used, additional items are allowed, disallowed, or constrained by the <xref target="additionalItems">"additionalItems"</xref> attribute the same way as <xref target="additionalProperties">"additionalProperties"</xref> for objects is.</t>
			</section>
			
			<section title="additionalItems" anchor="additionalItems">
				<t>This attribute specifies how any item in the array instance that is not explicitly defined by <xref target="items">"items"</xref> (hereafter referred to as "additional items") is handled. If specified, the value MUST be a schema or a boolean.</t>
				<t>If a schema is provided:
					<list>
						<t>If the <xref target="items">"items"</xref> attribute is unspecified, then all items in the array instance must be valid against this schema.</t>
						<t>If the <xref target="items">"items"</xref> attribute is a schema, then this attribute is ignored.</t>
						<t>If the <xref target="items">"items"</xref> attribute is an array (during tuple typing), then any additional items MUST be valid against this schema.</t>
					</list>
				</t>
				<t>If false is provided, then any additional items in the array are not allowed.</t>
				<t>The default value is an empty schema, which allows any value for additional items.</t>
			</section>
			
			<section title="required" anchor="required">
				<t>This attribute is an array of strings that defines all the property names that must exist on the object instance.</t>
			</section>
			
			<section title="dependencies" anchor="dependencies">
				<t>This attribute is an object that specifies the requirements of a property on an object instance. If an object instance has a property with the same name as a property in this attribute's object, then the instance must be valid against the attribute's property value (hereafter referred to as the "dependency value").</t>
				<t>
					The dependency value can take one of two forms:
					
					<list style="hanging">
						<t hangText="Simple Dependency">
							If the dependency value is a string, then the instance object MUST have a property with the same name as the dependency value.
							If the dependency value is an array of strings, then the instance object MUST have a property with the same name as each string in the dependency value's array.
						</t>
						<t hangText="Schema Dependency">
							If the dependency value is a schema, then the instance object MUST be valid against the schema.
						</t>
					</list>
				</t>
			</section>
			
			<section title="minimum" anchor="minimum">
				<t>This attribute defines the minimum value of the instance property when the type of the instance value is a number.</t>
			</section>
			
			<section title="maximum" anchor="maximum">
				<t>This attribute defines the maximum value of the instance property when the type of the instance value is a number.</t>
			</section>
			
			<section title="exclusiveMinimum" anchor="exclusiveMinimum">
				<t>This attribute indicates if the value of the instance (if the instance is a number) can not equal the number defined by the "minimum" attribute. This is false by default, meaning the instance value can be greater then or equal to the minimum value.</t>
			</section>
			
			<section title="exclusiveMaximum" anchor="exclusiveMaximum">
				<t>This attribute indicates if the value of the instance (if the instance is a number) can not equal the number defined by the "maximum" attribute. This is false by default, meaning the instance value can be less then or equal to the maximum value.</t>
			</section>
			
			<section title="minItems" anchor="minItems">
				<t>This attribute defines the minimum number of values in an array when the array is the instance value.</t>
			</section>
			
			<section title="maxItems" anchor="maxItems">
				<t>This attribute defines the maximum number of values in an array when the array is the instance value.</t>
			</section>
			
			<section title="minProperties" anchor="minProperties">
				<t>This attribute defines the minimum number of properties required on an object instance.</t>
			</section>
			
			<section title="maxProperties" anchor="maxProperties">
				<t>This attribute defines the maximum number of properties the object instance can have.</t>
			</section>
			
			<section title="uniqueItems" anchor="uniqueItems">
				<t>This attribute indicates that all items in an array instance MUST be unique (contains no two identical values).</t>
				<t>
					Two instance are consider equal if they are both of the same type and:
					
					<list>
						<t>are null; or</t>
						<t>are booleans/numbers/strings and have the same value; or</t>
						<t>are arrays, contains the same number of items, and each item in the array is equal to the item at the corresponding index in the other array; or</t>
						<t>are objects, contains the same property names, and each property in the object is equal to the corresponding property in the other object.</t>
					</list>
				</t>
			</section>
			
			<section title="pattern" anchor="pattern">
				<t>When the instance value is a string, this provides a regular expression that a string instance MUST match in order to be valid. Regular expressions SHOULD follow the regular expression specification from ECMA 262/Perl 5</t>
			</section>
			
			<section title="minLength" anchor="minLength">
				<t>When the instance value is a string, this defines the minimum length of the string.</t>
			</section>
			
			<section title="maxLength" anchor="maxLength">
				<t>When the instance value is a string, this defines the maximum length of the string.</t>
			</section>
			
			<section title="enum" anchor="enum">
				<t>This provides an enumeration of all possible values that are valid for the instance property. This MUST be an array, and each item in the array represents a possible value for the instance value. If this attribute is defined, the instance value MUST be one of the values in the array in order for the schema to be valid. Comparison of enum values uses the same algorithm as defined in <xref target="uniqueItems">"uniqueItems"</xref>.</t>
			</section>
			
			<section title="default" anchor="default">
				<t>This attribute defines the default value of the instance when the instance is undefined.</t>
			</section>
			
			<section title="title" anchor="title">
				<t>This attribute is a string that provides a short description of the instance property.</t>
			</section>
			
			<section title="description" anchor="description">
				<t>This attribute is a string that provides a full description of the of purpose the instance property.</t>
			</section>
			
			<section title="divisibleBy" anchor="divisibleBy">
				<t>This attribute defines what value the number instance must be divisible by with no remainder (the result of the division must be an integer.) The value of this attribute SHOULD NOT be 0.</t>
			</section>
			
			<section title="disallow" anchor="disallow">
				<t>This attribute takes the same values as the "type" attribute, however if the instance matches the type or if this value is an array and the instance matches any type or schema in the array, then this instance is not valid.</t>
			</section>
			
			<section title="extends" anchor="extends">
				<t>The value of this property MUST be another schema which will provide a base schema which the current schema will inherit from. The inheritance rules are such that any instance that is valid according to the current schema MUST be valid according to the referenced schema. This MAY also be an array, in which case, the instance MUST be valid for all the schemas in the array. A schema that extends another schema MAY define additional attributes, constrain existing attributes, or add other constraints.</t>
				<t>
					Conceptually, the behavior of extends can be seen as validating an
					instance against all constraints in the extending schema as well as
					the extended schema(s). More optimized implementations that merge
					schemas are possible, but are not required. Some examples of using "extends":
					
					<figure>
						<artwork>
<![CDATA[
{
	"description": "An adult",
	"properties": {
		"age": {
			"minimum": 21
		}
	},
	"extends": {"$ref": "person"}
}
]]>
						</artwork>
					</figure>
					
					<figure>
						<artwork>
<![CDATA[
{
	"description": "Extended schema",
	"properties": {
		"deprecated": {
			"type": "boolean"
		}
	},
	"extends": {"$ref": "http://json-schema.org/draft-04/schema"}
}
]]>
						</artwork>
					</figure>
				</t>
			</section>
			
			<section title="id" anchor="id">
				<t>
					This attribute defines the current URI of this schema (this attribute is
					effectively a "self" link). This URI MAY be relative or absolute. If
					the URI is relative it is resolved against the current URI of the parent
					schema it is contained in. If this schema is not contained in any
					parent schema, the current URI of the parent schema is held to be the
					URI under which this schema was addressed. If id is missing, the current URI of a schema is
					defined to be that of the parent schema. The current URI of the schema
					is also used to construct relative references such as for $ref.
				</t>
			</section>
			
			<section title="$ref" anchor="ref">
				<t>
					This attribute defines a URI of a schema that contains the full representation of this schema. 
					When a validator encounters this attribute, it SHOULD replace the current schema with the schema referenced by the value's URI (if known and available) and re-validate the instance. 
					This URI MAY be relative or absolute, and relative URIs SHOULD be resolved against the URI of the current schema.
				</t>
			</section>
			
			<section title="$schema" anchor="schema">
				<t>
					This attribute defines a URI of a JSON Schema that is the schema of the current schema. 
					When this attribute is defined, a validator SHOULD use the schema referenced by the value's URI (if known and available) when resolving <xref target="hyper-schema">Hyper Schema</xref><xref target="links">links</xref>.
				</t>
				
				<t>
					A validator MAY use this attribute's value to determine which version of JSON Schema the current schema is written in, and provide the appropriate validation features and behavior. 
					Therefore, it is RECOMMENDED that all schema authors include this attribute in their schemas to prevent conflicts with future JSON Schema specification changes.
				</t>
			</section>
		</section>
		
		<section title="Hyper Schema" anchor="hyper-schema">
			<t>
				The following attributes are specified in addition to those
				attributes that already provided by the core schema with the specific
				purpose of informing user agents of relations between resources based
				on JSON data. Just as with JSON
				schema attributes, all the attributes in hyper schemas are optional.
				Therefore, an empty object is a valid (non-informative) schema, and
				essentially describes plain JSON (no constraints on the structures).
				Addition of attributes provides additive information for user agents.
			</t>
			
			<section title="links" anchor="links">
				<t>
					The value of the links property MUST be an array, where each item 
					in the array is a link description object which describes the link
					relations of the instances.
				</t>
				
				<!-- TODO: Needs more clarification and examples -->
				
				<section title="Link Description Object">
					<t>
						A link description object is used to describe link relations. In 
						the context of a schema, it defines the link relations of the 
						instances of the schema, and can be parameterized by the instance
						values. The link description format can be used without JSON Schema, 
						and use of this format can
						be declared by referencing the normative link description
						schema as the the schema for the data structure that uses the 
						links. The URI of the normative link description schema is: 
						<eref target="http://json-schema.org/links">http://json-schema.org/links</eref> (latest version) or
						<eref target="http://json-schema.org/draft-04/links">http://json-schema.org/draft-04/links</eref> (draft-04 version).
					</t>
					
					<section title="href" anchor="href">
						<t>
							The value of the "href" link description property
							indicates the target URI of the related resource. The value
							of the instance property SHOULD be resolved as a URI-Reference per <xref target="RFC3986">RFC 3986</xref>
							and MAY be a relative URI. The base URI to be used for relative resolution
							SHOULD be the URI used to retrieve the instance object (not the schema)
							when used within a schema. Also, when links are used within a schema, the URI 
							SHOULD be parametrized by the property values of the instance 
							object, if property values exist for the corresponding variables
							in the template (otherwise they MAY be provided from alternate sources, like user input).
						</t>
						
						<t>
							Instance property values SHOULD be substituted into the URIs where
							matching braces ('{', '}') are found surrounding zero or more characters,
							creating an expanded URI. Instance property value substitutions are resolved
							by using the text between the braces to denote the property name
							from the instance to get the value to substitute. 
							
							<figure>
								<preamble>For example, if an href value is defined:</preamble>
								<artwork>
<![CDATA[
http://somesite.com/{id}
]]>
								</artwork>
								<postamble>Then it would be resolved by replace the value of the "id" property value from the instance object.</postamble>
							</figure>
							
							<figure>
								<preamble>If the value of the "id" property was "45", the expanded URI would be:</preamble>
								<artwork>
<![CDATA[
http://somesite.com/45
]]>
								</artwork>
							</figure>
							
							If matching braces are found with the string "@" (no quotes) between the braces, then the 
							actual instance value SHOULD be used to replace the braces, rather than a property value.
							This should only be used in situations where the instance is a scalar (string, 
							boolean, or number), and not for objects or arrays.
						</t>
					</section>
					
					<section title="rel">
						<t>
							The value of the "rel" property indicates the name of the 
							relation to the target resource. The relation to the target SHOULD be interpreted as specifically from the instance object that the schema (or sub-schema) applies to, not just the top level resource that contains the object within its hierarchy. If a resource JSON representation contains a sub object with a property interpreted as a link, that sub-object holds the relation with the target. A relation to target from the top level resource MUST be indicated with the schema describing the top level JSON representation.
						</t>
						
						<t>
							Relationship definitions SHOULD NOT be media type dependent, and users are encouraged to utilize existing accepted relation definitions, including those in existing relation registries (see <xref target="RFC4287">RFC 4287</xref>). However, we define these relations here for clarity of normative interpretation within the context of JSON hyper schema defined relations:
							
							<list style="hanging">
								<t hangText="self">
									If the relation value is "self", when this property is encountered in
									the instance object, the object represents a resource and the instance object is
									treated as a full representation of the target resource identified by
									the specified URI.
								</t>
								
								<t hangText="full">
									This indicates that the target of the link is the full representation for the instance object. The object that contains this link possibly may not be the full representation.
								</t>
								
								<t hangText="describedby">
									This indicates the target of the link is the schema for the instance object. This MAY be used to specifically denote the schemas of objects within a JSON object hierarchy, facilitating polymorphic type data structures.
								</t>
								
								<t hangText="root">
									This relation indicates that the target of the link
									SHOULD be treated as the root or the body of the representation for the
									purposes of user agent interaction or fragment resolution. All other
									properties of the instance objects can be regarded as meta-data
									descriptions for the data.
								</t>
							</list>
						</t>
						
						<t>
							The following relations are applicable for schemas (the schema as the "from" resource in the relation):

							<list style="hanging">
								<t hangText="instances">This indicates the target resource that represents collection of instances of a schema.</t>
								<t hangText="create">This indicates a target to use for creating new instances of a schema. This link definition SHOULD be a submission link with a non-safe method (like POST).</t>
							</list>
						</t>
						
						<t>
							<figure>
								<preamble>For example, if a schema is defined:</preamble>
								<artwork>
<![CDATA[
{
	"links": [{
		"rel": "self",
		"href": "{id}"
	}, {
		"rel": "up",
		"href": "{upId}"
	}, {
		"rel": "children",
		"href": "?upId={id}"
	}]
}
]]>
								</artwork>
							</figure>
							
							<figure>
								<preamble>And if a collection of instance resource's JSON representation was retrieved:</preamble>
								<artwork>
<![CDATA[
GET /Resource/

[{
	"id": "thing",
	"upId": "parent"
}, {
	"id": "thing2",
	"upId": "parent"
}]
]]>
								</artwork>
							</figure>

							This would indicate that for the first item in the collection, its own
							(self) URI would resolve to "/Resource/thing" and the first item's "up"
							relation SHOULD be resolved to the resource at "/Resource/parent".
							The "children" collection would be located at "/Resource/?upId=thing".
						</t>
					</section>
					
					<section title="template">
						<t>This property value is a string that defines the templating language used in the <xref target="href">"href"</xref> attribute. If no templating language is defined, then the default <xref target="href">Link Description Object templating langauge</xref> is used.</t>
					</section>
					
					<section title="targetSchema">
						<t>This property value is a schema that defines the expected structure of the JSON representation of the target of the link.</t>
					</section>
					
					<section title="Submission Link Properties">
						<t>
							The following properties also apply to link definition objects, and 
							provide functionality analogous to HTML forms, in providing a 
							means for submitting extra (often user supplied) information to send to a server.
						</t>
						
						<section title="method">
							<t>
								This attribute defines which method can be used to access the target resource. 
								In an HTTP environment, this would be "GET" or "POST" (other HTTP methods 
								such as "PUT" and "DELETE" have semantics that are clearly implied by 
								accessed resources, and do not need to be defined here). 
								This defaults to "GET".
							</t>
						</section>
						
						<section title="enctype">
							<t>
								If present, this property indicates a query media type format that the server
								supports for querying or posting to the collection of instances at the target 
								resource. The query can be 
								suffixed to the target URI to query the collection with
								property-based constraints on the resources that SHOULD be returned from
								the server or used to post data to the resource (depending on the method).
								
								<figure>
									<preamble>For example, with the following schema:</preamble>
									<artwork>
<![CDATA[
{
	"links": [{
		"enctype": "application/x-www-form-urlencoded",
		"method": "GET",
		"href": "/Product/",
		"properties": {
			"name": {
				"description": "name of the product"
			}
		}
	}]
}
]]>
									</artwork>
									<postamble>This indicates that the client can query the server for instances that have a specific name.</postamble>
								</figure>
								
								<figure>
									<preamble>For example:</preamble>
									<artwork>
<![CDATA[
/Product/?name=Slinky
]]>
									</artwork>
								</figure>

								If no enctype or method is specified, only the single URI specified by 
								the href property is defined. If the method is POST, "application/json" is 
								the default media type.
							</t>
						</section>
						
						<section title="schema">
							<t>
								This attribute contains a schema which defines the acceptable structure of the submitted
								request (for a GET request, this schema would define the properties for the query string 
								and for a POST request, this would define the body).
							</t>
						</section>
					</section>
				</section>
			</section>
			
			<section title="fragmentResolution">
				<t>
					This property indicates the fragment resolution protocol to use for
					resolving fragment identifiers in URIs within the instance
					representations. This applies to the instance object URIs and all
					children of the instance object's URIs. The default fragment resolution
					protocol is "json-pointer", which is defined below. Other fragment
					resolution protocols MAY be used, but are not defined in this document.
				</t>
				
				<t>
					The fragment identifier is based on <xref target="RFC3986">RFC 3986, Sec 5</xref>, and defines the
					mechanism for resolving references to entities within a document.
				</t>
				
				<section title="json-pointer fragment resolution">
					<t>The "json-pointer" fragment resolution protocol uses a <xref target="json-pointer">JSON Pointer</xref> to resolve fragment identifiers in URIs within instance representations.</t>
				</section>
			</section>
			
			<!-- TODO: Remove this? -->
			
			<section title="readonly">
				<t>This attribute indicates that the instance value SHOULD NOT be changed. Attempts by a user agent to modify the value of this property are expected to be rejected by a server.</t>
			</section>
			
			<section title="contentEncoding">
				<t>If the instance property value is a string, this attribute defines that the string SHOULD be interpreted as binary data and decoded using the encoding named by this schema property. <xref target="RFC2045">RFC 2045, Sec 6.1</xref> lists the possible values for this property.</t>
			</section>
			
			<section title="pathStart">
				<t>
					This attribute is a URI that defines what the instance's URI MUST start with in order to validate. 
					The value of the "pathStart" attribute MUST be resolved as per <xref target="RFC3986">RFC 3986, Sec 5</xref>, 
					and is relative to the instance's URI.
				</t>
				
				<t>
					When multiple schemas have been referenced for an instance, the user agent 
					can determine if this schema is applicable for a particular instance by 
					determining if the URI of the instance begins with the the value of the "pathStart"
					attribute. If the URI of the instance does not start with this URI, 
					or if another schema specifies a starting URI that is longer and also matches the 
					instance, this schema SHOULD NOT be applied to the instance. Any schema 
					that does not have a pathStart attribute SHOULD be considered applicable 
					to all the instances for which it is referenced.
				</t>
			</section>
			
			<section title="mediaType">
				<t>This attribute defines the media type of the instance representations that this schema is defining.</t>
			</section>
		</section>
		
		<section title="Security Considerations">
			<t>
				This specification is a sub-type of the JSON format, and 
				consequently the security considerations are generally the same as <xref target="RFC4627">RFC 4627</xref>. 
				However, an additional issue is that when link relation of "self"
				is used to denote a full representation of an object, the user agent 
				SHOULD NOT consider the representation to be the authoritative representation
				of the resource denoted by the target URI if the target URI is not
				equivalent to or a sub-path of the the URI used to request the resource 
				representation which contains the target URI with the "self" link.
				
				<figure>
					<preamble>For example, if a hyper schema was defined:</preamble>
					<artwork>
<![CDATA[
{
	"links": [{
		"rel": "self",
		"href": "{id}"
	}]
}
]]>
					</artwork>
				</figure>
				
				<figure>
					<preamble>And a resource was requested from somesite.com:</preamble>
					<artwork>
<![CDATA[
GET /foo/
]]>
					</artwork>
				</figure>

				<figure>
					<preamble>With a response of:</preamble>
					<artwork>
<![CDATA[
Content-Type: application/json; profile=/schema-for-this-data

[{
	"id": "bar",
	"name": "This representation can be safely treated \
		as authoritative "
}, {
	"id": "/baz",
	"name": "This representation should not be treated as \
		authoritative the user agent should make request the resource\
		from '/baz' to ensure it has the authoritative representation"
}, {
	"id": "http://othersite.com/something",
	"name": "This representation\
		should also not be treated as authoritative and the target\
		resource representation should be retrieved for the\
		authoritative representation"
}]
]]>
					</artwork>
				</figure>
			</t>
		</section>
		
		<section title="IANA Considerations">
			<t>The proposed MIME media type for JSON Schema is "application/schema+json".</t>
			<t>Type name: application</t>
			<t>Subtype name: schema+json</t>
			<t>Required parameters: profile</t>
			<t>
				The value of the profile parameter SHOULD be a URI (relative or absolute) that 
				refers to the schema used to define the structure of this structure (the 
				meta-schema). Normally the value would be http://json-schema.org/draft-04/hyper-schema,
				but it is allowable to use other schemas that extend the hyper schema's meta-
				schema.
			</t>
			<t>Optional parameters: pretty</t>
			<t>The value of the pretty parameter MAY be true or false to indicate if additional whitespace has been included to make the JSON representation easier to read.</t>
			
			<section title="Registry of Link Relations">
				<t>
					This registry is maintained by IANA per <xref target="RFC4287">RFC 4287</xref> and this specification adds
					four values: "full", "create", "instances", "root".  New
					assignments are subject to IESG Approval, as outlined in <xref target="RFC5226">RFC 5226</xref>.
					Requests should be made by email to IANA, which will then forward the
					request to the IESG, requesting approval.
				</t>
			</section>
		</section>
	</middle>
	
	<back>
		<!-- References Section -->
		<references title="Normative References">
			&rfc2045;
			&rfc2119;
			&rfc3339;
			&rfc3986;
			&rfc4287;
			<reference anchor="json-pointer" target="http://tools.ietf.org/html/draft-pbryan-zyp-json-pointer-02">
				<front>
					<title>JSON Pointer</title>
					<author initials="P." surname="Bryan">
						<organization>ForgeRock US, Inc.</organization>
					</author>
					<author initials="K." surname="Zyp">
						<organization>SitePen (USA)</organization>
					</author>
					<date year="2011" month="October" />
				</front>
			</reference>
		</references>
		<references title="Informative References">
			&rfc2616;
			&rfc4627;
			&rfc5226;
			&iddiscovery;
			&uritemplate;
			&linkheader;
			&html401;
			&css21;
		</references>

		<section title="Change Log">
			<t>
				<list style="hanging">
					<t hangText="draft-04">
						<list style="symbols">
							<t>Changed "required" attribute to an array of strings.</t>
							<t>Removed "format" attribute.</t>
							<t>Added "minProperties" and "maxProperties" attributes.</t>
							<t>Replaced "slash-delimited" fragment resolution with "json-pointer".</t>
							<t>Added "template" LDO attribute.</t>
							<t>Removed irrelevant "Open Issues" section.</t>
							<t>Merged Conventions and Terminology sections.</t>
							<t>Defined terms used in specification.</t>
							<t>Removed "integer" type in favor of {"type":"number", "divisibleBy":1}.</t>
							<t>Restricted "type" to only the core JSON types.</t>
							<t>Improved wording of many sections.</t>
						</list>
					</t>
				
					<t hangText="draft-03">
						<list style="symbols">
							<t>Added example and verbiage to "extends" attribute.</t>
							<t>Defined slash-delimited to use a leading slash.</t>
							<t>Made "root" a relation instead of an attribute.</t>
							<t>Removed address values, and MIME media type from format to reduce confusion (mediaType already exists, so it can be used for MIME types).</t>
							<t>Added more explanation of nullability.</t>
							<t>Removed "alternate" attribute.</t>
							<t>Upper cased many normative usages of must, may, and should.</t>
							<t>Replaced the link submission "properties" attribute to "schema" attribute.</t>
							<t>Replaced "optional" attribute with "required" attribute.</t>
							<t>Replaced "maximumCanEqual" attribute with "exclusiveMaximum" attribute.</t>
							<t>Replaced "minimumCanEqual" attribute with "exclusiveMinimum" attribute.</t>
							<t>Replaced "requires" attribute with "dependencies" attribute.</t>
							<t>Moved "contentEncoding" attribute to hyper schema.</t>
							<t>Added "additionalItems" attribute.</t>
							<t>Added "id" attribute.</t>
							<t>Switched self-referencing variable substitution from "-this" to "@" to align with reserved characters in URI template.</t>
							<t>Added "patternProperties" attribute.</t>
							<t>Schema URIs are now namespace versioned.</t>
							<t>Added "$ref" and "$schema" attributes.</t>
						</list>
					</t>
					
					<t hangText="draft-02">
						<list style="symbols">
							<t>Replaced "maxDecimal" attribute with "divisibleBy" attribute.</t>
							<t>Added slash-delimited fragment resolution protocol and made it the default.</t>
							<t>Added language about using links outside of schemas by referencing its normative URI.</t>
							<t>Added "uniqueItems" attribute.</t>
							<t>Added "targetSchema" attribute to link description object.</t>
						</list>
					</t>
					
					<t hangText="draft-01">
						<list style="symbols">
							<t>Fixed category and updates from template.</t>
						</list>
					</t>
					
					<t hangText="draft-00">
						<list style="symbols">
							<t>Initial draft.</t>
						</list>
					</t>
				</list>
			</t>
		</section>
	</back>
</rfc>
/** 
 * JSON Schema link handler
 * Copyright (c) 2007 Kris Zyp SitePen (www.sitepen.com)
 * Licensed under the MIT (MIT-LICENSE.txt) license.
 */
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define([], function () {
            return factory();
        });
    } else if (typeof module === 'object' && module.exports) {
        // Node. Does not work with strict CommonJS, but
        // only CommonJS-like environments that support module.exports,
        // like Node.
        module.exports = factory();
    } else {
        // Browser globals
        root.jsonSchemaLinks = factory();
    }
}(this, function () {// setup primitive classes to be JSON Schema types
var exports = {};
exports.cacheLinks = true;
exports.getLink = function(relation, instance, schema){
	// gets the URI of the link for the given relation based on the instance and schema
	// for example:
	// getLink(
	// 		"brother", 
	// 		{"brother_id":33}, 
	// 		{links:[{rel:"brother", href:"Brother/{brother_id}"}]}) ->
	//	"Brother/33"
	var links = schema.__linkTemplates; 
	if(!links){
		links = {};
		var schemaLinks = schema.links;
		if(schemaLinks && schemaLinks instanceof Array){
			schemaLinks.forEach(function(link){
	/*			// TODO: allow for multiple same-name relations
				if(links[link.rel]){
					if(!(links[link.rel] instanceof Array)){
						links[link.rel] = [links[link.rel]];
					}
				}*/
				links[link.rel] = link.href;
			});
		}
		if(exports.cacheLinks){
			schema.__linkTemplates = links;
		}
	}
	var linkTemplate = links[relation];
	return linkTemplate && exports.substitute(linkTemplate, instance);
};

exports.substitute = function(linkTemplate, instance){
	return linkTemplate.replace(/\{([^\}]*)\}/g, function(t, property){
			var value = instance[decodeURIComponent(property)];
			if(value instanceof Array){
				// the value is an array, it should produce a URI like /Table/(4,5,8) and store.get() should handle that as an array of values
				return '(' + value.join(',') + ')';
			}
			return value;
		});
};
return exports;
}));/**
 * JSONSchema Validator - Validates JavaScript objects using JSON Schemas
 *	(http://www.json.com/json-schema-proposal/)
 *
 * Copyright (c) 2007 Kris Zyp SitePen (www.sitepen.com)
 * Licensed under the MIT (MIT-LICENSE.txt) license.
To use the validator call the validate function with an instance object and an optional schema object.
If a schema is provided, it will be used to validate. If the instance object refers to a schema (self-validating),
that schema will be used to validate and the schema parameter is not necessary (if both exist,
both validations will occur).
The validate method will return an array of validation errors. If there are no errors, then an
empty list will be returned. A validation error will have two properties:
"property" which indicates which property had the error
"message" which indicates what the error was
 */
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define([], function () {
            return factory();
        });
    } else if (typeof module === 'object' && module.exports) {
        // Node. Does not work with strict CommonJS, but
        // only CommonJS-like environments that support module.exports,
        // like Node.
        module.exports = factory();
    } else {
        // Browser globals
        root.jsonSchema = factory();
    }
}(this, function () {// setup primitive classes to be JSON Schema types
var exports = validate
exports.Integer = {type:"integer"};
var primitiveConstructors = {
	String: String,
	Boolean: Boolean,
	Number: Number,
	Object: Object,
	Array: Array,
	Date: Date
}
exports.validate = validate;
function validate(/*Any*/instance,/*Object*/schema) {
		// Summary:
		//  	To use the validator call JSONSchema.validate with an instance object and an optional schema object.
		// 		If a schema is provided, it will be used to validate. If the instance object refers to a schema (self-validating),
		// 		that schema will be used to validate and the schema parameter is not necessary (if both exist,
		// 		both validations will occur).
		// 		The validate method will return an object with two properties:
		// 			valid: A boolean indicating if the instance is valid by the schema
		// 			errors: An array of validation errors. If there are no errors, then an
		// 					empty list will be returned. A validation error will have two properties:
		// 						property: which indicates which property had the error
		// 						message: which indicates what the error was
		//
		return validate(instance, schema, {changing: false});//, coerce: false, existingOnly: false});
	};
exports.checkPropertyChange = function(/*Any*/value,/*Object*/schema, /*String*/property) {
		// Summary:
		// 		The checkPropertyChange method will check to see if an value can legally be in property with the given schema
		// 		This is slightly different than the validate method in that it will fail if the schema is readonly and it will
		// 		not check for self-validation, it is assumed that the passed in value is already internally valid.
		// 		The checkPropertyChange method will return the same object type as validate, see JSONSchema.validate for
		// 		information.
		//
		return validate(value, schema, {changing: property || "property"});
	};
var validate = exports._validate = function(/*Any*/instance,/*Object*/schema,/*Object*/options) {

	if (!options) options = {};
	var _changing = options.changing;

	function getType(schema){
		return schema.type || (primitiveConstructors[schema.name] == schema && schema.name.toLowerCase());
	}
	var errors = [];
	// validate a value against a property definition
	function checkProp(value, schema, path,i){

		var l;
		path += path ? typeof i == 'number' ? '[' + i + ']' : typeof i == 'undefined' ? '' : '.' + i : i;
		function addError(message){
			errors.push({property:path,message:message});
		}

		if((typeof schema != 'object' || schema instanceof Array) && (path || typeof schema != 'function') && !(schema && getType(schema))){
			if(typeof schema == 'function'){
				if(!(value instanceof schema)){
					addError("is not an instance of the class/constructor " + schema.name);
				}
			}else if(schema){
				addError("Invalid schema/property definition " + schema);
			}
			return null;
		}
		if(_changing && schema.readonly){
			addError("is a readonly field, it can not be changed");
		}
		if(schema['extends']){ // if it extends another schema, it must pass that schema as well
			checkProp(value,schema['extends'],path,i);
		}
		// validate a value against a type definition
		function checkType(type,value){
			if(type){
				if(typeof type == 'string' && type != 'any' &&
						(type == 'null' ? value !== null : typeof value != type) &&
						!(value instanceof Array && type == 'array') &&
						!(value instanceof Date && type == 'date') &&
						!(type == 'integer' && value%1===0)){
					return [{property:path,message:(typeof value) + " value found, but a " + type + " is required"}];
				}
				if(type instanceof Array){
					var unionErrors=[];
					for(var j = 0; j < type.length; j++){ // a union type
						if(!(unionErrors=checkType(type[j],value)).length){
							break;
						}
					}
					if(unionErrors.length){
						return unionErrors;
					}
				}else if(typeof type == 'object'){
					var priorErrors = errors;
					errors = [];
					checkProp(value,type,path);
					var theseErrors = errors;
					errors = priorErrors;
					return theseErrors;
				}
			}
			return [];
		}
		if(value === undefined){
			if(schema.required){
				addError("is missing and it is required");
			}
		}else{
			errors = errors.concat(checkType(getType(schema),value));
			if(schema.disallow && !checkType(schema.disallow,value).length){
				addError(" disallowed value was matched");
			}
			if(value !== null){
				if(value instanceof Array){
					if(schema.items){
						var itemsIsArray = schema.items instanceof Array;
						var propDef = schema.items;
						for (i = 0, l = value.length; i < l; i += 1) {
							if (itemsIsArray)
								propDef = schema.items[i];
							if (options.coerce)
								value[i] = options.coerce(value[i], propDef);
							errors.concat(checkProp(value[i],propDef,path,i));
						}
					}
					if(schema.minItems && value.length < schema.minItems){
						addError("There must be a minimum of " + schema.minItems + " in the array");
					}
					if(schema.maxItems && value.length > schema.maxItems){
						addError("There must be a maximum of " + schema.maxItems + " in the array");
					}
				}else if(schema.properties || schema.additionalProperties){
					errors.concat(checkObj(value, schema.properties, path, schema.additionalProperties));
				}
				if(schema.pattern && typeof value == 'string' && !value.match(schema.pattern)){
					addError("does not match the regex pattern " + schema.pattern);
				}
				if(schema.maxLength && typeof value == 'string' && value.length > schema.maxLength){
					addError("may only be " + schema.maxLength + " characters long");
				}
				if(schema.minLength && typeof value == 'string' && value.length < schema.minLength){
					addError("must be at least " + schema.minLength + " characters long");
				}
				if(typeof schema.minimum !== undefined && typeof value == typeof schema.minimum &&
						schema.minimum > value){
					addError("must have a minimum value of " + schema.minimum);
				}
				if(typeof schema.maximum !== undefined && typeof value == typeof schema.maximum &&
						schema.maximum < value){
					addError("must have a maximum value of " + schema.maximum);
				}
				if(schema['enum']){
					var enumer = schema['enum'];
					l = enumer.length;
					var found;
					for(var j = 0; j < l; j++){
						if(enumer[j]===value){
							found=1;
							break;
						}
					}
					if(!found){
						addError("does not have a value in the enumeration " + enumer.join(", "));
					}
				}
				if(typeof schema.maxDecimal == 'number' &&
					(value.toString().match(new RegExp("\\.[0-9]{" + (schema.maxDecimal + 1) + ",}")))){
					addError("may only have " + schema.maxDecimal + " digits of decimal places");
				}
			}
		}
		return null;
	}
	// validate an object against a schema
	function checkObj(instance,objTypeDef,path,additionalProp){

		if(typeof objTypeDef =='object'){
			if(typeof instance != 'object' || instance instanceof Array){
				errors.push({property:path,message:"an object is required"});
			}
			
			for(var i in objTypeDef){ 
				if(objTypeDef.hasOwnProperty(i)){
					var value = instance[i];
					// skip _not_ specified properties
					if (value === undefined && options.existingOnly) continue;
					var propDef = objTypeDef[i];
					// set default
					if(value === undefined && propDef["default"]){
						value = instance[i] = propDef["default"];
					}
					if(options.coerce && i in instance){
						value = instance[i] = options.coerce(value, propDef);
					}
					checkProp(value,propDef,path,i);
				}
			}
		}
		for(i in instance){
			if(instance.hasOwnProperty(i) && !(i.charAt(0) == '_' && i.charAt(1) == '_') && objTypeDef && !objTypeDef[i] && additionalProp===false){
				if (options.filter) {
					delete instance[i];
					continue;
				} else {
					errors.push({property:path,message:(typeof value) + "The property " + i +
						" is not defined in the schema and the schema does not allow additional properties"});
				}
			}
			var requires = objTypeDef && objTypeDef[i] && objTypeDef[i].requires;
			if(requires && !(requires in instance)){
				errors.push({property:path,message:"the presence of the property " + i + " requires that " + requires + " also be present"});
			}
			value = instance[i];
			if(additionalProp && (!(objTypeDef && typeof objTypeDef == 'object') || !(i in objTypeDef))){
				if(options.coerce){
					value = instance[i] = options.coerce(value, additionalProp);
				}
				checkProp(value,additionalProp,path,i);
			}
			if(!_changing && value && value.$schema){
				errors = errors.concat(checkProp(value,value.$schema,path,i));
			}
		}
		return errors;
	}
	if(schema){
		checkProp(instance,schema,'',_changing || '');
	}
	if(!_changing && instance && instance.$schema){
		checkProp(instance,instance.$schema,'','');
	}
	return {valid:!errors.length,errors:errors};
};
exports.mustBeValid = function(result){
	//	summary:
	//		This checks to ensure that the result is valid and will throw an appropriate error message if it is not
	// result: the result returned from checkPropertyChange or validate
	if(!result.valid){
		throw new TypeError(result.errors.map(function(error){return "for property " + error.property + ': ' + error.message;}).join(", \n"));
	}
}

return exports;
}));
{
  "name": "json-schema",
  "version": "0.2.3",
  "author": "Kris Zyp",
  "description": "JSON Schema validation and specifications",
  "maintainers":[
  	{"name": "Kris Zyp", "email": "kriszyp@gmail.com"}],
  "keywords": [
    "json",
    "schema"
  ],
  "licenses": [
     {
         "type": "AFLv2.1",
         "url": "http://trac.dojotoolkit.org/browser/dojo/trunk/LICENSE#L43"
     },
     {
         "type": "BSD",
         "url": "http://trac.dojotoolkit.org/browser/dojo/trunk/LICENSE#L13"
     }
  ],
  "repository": {
    "type":"git",
    "url":"http://github.com/kriszyp/json-schema"
  },
  "directories": { "lib": "./lib" },
  "main": "./lib/validate.js",
  "devDependencies": { "vows": "*" },
  "scripts": { "test": "echo TESTS DISABLED vows --spec test/*.js" }
}

JSON Schema is a repository for the JSON Schema specification, reference schemas and a CommonJS implementation of JSON Schema (not the only JavaScript implementation of JSON Schema, JSV is another excellent JavaScript validator).

Code is licensed under the AFL or BSD license as part of the Persevere 
project which is administered under the Dojo foundation,
and all contributions require a Dojo CLA.var assert = require('assert');
var vows = require('vows');
var path = require('path');
var fs = require('fs');

var validate = require('../lib/validate').validate;


var revision = 'draft-03';
var schemaRoot = path.join(__dirname, '..', revision);
var schemaNames = ['schema', 'hyper-schema', 'links', 'json-ref' ];
var schemas = {};

schemaNames.forEach(function(name) {
    var file = path.join(schemaRoot, name);
    schemas[name] = loadSchema(file);
});

schemaNames.forEach(function(name) {
    var s, n = name+'-nsd', f = path.join(schemaRoot, name);
    schemas[n] = loadSchema(f);
    s = schemas[n];
    delete s['$schema'];
});

function loadSchema(path) {
    var data = fs.readFileSync(path, 'utf-8');
    var schema = JSON.parse(data);
    return schema;
}

function resultIsValid() {
    return function(result) {
        assert.isObject(result);
        //assert.isBoolean(result.valid);
        assert.equal(typeof(result.valid), 'boolean');
        assert.isArray(result.errors);
        for (var i = 0; i < result.errors.length; i++) {
            assert.notEqual(result.errors[i], null, 'errors['+i+'] is null');
        }
    }
}

function assertValidates(doc, schema) {
    var context = {};

    context[': validate('+doc+', '+schema+')'] = {
        topic: validate(schemas[doc], schemas[schema]),
        'returns valid result': resultIsValid(),
        'with valid=true': function(result) { assert.equal(result.valid, true); },
        'and no errors':   function(result) {
            // XXX work-around for bug in vows: [null] chokes it
            if (result.errors[0] == null) assert.fail('(errors contains null)');
            assert.length(result.errors, 0);
        }
    };

    return context;
}

function assertSelfValidates(doc) {
    var context = {};

    context[': validate('+doc+')'] = {
        topic: validate(schemas[doc]),
        'returns valid result': resultIsValid(),
        'with valid=true': function(result) { assert.equal(result.valid, true); },
        'and no errors':   function(result) { assert.length(result.errors, 0); }
    };

    return context;
}

var suite = vows.describe('JSON Schema').addBatch({
    'Core-NSD self-validates': assertSelfValidates('schema-nsd'),
    'Core-NSD/Core-NSD': assertValidates('schema-nsd', 'schema-nsd'),
    'Core-NSD/Core': assertValidates('schema-nsd', 'schema'),

    'Core self-validates': assertSelfValidates('schema'),
    'Core/Core': assertValidates('schema', 'schema'),

    'Hyper-NSD self-validates': assertSelfValidates('hyper-schema-nsd'),
    'Hyper self-validates': assertSelfValidates('hyper-schema'),
    'Hyper/Hyper': assertValidates('hyper-schema', 'hyper-schema'),
    'Hyper/Core': assertValidates('hyper-schema', 'schema'),

    'Links-NSD self-validates': assertSelfValidates('links-nsd'),
    'Links self-validates': assertSelfValidates('links'),
    'Links/Hyper': assertValidates('links', 'hyper-schema'),
    'Links/Core': assertValidates('links', 'schema'),

    'Json-Ref self-validates': assertSelfValidates('json-ref'),
    'Json-Ref/Hyper': assertValidates('json-ref', 'hyper-schema'),
    'Json-Ref/Core': assertValidates('json-ref', 'schema')
}).export(module);
/*.tgz
## Unreleased
- Fixes stringify to only take ancestors into account when checking
  circularity.  
  It previously assumed every visited object was circular which led to [false
  positives][issue9].  
  Uses the tiny serializer I wrote for [Must.js][must] a year and a half ago.
- Fixes calling the `replacer` function in the proper context (`thisArg`).
- Fixes calling the `cycleReplacer` function in the proper context (`thisArg`).
- Speeds serializing by a factor of
  Big-O(h-my-god-it-linearly-searched-every-object) it had ever seen. Searching
  only the ancestors for a circular references speeds up things considerably.

[must]: https://github.com/moll/js-must
[issue9]: https://github.com/isaacs/json-stringify-safe/issues/9
The ISC License

Copyright (c) Isaac Z. Schlueter and Contributors

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
NODE_OPTS =
TEST_OPTS =

love:
	@echo "Feel like makin' love."

test:
	@node $(NODE_OPTS) ./node_modules/.bin/_mocha -R dot $(TEST_OPTS)

spec:
	@node $(NODE_OPTS) ./node_modules/.bin/_mocha -R spec $(TEST_OPTS)

autotest:
	@node $(NODE_OPTS) ./node_modules/.bin/_mocha -R dot --watch $(TEST_OPTS)

autospec:
	@node $(NODE_OPTS) ./node_modules/.bin/_mocha -R spec --watch $(TEST_OPTS)

pack:
	@file=$$(npm pack); echo "$$file"; tar tf "$$file"

publish:
	npm publish

tag:
	git tag "v$$(node -e 'console.log(require("./package").version)')"

clean:
	rm -f *.tgz
	npm prune --production

.PHONY: love
.PHONY: test spec autotest autospec
.PHONY: pack publish tag
.PHONY: clean
{
  "name": "json-stringify-safe",
  "version": "5.0.1",
  "description": "Like JSON.stringify, but doesn't blow up on circular refs.",
  "keywords": [
    "json",
    "stringify",
    "circular",
    "safe"
  ],
  "homepage": "https://github.com/isaacs/json-stringify-safe",
  "bugs": "https://github.com/isaacs/json-stringify-safe/issues",
  "author": "Isaac Z. Schlueter <i@izs.me> (http://blog.izs.me)",
  "contributors": [
    "Andri Möll <andri@dot.ee> (http://themoll.com)"
  ],
  "license": "ISC",
  "repository": {
    "type": "git",
    "url": "git://github.com/isaacs/json-stringify-safe"
  },
  "main": "stringify.js",
  "scripts": {
    "test": "node test.js"
  },
  "devDependencies": {
    "mocha": ">= 2.1.0 < 3",
    "must": ">= 0.12 < 0.13",
    "sinon": ">= 1.12.2 < 2"
  }
}
# json-stringify-safe

Like JSON.stringify, but doesn't throw on circular references.

## Usage

Takes the same arguments as `JSON.stringify`.

```javascript
var stringify = require('json-stringify-safe');
var circularObj = {};
circularObj.circularRef = circularObj;
circularObj.list = [ circularObj, circularObj ];
console.log(stringify(circularObj, null, 2));
```

Output:

```json
{
  "circularRef": "[Circular]",
  "list": [
    "[Circular]",
    "[Circular]"
  ]
}
```

## Details

```
stringify(obj, serializer, indent, decycler)
```

The first three arguments are the same as to JSON.stringify.  The last
is an argument that's only used when the object has been seen already.

The default `decycler` function returns the string `'[Circular]'`.
If, for example, you pass in `function(k,v){}` (return nothing) then it
will prune cycles.  If you pass in `function(k,v){ return {foo: 'bar'}}`,
then cyclical objects will always be represented as `{"foo":"bar"}` in
the result.

```
stringify.getSerialize(serializer, decycler)
```

Returns a serializer that can be used elsewhere.  This is the actual
function that's passed to JSON.stringify.

**Note** that the function returned from `getSerialize` is stateful for now, so
do **not** use it more than once.
exports = module.exports = stringify
exports.getSerialize = serializer

function stringify(obj, replacer, spaces, cycleReplacer) {
  return JSON.stringify(obj, serializer(replacer, cycleReplacer), spaces)
}

function serializer(replacer, cycleReplacer) {
  var stack = [], keys = []

  if (cycleReplacer == null) cycleReplacer = function(key, value) {
    if (stack[0] === value) return "[Circular ~]"
    return "[Circular ~." + keys.slice(0, stack.indexOf(value)).join(".") + "]"
  }

  return function(key, value) {
    if (stack.length > 0) {
      var thisPos = stack.indexOf(this)
      ~thisPos ? stack.splice(thisPos + 1) : stack.push(this)
      ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key)
      if (~stack.indexOf(value)) value = cycleReplacer.call(this, key, value)
    }
    else stack.push(value)

    return replacer == null ? value : replacer.call(this, key, value)
  }
}
--recursive
--require must
var Sinon = require("sinon")
var stringify = require("..")
function jsonify(obj) { return JSON.stringify(obj, null, 2) }

describe("Stringify", function() {
  it("must stringify circular objects", function() {
    var obj = {name: "Alice"}
    obj.self = obj
    var json = stringify(obj, null, 2)
    json.must.eql(jsonify({name: "Alice", self: "[Circular ~]"}))
  })

  it("must stringify circular objects with intermediaries", function() {
    var obj = {name: "Alice"}
    obj.identity = {self: obj}
    var json = stringify(obj, null, 2)
    json.must.eql(jsonify({name: "Alice", identity: {self: "[Circular ~]"}}))
  })

  it("must stringify circular objects deeper", function() {
    var obj = {name: "Alice", child: {name: "Bob"}}
    obj.child.self = obj.child

    stringify(obj, null, 2).must.eql(jsonify({
      name: "Alice",
      child: {name: "Bob", self: "[Circular ~.child]"}
    }))
  })

  it("must stringify circular objects deeper with intermediaries", function() {
    var obj = {name: "Alice", child: {name: "Bob"}}
    obj.child.identity = {self: obj.child}

    stringify(obj, null, 2).must.eql(jsonify({
      name: "Alice",
      child: {name: "Bob", identity: {self: "[Circular ~.child]"}}
    }))
  })

  it("must stringify circular objects in an array", function() {
    var obj = {name: "Alice"}
    obj.self = [obj, obj]

    stringify(obj, null, 2).must.eql(jsonify({
      name: "Alice", self: ["[Circular ~]", "[Circular ~]"]
    }))
  })

  it("must stringify circular objects deeper in an array", function() {
    var obj = {name: "Alice", children: [{name: "Bob"}, {name: "Eve"}]}
    obj.children[0].self = obj.children[0]
    obj.children[1].self = obj.children[1]

    stringify(obj, null, 2).must.eql(jsonify({
      name: "Alice",
      children: [
        {name: "Bob", self: "[Circular ~.children.0]"},
        {name: "Eve", self: "[Circular ~.children.1]"}
      ]
    }))
  })

  it("must stringify circular arrays", function() {
    var obj = []
    obj.push(obj)
    obj.push(obj)
    var json = stringify(obj, null, 2)
    json.must.eql(jsonify(["[Circular ~]", "[Circular ~]"]))
  })

  it("must stringify circular arrays with intermediaries", function() {
    var obj = []
    obj.push({name: "Alice", self: obj})
    obj.push({name: "Bob", self: obj})

    stringify(obj, null, 2).must.eql(jsonify([
      {name: "Alice", self: "[Circular ~]"},
      {name: "Bob", self: "[Circular ~]"}
    ]))
  })

  it("must stringify repeated objects in objects", function() {
    var obj = {}
    var alice = {name: "Alice"}
    obj.alice1 = alice
    obj.alice2 = alice

    stringify(obj, null, 2).must.eql(jsonify({
      alice1: {name: "Alice"},
      alice2: {name: "Alice"}
    }))
  })

  it("must stringify repeated objects in arrays", function() {
    var alice = {name: "Alice"}
    var obj = [alice, alice]
    var json = stringify(obj, null, 2)
    json.must.eql(jsonify([{name: "Alice"}, {name: "Alice"}]))
  })

  it("must call given decycler and use its output", function() {
    var obj = {}
    obj.a = obj
    obj.b = obj

    var decycle = Sinon.spy(function() { return decycle.callCount })
    var json = stringify(obj, null, 2, decycle)
    json.must.eql(jsonify({a: 1, b: 2}, null, 2))

    decycle.callCount.must.equal(2)
    decycle.thisValues[0].must.equal(obj)
    decycle.args[0][0].must.equal("a")
    decycle.args[0][1].must.equal(obj)
    decycle.thisValues[1].must.equal(obj)
    decycle.args[1][0].must.equal("b")
    decycle.args[1][1].must.equal(obj)
  })

  it("must call replacer and use its output", function() {
    var obj = {name: "Alice", child: {name: "Bob"}}

    var replacer = Sinon.spy(bangString)
    var json = stringify(obj, replacer, 2)
    json.must.eql(jsonify({name: "Alice!", child: {name: "Bob!"}}))

    replacer.callCount.must.equal(4)
    replacer.args[0][0].must.equal("")
    replacer.args[0][1].must.equal(obj)
    replacer.thisValues[1].must.equal(obj)
    replacer.args[1][0].must.equal("name")
    replacer.args[1][1].must.equal("Alice")
    replacer.thisValues[2].must.equal(obj)
    replacer.args[2][0].must.equal("child")
    replacer.args[2][1].must.equal(obj.child)
    replacer.thisValues[3].must.equal(obj.child)
    replacer.args[3][0].must.equal("name")
    replacer.args[3][1].must.equal("Bob")
  })

  it("must call replacer after describing circular references", function() {
    var obj = {name: "Alice"}
    obj.self = obj

    var replacer = Sinon.spy(bangString)
    var json = stringify(obj, replacer, 2)
    json.must.eql(jsonify({name: "Alice!", self: "[Circular ~]!"}))

    replacer.callCount.must.equal(3)
    replacer.args[0][0].must.equal("")
    replacer.args[0][1].must.equal(obj)
    replacer.thisValues[1].must.equal(obj)
    replacer.args[1][0].must.equal("name")
    replacer.args[1][1].must.equal("Alice")
    replacer.thisValues[2].must.equal(obj)
    replacer.args[2][0].must.equal("self")
    replacer.args[2][1].must.equal("[Circular ~]")
  })

  it("must call given decycler and use its output for nested objects",
    function() {
    var obj = {}
    obj.a = obj
    obj.b = {self: obj}

    var decycle = Sinon.spy(function() { return decycle.callCount })
    var json = stringify(obj, null, 2, decycle)
    json.must.eql(jsonify({a: 1, b: {self: 2}}))

    decycle.callCount.must.equal(2)
    decycle.args[0][0].must.equal("a")
    decycle.args[0][1].must.equal(obj)
    decycle.args[1][0].must.equal("self")
    decycle.args[1][1].must.equal(obj)
  })

  it("must use decycler's output when it returned null", function() {
    var obj = {a: "b"}
    obj.self = obj
    obj.selves = [obj, obj]

    function decycle() { return null }
    stringify(obj, null, 2, decycle).must.eql(jsonify({
      a: "b",
      self: null,
      selves: [null, null]
    }))
  })

  it("must use decycler's output when it returned undefined", function() {
    var obj = {a: "b"}
    obj.self = obj
    obj.selves = [obj, obj]

    function decycle() {}
    stringify(obj, null, 2, decycle).must.eql(jsonify({
      a: "b",
      selves: [null, null]
    }))
  })

  it("must throw given a decycler that returns a cycle", function() {
    var obj = {}
    obj.self = obj
    var err
    function identity(key, value) { return value }
    try { stringify(obj, null, 2, identity) } catch (ex) { err = ex }
    err.must.be.an.instanceof(TypeError)
  })

  describe(".getSerialize", function() {
    it("must stringify circular objects", function() {
      var obj = {a: "b"}
      obj.circularRef = obj
      obj.list = [obj, obj]

      var json = JSON.stringify(obj, stringify.getSerialize(), 2)
      json.must.eql(jsonify({
        "a": "b",
        "circularRef": "[Circular ~]",
        "list": ["[Circular ~]", "[Circular ~]"]
      }))
    })

    // This is the behavior as of Mar 3, 2015.
    // The serializer function keeps state inside the returned function and
    // so far I'm not sure how to not do that. JSON.stringify's replacer is not
    // called _after_ serialization.
    xit("must return a function that could be called twice", function() {
      var obj = {name: "Alice"}
      obj.self = obj

      var json
      var serializer = stringify.getSerialize()

      json = JSON.stringify(obj, serializer, 2)
      json.must.eql(jsonify({name: "Alice", self: "[Circular ~]"}))

      json = JSON.stringify(obj, serializer, 2)
      json.must.eql(jsonify({name: "Alice", self: "[Circular ~]"}))
    })
  })
})

function bangString(key, value) {
  return typeof value == "string" ? value + "!" : value
}
# Changelog

## not yet released

None yet.

## v1.4.1 (2017-08-02)

* #21 Update verror dep
* #22 Update extsprintf dependency
* #23 update contribution guidelines

## v1.4.0 (2017-03-13)

* #7 Add parseInteger() function for safer number parsing

## v1.3.1 (2016-09-12)

* #13 Incompatible with webpack

## v1.3.0 (2016-06-22)

* #14 add safer version of hasOwnProperty()
* #15 forEachKey() should ignore inherited properties

## v1.2.2 (2015-10-15)

* #11 NPM package shouldn't include any code that does `require('JSV')`
* #12 jsl.node.conf missing definition for "module"

## v1.2.1 (2015-10-14)

* #8 odd date parsing behaviour

## v1.2.0 (2015-10-13)

* #9 want function for returning RFC1123 dates

## v1.1.0 (2015-09-02)

* #6 a new suite of hrtime manipulation routines: `hrtimeAdd()`,
  `hrtimeAccum()`, `hrtimeNanosec()`, `hrtimeMicrosec()` and
  `hrtimeMillisec()`.

## v1.0.0 (2015-09-01)

First tracked release.  Includes everything in previous releases, plus:

* #4 want function for merging objects
# Contributing

This repository uses [cr.joyent.us](https://cr.joyent.us) (Gerrit) for new
changes.  Anyone can submit changes.  To get started, see the [cr.joyent.us user
guide](https://github.com/joyent/joyent-gerrit/blob/master/docs/user/README.md).
This repo does not use GitHub pull requests.

See the [Joyent Engineering
Guidelines](https://github.com/joyent/eng/blob/master/docs/index.md) for general
best practices expected in this repository.

Contributions should be "make prepush" clean.  The "prepush" target runs the
"check" target, which requires these separate tools:

* https://github.com/davepacheco/jsstyle
* https://github.com/davepacheco/javascriptlint

If you're changing something non-trivial or user-facing, you may want to submit
an issue first.
/*
 * lib/jsprim.js: utilities for primitive JavaScript types
 */

var mod_assert = require('assert-plus');
var mod_util = require('util');

var mod_extsprintf = require('extsprintf');
var mod_verror = require('verror');
var mod_jsonschema = require('json-schema');

/*
 * Public interface
 */
exports.deepCopy = deepCopy;
exports.deepEqual = deepEqual;
exports.isEmpty = isEmpty;
exports.hasKey = hasKey;
exports.forEachKey = forEachKey;
exports.pluck = pluck;
exports.flattenObject = flattenObject;
exports.flattenIter = flattenIter;
exports.validateJsonObject = validateJsonObjectJS;
exports.validateJsonObjectJS = validateJsonObjectJS;
exports.randElt = randElt;
exports.extraProperties = extraProperties;
exports.mergeObjects = mergeObjects;

exports.startsWith = startsWith;
exports.endsWith = endsWith;

exports.parseInteger = parseInteger;

exports.iso8601 = iso8601;
exports.rfc1123 = rfc1123;
exports.parseDateTime = parseDateTime;

exports.hrtimediff = hrtimeDiff;
exports.hrtimeDiff = hrtimeDiff;
exports.hrtimeAccum = hrtimeAccum;
exports.hrtimeAdd = hrtimeAdd;
exports.hrtimeNanosec = hrtimeNanosec;
exports.hrtimeMicrosec = hrtimeMicrosec;
exports.hrtimeMillisec = hrtimeMillisec;


/*
 * Deep copy an acyclic *basic* Javascript object.  This only handles basic
 * scalars (strings, numbers, booleans) and arbitrarily deep arrays and objects
 * containing these.  This does *not* handle instances of other classes.
 */
function deepCopy(obj)
{
	var ret, key;
	var marker = '__deepCopy';

	if (obj && obj[marker])
		throw (new Error('attempted deep copy of cyclic object'));

	if (obj && obj.constructor == Object) {
		ret = {};
		obj[marker] = true;

		for (key in obj) {
			if (key == marker)
				continue;

			ret[key] = deepCopy(obj[key]);
		}

		delete (obj[marker]);
		return (ret);
	}

	if (obj && obj.constructor == Array) {
		ret = [];
		obj[marker] = true;

		for (key = 0; key < obj.length; key++)
			ret.push(deepCopy(obj[key]));

		delete (obj[marker]);
		return (ret);
	}

	/*
	 * It must be a primitive type -- just return it.
	 */
	return (obj);
}

function deepEqual(obj1, obj2)
{
	if (typeof (obj1) != typeof (obj2))
		return (false);

	if (obj1 === null || obj2 === null || typeof (obj1) != 'object')
		return (obj1 === obj2);

	if (obj1.constructor != obj2.constructor)
		return (false);

	var k;
	for (k in obj1) {
		if (!obj2.hasOwnProperty(k))
			return (false);

		if (!deepEqual(obj1[k], obj2[k]))
			return (false);
	}

	for (k in obj2) {
		if (!obj1.hasOwnProperty(k))
			return (false);
	}

	return (true);
}

function isEmpty(obj)
{
	var key;
	for (key in obj)
		return (false);
	return (true);
}

function hasKey(obj, key)
{
	mod_assert.equal(typeof (key), 'string');
	return (Object.prototype.hasOwnProperty.call(obj, key));
}

function forEachKey(obj, callback)
{
	for (var key in obj) {
		if (hasKey(obj, key)) {
			callback(key, obj[key]);
		}
	}
}

function pluck(obj, key)
{
	mod_assert.equal(typeof (key), 'string');
	return (pluckv(obj, key));
}

function pluckv(obj, key)
{
	if (obj === null || typeof (obj) !== 'object')
		return (undefined);

	if (obj.hasOwnProperty(key))
		return (obj[key]);

	var i = key.indexOf('.');
	if (i == -1)
		return (undefined);

	var key1 = key.substr(0, i);
	if (!obj.hasOwnProperty(key1))
		return (undefined);

	return (pluckv(obj[key1], key.substr(i + 1)));
}

/*
 * Invoke callback(row) for each entry in the array that would be returned by
 * flattenObject(data, depth).  This is just like flattenObject(data,
 * depth).forEach(callback), except that the intermediate array is never
 * created.
 */
function flattenIter(data, depth, callback)
{
	doFlattenIter(data, depth, [], callback);
}

function doFlattenIter(data, depth, accum, callback)
{
	var each;
	var key;

	if (depth === 0) {
		each = accum.slice(0);
		each.push(data);
		callback(each);
		return;
	}

	mod_assert.ok(data !== null);
	mod_assert.equal(typeof (data), 'object');
	mod_assert.equal(typeof (depth), 'number');
	mod_assert.ok(depth >= 0);

	for (key in data) {
		each = accum.slice(0);
		each.push(key);
		doFlattenIter(data[key], depth - 1, each, callback);
	}
}

function flattenObject(data, depth)
{
	if (depth === 0)
		return ([ data ]);

	mod_assert.ok(data !== null);
	mod_assert.equal(typeof (data), 'object');
	mod_assert.equal(typeof (depth), 'number');
	mod_assert.ok(depth >= 0);

	var rv = [];
	var key;

	for (key in data) {
		flattenObject(data[key], depth - 1).forEach(function (p) {
			rv.push([ key ].concat(p));
		});
	}

	return (rv);
}

function startsWith(str, prefix)
{
	return (str.substr(0, prefix.length) == prefix);
}

function endsWith(str, suffix)
{
	return (str.substr(
	    str.length - suffix.length, suffix.length) == suffix);
}

function iso8601(d)
{
	if (typeof (d) == 'number')
		d = new Date(d);
	mod_assert.ok(d.constructor === Date);
	return (mod_extsprintf.sprintf('%4d-%02d-%02dT%02d:%02d:%02d.%03dZ',
	    d.getUTCFullYear(), d.getUTCMonth() + 1, d.getUTCDate(),
	    d.getUTCHours(), d.getUTCMinutes(), d.getUTCSeconds(),
	    d.getUTCMilliseconds()));
}

var RFC1123_MONTHS = [
    'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
    'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
var RFC1123_DAYS = [
    'Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];

function rfc1123(date) {
	return (mod_extsprintf.sprintf('%s, %02d %s %04d %02d:%02d:%02d GMT',
	    RFC1123_DAYS[date.getUTCDay()], date.getUTCDate(),
	    RFC1123_MONTHS[date.getUTCMonth()], date.getUTCFullYear(),
	    date.getUTCHours(), date.getUTCMinutes(),
	    date.getUTCSeconds()));
}

/*
 * Parses a date expressed as a string, as either a number of milliseconds since
 * the epoch or any string format that Date accepts, giving preference to the
 * former where these two sets overlap (e.g., small numbers).
 */
function parseDateTime(str)
{
	/*
	 * This is irritatingly implicit, but significantly more concise than
	 * alternatives.  The "+str" will convert a string containing only a
	 * number directly to a Number, or NaN for other strings.  Thus, if the
	 * conversion succeeds, we use it (this is the milliseconds-since-epoch
	 * case).  Otherwise, we pass the string directly to the Date
	 * constructor to parse.
	 */
	var numeric = +str;
	if (!isNaN(numeric)) {
		return (new Date(numeric));
	} else {
		return (new Date(str));
	}
}


/*
 * Number.*_SAFE_INTEGER isn't present before node v0.12, so we hardcode
 * the ES6 definitions here, while allowing for them to someday be higher.
 */
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
var MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;


/*
 * Default options for parseInteger().
 */
var PI_DEFAULTS = {
	base: 10,
	allowSign: true,
	allowPrefix: false,
	allowTrailing: false,
	allowImprecise: false,
	trimWhitespace: false,
	leadingZeroIsOctal: false
};

var CP_0 = 0x30;
var CP_9 = 0x39;

var CP_A = 0x41;
var CP_B = 0x42;
var CP_O = 0x4f;
var CP_T = 0x54;
var CP_X = 0x58;
var CP_Z = 0x5a;

var CP_a = 0x61;
var CP_b = 0x62;
var CP_o = 0x6f;
var CP_t = 0x74;
var CP_x = 0x78;
var CP_z = 0x7a;

var PI_CONV_DEC = 0x30;
var PI_CONV_UC = 0x37;
var PI_CONV_LC = 0x57;


/*
 * A stricter version of parseInt() that provides options for changing what
 * is an acceptable string (for example, disallowing trailing characters).
 */
function parseInteger(str, uopts)
{
	mod_assert.string(str, 'str');
	mod_assert.optionalObject(uopts, 'options');

	var baseOverride = false;
	var options = PI_DEFAULTS;

	if (uopts) {
		baseOverride = hasKey(uopts, 'base');
		options = mergeObjects(options, uopts);
		mod_assert.number(options.base, 'options.base');
		mod_assert.ok(options.base >= 2, 'options.base >= 2');
		mod_assert.ok(options.base <= 36, 'options.base <= 36');
		mod_assert.bool(options.allowSign, 'options.allowSign');
		mod_assert.bool(options.allowPrefix, 'options.allowPrefix');
		mod_assert.bool(options.allowTrailing,
		    'options.allowTrailing');
		mod_assert.bool(options.allowImprecise,
		    'options.allowImprecise');
		mod_assert.bool(options.trimWhitespace,
		    'options.trimWhitespace');
		mod_assert.bool(options.leadingZeroIsOctal,
		    'options.leadingZeroIsOctal');

		if (options.leadingZeroIsOctal) {
			mod_assert.ok(!baseOverride,
			    '"base" and "leadingZeroIsOctal" are ' +
			    'mutually exclusive');
		}
	}

	var c;
	var pbase = -1;
	var base = options.base;
	var start;
	var mult = 1;
	var value = 0;
	var idx = 0;
	var len = str.length;

	/* Trim any whitespace on the left side. */
	if (options.trimWhitespace) {
		while (idx < len && isSpace(str.charCodeAt(idx))) {
			++idx;
		}
	}

	/* Check the number for a leading sign. */
	if (options.allowSign) {
		if (str[idx] === '-') {
			idx += 1;
			mult = -1;
		} else if (str[idx] === '+') {
			idx += 1;
		}
	}

	/* Parse the base-indicating prefix if there is one. */
	if (str[idx] === '0') {
		if (options.allowPrefix) {
			pbase = prefixToBase(str.charCodeAt(idx + 1));
			if (pbase !== -1 && (!baseOverride || pbase === base)) {
				base = pbase;
				idx += 2;
			}
		}

		if (pbase === -1 && options.leadingZeroIsOctal) {
			base = 8;
		}
	}

	/* Parse the actual digits. */
	for (start = idx; idx < len; ++idx) {
		c = translateDigit(str.charCodeAt(idx));
		if (c !== -1 && c < base) {
			value *= base;
			value += c;
		} else {
			break;
		}
	}

	/* If we didn't parse any digits, we have an invalid number. */
	if (start === idx) {
		return (new Error('invalid number: ' + JSON.stringify(str)));
	}

	/* Trim any whitespace on the right side. */
	if (options.trimWhitespace) {
		while (idx < len && isSpace(str.charCodeAt(idx))) {
			++idx;
		}
	}

	/* Check for trailing characters. */
	if (idx < len && !options.allowTrailing) {
		return (new Error('trailing characters after number: ' +
		    JSON.stringify(str.slice(idx))));
	}

	/* If our value is 0, we return now, to avoid returning -0. */
	if (value === 0) {
		return (0);
	}

	/* Calculate our final value. */
	var result = value * mult;

	/*
	 * If the string represents a value that cannot be precisely represented
	 * by JavaScript, then we want to check that:
	 *
	 * - We never increased the value past MAX_SAFE_INTEGER
	 * - We don't make the result negative and below MIN_SAFE_INTEGER
	 *
	 * Because we only ever increment the value during parsing, there's no
	 * chance of moving past MAX_SAFE_INTEGER and then dropping below it
	 * again, losing precision in the process. This means that we only need
	 * to do our checks here, at the end.
	 */
	if (!options.allowImprecise &&
	    (value > MAX_SAFE_INTEGER || result < MIN_SAFE_INTEGER)) {
		return (new Error('number is outside of the supported range: ' +
		    JSON.stringify(str.slice(start, idx))));
	}

	return (result);
}


/*
 * Interpret a character code as a base-36 digit.
 */
function translateDigit(d)
{
	if (d >= CP_0 && d <= CP_9) {
		/* '0' to '9' -> 0 to 9 */
		return (d - PI_CONV_DEC);
	} else if (d >= CP_A && d <= CP_Z) {
		/* 'A' - 'Z' -> 10 to 35 */
		return (d - PI_CONV_UC);
	} else if (d >= CP_a && d <= CP_z) {
		/* 'a' - 'z' -> 10 to 35 */
		return (d - PI_CONV_LC);
	} else {
		/* Invalid character code */
		return (-1);
	}
}


/*
 * Test if a value matches the ECMAScript definition of trimmable whitespace.
 */
function isSpace(c)
{
	return (c === 0x20) ||
	    (c >= 0x0009 && c <= 0x000d) ||
	    (c === 0x00a0) ||
	    (c === 0x1680) ||
	    (c === 0x180e) ||
	    (c >= 0x2000 && c <= 0x200a) ||
	    (c === 0x2028) ||
	    (c === 0x2029) ||
	    (c === 0x202f) ||
	    (c === 0x205f) ||
	    (c === 0x3000) ||
	    (c === 0xfeff);
}


/*
 * Determine which base a character indicates (e.g., 'x' indicates hex).
 */
function prefixToBase(c)
{
	if (c === CP_b || c === CP_B) {
		/* 0b/0B (binary) */
		return (2);
	} else if (c === CP_o || c === CP_O) {
		/* 0o/0O (octal) */
		return (8);
	} else if (c === CP_t || c === CP_T) {
		/* 0t/0T (decimal) */
		return (10);
	} else if (c === CP_x || c === CP_X) {
		/* 0x/0X (hexadecimal) */
		return (16);
	} else {
		/* Not a meaningful character */
		return (-1);
	}
}


function validateJsonObjectJS(schema, input)
{
	var report = mod_jsonschema.validate(input, schema);

	if (report.errors.length === 0)
		return (null);

	/* Currently, we only do anything useful with the first error. */
	var error = report.errors[0];

	/* The failed property is given by a URI with an irrelevant prefix. */
	var propname = error['property'];
	var reason = error['message'].toLowerCase();
	var i, j;

	/*
	 * There's at least one case where the property error message is
	 * confusing at best.  We work around this here.
	 */
	if ((i = reason.indexOf('the property ')) != -1 &&
	    (j = reason.indexOf(' is not defined in the schema and the ' +
	    'schema does not allow additional properties')) != -1) {
		i += 'the property '.length;
		if (propname === '')
			propname = reason.substr(i, j - i);
		else
			propname = propname + '.' + reason.substr(i, j - i);

		reason = 'unsupported property';
	}

	var rv = new mod_verror.VError('property "%s": %s', propname, reason);
	rv.jsv_details = error;
	return (rv);
}

function randElt(arr)
{
	mod_assert.ok(Array.isArray(arr) && arr.length > 0,
	    'randElt argument must be a non-empty array');

	return (arr[Math.floor(Math.random() * arr.length)]);
}

function assertHrtime(a)
{
	mod_assert.ok(a[0] >= 0 && a[1] >= 0,
	    'negative numbers not allowed in hrtimes');
	mod_assert.ok(a[1] < 1e9, 'nanoseconds column overflow');
}

/*
 * Compute the time elapsed between hrtime readings A and B, where A is later
 * than B.  hrtime readings come from Node's process.hrtime().  There is no
 * defined way to represent negative deltas, so it's illegal to diff B from A
 * where the time denoted by B is later than the time denoted by A.  If this
 * becomes valuable, we can define a representation and extend the
 * implementation to support it.
 */
function hrtimeDiff(a, b)
{
	assertHrtime(a);
	assertHrtime(b);
	mod_assert.ok(a[0] > b[0] || (a[0] == b[0] && a[1] >= b[1]),
	    'negative differences not allowed');

	var rv = [ a[0] - b[0], 0 ];

	if (a[1] >= b[1]) {
		rv[1] = a[1] - b[1];
	} else {
		rv[0]--;
		rv[1] = 1e9 - (b[1] - a[1]);
	}

	return (rv);
}

/*
 * Convert a hrtime reading from the array format returned by Node's
 * process.hrtime() into a scalar number of nanoseconds.
 */
function hrtimeNanosec(a)
{
	assertHrtime(a);

	return (Math.floor(a[0] * 1e9 + a[1]));
}

/*
 * Convert a hrtime reading from the array format returned by Node's
 * process.hrtime() into a scalar number of microseconds.
 */
function hrtimeMicrosec(a)
{
	assertHrtime(a);

	return (Math.floor(a[0] * 1e6 + a[1] / 1e3));
}

/*
 * Convert a hrtime reading from the array format returned by Node's
 * process.hrtime() into a scalar number of milliseconds.
 */
function hrtimeMillisec(a)
{
	assertHrtime(a);

	return (Math.floor(a[0] * 1e3 + a[1] / 1e6));
}

/*
 * Add two hrtime readings A and B, overwriting A with the result of the
 * addition.  This function is useful for accumulating several hrtime intervals
 * into a counter.  Returns A.
 */
function hrtimeAccum(a, b)
{
	assertHrtime(a);
	assertHrtime(b);

	/*
	 * Accumulate the nanosecond component.
	 */
	a[1] += b[1];
	if (a[1] >= 1e9) {
		/*
		 * The nanosecond component overflowed, so carry to the seconds
		 * field.
		 */
		a[0]++;
		a[1] -= 1e9;
	}

	/*
	 * Accumulate the seconds component.
	 */
	a[0] += b[0];

	return (a);
}

/*
 * Add two hrtime readings A and B, returning the result as a new hrtime array.
 * Does not modify either input argument.
 */
function hrtimeAdd(a, b)
{
	assertHrtime(a);

	var rv = [ a[0], a[1] ];

	return (hrtimeAccum(rv, b));
}


/*
 * Check an object for unexpected properties.  Accepts the object to check, and
 * an array of allowed property names (strings).  Returns an array of key names
 * that were found on the object, but did not appear in the list of allowed
 * properties.  If no properties were found, the returned array will be of
 * zero length.
 */
function extraProperties(obj, allowed)
{
	mod_assert.ok(typeof (obj) === 'object' && obj !== null,
	    'obj argument must be a non-null object');
	mod_assert.ok(Array.isArray(allowed),
	    'allowed argument must be an array of strings');
	for (var i = 0; i < allowed.length; i++) {
		mod_assert.ok(typeof (allowed[i]) === 'string',
		    'allowed argument must be an array of strings');
	}

	return (Object.keys(obj).filter(function (key) {
		return (allowed.indexOf(key) === -1);
	}));
}

/*
 * Given three sets of properties "provided" (may be undefined), "overrides"
 * (required), and "defaults" (may be undefined), construct an object containing
 * the union of these sets with "overrides" overriding "provided", and
 * "provided" overriding "defaults".  None of the input objects are modified.
 */
function mergeObjects(provided, overrides, defaults)
{
	var rv, k;

	rv = {};
	if (defaults) {
		for (k in defaults)
			rv[k] = defaults[k];
	}

	if (provided) {
		for (k in provided)
			rv[k] = provided[k];
	}

	if (overrides) {
		for (k in overrides)
			rv[k] = overrides[k];
	}

	return (rv);
}
Copyright (c) 2012, Joyent, Inc. All rights reserved.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE
{
	"name": "jsprim",
	"version": "1.4.1",
	"description": "utilities for primitive JavaScript types",
	"main": "./lib/jsprim.js",
	"repository": {
		"type": "git",
		"url": "git://github.com/joyent/node-jsprim.git"
	},
	"dependencies": {
		"assert-plus": "1.0.0",
		"extsprintf": "1.3.0",
		"json-schema": "0.2.3",
		"verror": "1.10.0"
	},
	"engines": [
		"node >=0.6.0"
	],
	"license": "MIT"
}
# jsprim: utilities for primitive JavaScript types

This module provides miscellaneous facilities for working with strings,
numbers, dates, and objects and arrays of these basic types.


### deepCopy(obj)

Creates a deep copy of a primitive type, object, or array of primitive types.


### deepEqual(obj1, obj2)

Returns whether two objects are equal.


### isEmpty(obj)

Returns true if the given object has no properties and false otherwise.  This
is O(1) (unlike `Object.keys(obj).length === 0`, which is O(N)).

### hasKey(obj, key)

Returns true if the given object has an enumerable, non-inherited property
called `key`.  [For information on enumerability and ownership of properties, see
the MDN
documentation.](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Enumerability_and_ownership_of_properties)

### forEachKey(obj, callback)

Like Array.forEach, but iterates enumerable, owned properties of an object
rather than elements of an array.  Equivalent to:

    for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    callback(key, obj[key]);
            }
    }


### flattenObject(obj, depth)

Flattens an object up to a given level of nesting, returning an array of arrays
of length "depth + 1", where the first "depth" elements correspond to flattened
columns and the last element contains the remaining object .  For example:

    flattenObject({
        'I': {
            'A': {
                'i': {
                    'datum1': [ 1, 2 ],
                    'datum2': [ 3, 4 ]
                },
                'ii': {
                    'datum1': [ 3, 4 ]
                }
            },
            'B': {
                'i': {
                    'datum1': [ 5, 6 ]
                },
                'ii': {
                    'datum1': [ 7, 8 ],
                    'datum2': [ 3, 4 ],
                },
                'iii': {
                }
            }
        },
        'II': {
            'A': {
                'i': {
                    'datum1': [ 1, 2 ],
                    'datum2': [ 3, 4 ]
                }
            }
        }
    }, 3)

becomes:

    [
        [ 'I',  'A', 'i',   { 'datum1': [ 1, 2 ], 'datum2': [ 3, 4 ] } ],
        [ 'I',  'A', 'ii',  { 'datum1': [ 3, 4 ] } ],
        [ 'I',  'B', 'i',   { 'datum1': [ 5, 6 ] } ],
        [ 'I',  'B', 'ii',  { 'datum1': [ 7, 8 ], 'datum2': [ 3, 4 ] } ],
        [ 'I',  'B', 'iii', {} ],
        [ 'II', 'A', 'i',   { 'datum1': [ 1, 2 ], 'datum2': [ 3, 4 ] } ]
    ]

This function is strict: "depth" must be a non-negative integer and "obj" must
be a non-null object with at least "depth" levels of nesting under all keys.


### flattenIter(obj, depth, func)

This is similar to `flattenObject` except that instead of returning an array,
this function invokes `func(entry)` for each `entry` in the array that
`flattenObject` would return.  `flattenIter(obj, depth, func)` is logically
equivalent to `flattenObject(obj, depth).forEach(func)`.  Importantly, this
version never constructs the full array.  Its memory usage is O(depth) rather
than O(n) (where `n` is the number of flattened elements).

There's another difference between `flattenObject` and `flattenIter` that's
related to the special case where `depth === 0`.  In this case, `flattenObject`
omits the array wrapping `obj` (which is regrettable).


### pluck(obj, key)

Fetch nested property "key" from object "obj", traversing objects as needed.
For example, `pluck(obj, "foo.bar.baz")` is roughly equivalent to
`obj.foo.bar.baz`, except that:

1. If traversal fails, the resulting value is undefined, and no error is
   thrown.  For example, `pluck({}, "foo.bar")` is just undefined.
2. If "obj" has property "key" directly (without traversing), the
   corresponding property is returned.  For example,
   `pluck({ 'foo.bar': 1 }, 'foo.bar')` is 1, not undefined.  This is also
   true recursively, so `pluck({ 'a': { 'foo.bar': 1 } }, 'a.foo.bar')` is
   also 1, not undefined.


### randElt(array)

Returns an element from "array" selected uniformly at random.  If "array" is
empty, throws an Error.


### startsWith(str, prefix)

Returns true if the given string starts with the given prefix and false
otherwise.


### endsWith(str, suffix)

Returns true if the given string ends with the given suffix and false
otherwise.


### parseInteger(str, options)

Parses the contents of `str` (a string) as an integer. On success, the integer
value is returned (as a number). On failure, an error is **returned** describing
why parsing failed.

By default, leading and trailing whitespace characters are not allowed, nor are
trailing characters that are not part of the numeric representation. This
behaviour can be toggled by using the options below. The empty string (`''`) is
not considered valid input. If the return value cannot be precisely represented
as a number (i.e., is smaller than `Number.MIN_SAFE_INTEGER` or larger than
`Number.MAX_SAFE_INTEGER`), an error is returned. Additionally, the string
`'-0'` will be parsed as the integer `0`, instead of as the IEEE floating point
value `-0`.

This function accepts both upper and lowercase characters for digits, similar to
`parseInt()`, `Number()`, and [strtol(3C)](https://illumos.org/man/3C/strtol).

The following may be specified in `options`:

Option             | Type    | Default | Meaning
------------------ | ------- | ------- | ---------------------------
base               | number  | 10      | numeric base (radix) to use, in the range 2 to 36
allowSign          | boolean | true    | whether to interpret any leading `+` (positive) and `-` (negative) characters
allowImprecise     | boolean | false   | whether to accept values that may have lost precision (past `MAX_SAFE_INTEGER` or below `MIN_SAFE_INTEGER`)
allowPrefix        | boolean | false   | whether to interpret the prefixes `0b` (base 2), `0o` (base 8), `0t` (base 10), or `0x` (base 16)
allowTrailing      | boolean | false   | whether to ignore trailing characters
trimWhitespace     | boolean | false   | whether to trim any leading or trailing whitespace/line terminators
leadingZeroIsOctal | boolean | false   | whether a leading zero indicates octal

Note that if `base` is unspecified, and `allowPrefix` or `leadingZeroIsOctal`
are, then the leading characters can change the default base from 10. If `base`
is explicitly specified and `allowPrefix` is true, then the prefix will only be
accepted if it matches the specified base. `base` and `leadingZeroIsOctal`
cannot be used together.

**Context:** It's tricky to parse integers with JavaScript's built-in facilities
for several reasons:

- `parseInt()` and `Number()` by default allow the base to be specified in the
  input string by a prefix (e.g., `0x` for hex).
- `parseInt()` allows trailing nonnumeric characters.
- `Number(str)` returns 0 when `str` is the empty string (`''`).
- Both functions return incorrect values when the input string represents a
  valid integer outside the range of integers that can be represented precisely.
  Specifically, `parseInt('9007199254740993')` returns 9007199254740992.
- Both functions always accept `-` and `+` signs before the digit.
- Some older JavaScript engines always interpret a leading 0 as indicating
  octal, which can be surprising when parsing input from users who expect a
  leading zero to be insignificant.

While each of these may be desirable in some contexts, there are also times when
none of them are wanted. `parseInteger()` grants greater control over what
input's permissible.

### iso8601(date)

Converts a Date object to an ISO8601 date string of the form
"YYYY-MM-DDTHH:MM:SS.sssZ".  This format is not customizable.


### parseDateTime(str)

Parses a date expressed as a string, as either a number of milliseconds since
the epoch or any string format that Date accepts, giving preference to the
former where these two sets overlap (e.g., strings containing small numbers).


### hrtimeDiff(timeA, timeB)

Given two hrtime readings (as from Node's `process.hrtime()`), where timeA is
later than timeB, compute the difference and return that as an hrtime.  It is
illegal to invoke this for a pair of times where timeB is newer than timeA.

### hrtimeAdd(timeA, timeB)

Add two hrtime intervals (as from Node's `process.hrtime()`), returning a new
hrtime interval array.  This function does not modify either input argument.


### hrtimeAccum(timeA, timeB)

Add two hrtime intervals (as from Node's `process.hrtime()`), storing the
result in `timeA`.  This function overwrites (and returns) the first argument
passed in.


### hrtimeNanosec(timeA), hrtimeMicrosec(timeA), hrtimeMillisec(timeA)

This suite of functions converts a hrtime interval (as from Node's
`process.hrtime()`) into a scalar number of nanoseconds, microseconds or
milliseconds.  Results are truncated, as with `Math.floor()`.


### validateJsonObject(schema, object)

Uses JSON validation (via JSV) to validate the given object against the given
schema.  On success, returns null.  On failure, *returns* (does not throw) a
useful Error object.


### extraProperties(object, allowed)

Check an object for unexpected properties.  Accepts the object to check, and an
array of allowed property name strings.  If extra properties are detected, an
array of extra property names is returned.  If no properties other than those
in the allowed list are present on the object, the returned array will be of
zero length.

### mergeObjects(provided, overrides, defaults)

Merge properties from objects "provided", "overrides", and "defaults".  The
intended use case is for functions that accept named arguments in an "args"
object, but want to provide some default values and override other values.  In
that case, "provided" is what the caller specified, "overrides" are what the
function wants to override, and "defaults" contains default values.

The function starts with the values in "defaults", overrides them with the
values in "provided", and then overrides those with the values in "overrides".
For convenience, any of these objects may be falsey, in which case they will be
ignored.  The input objects are never modified, but properties in the returned
object are not deep-copied.

For example:

    mergeObjects(undefined, { 'objectMode': true }, { 'highWaterMark': 0 })

returns:

    { 'objectMode': true, 'highWaterMark': 0 }

For another example:

    mergeObjects(
        { 'highWaterMark': 16, 'objectMode': 7 }, /* from caller */
        { 'objectMode': true },                   /* overrides */
        { 'highWaterMark': 0 });                  /* default */

returns:

    { 'objectMode': true, 'highWaterMark': 16 }


# Contributing

See separate [contribution guidelines](CONTRIBUTING.md).
.DS_Store
_local
tstest.js
*-test.js
node_modules
language: node_js
node_js:
  - node  # latest stable
  - 6
script: 
  - npm test
// This is a benchmark suite which will run with nodejs.
// $ node --expose-gc benchmark.js
var assert = require('assert'),
    util = require('util'),
    LRUMap = require('./lru').LRUMap;

// Create a cache with N entries
var N = 10000;

// Run each measurement Iterations times
var Iterations = 1000;


var has_gc_access = typeof gc === 'function';
var gc_collect = has_gc_access ? gc : function(){};

Number.prototype.toHuman = function(divisor) {
  var N = Math.round(divisor ? this/divisor : this);
  var n = N.toString().split('.');
  n[0] = n[0].replace(/(\d)(?=(\d\d\d)+(?!\d))/g, '$1,');
  return n.join('.');
}
Number.prototype.toSignedHuman = function(divisor) {
  var n = this.toHuman(divisor);
  if (this > -1) n = '+'+n;
  return n;
}

function measure(block) {
  gc_collect();
  var elapsed = 0, start, usec, n;
  var sm = process.memoryUsage();
  if (Iterations && Iterations > 0) {
    start = new Date();
    for (n = 0; n < Iterations; n++) {
      block();
    }
    usec = ((new Date() - start) / Iterations) * 1000;
  } else {
    start = new Date();
    block();
    usec = (new Date() - start) * 1000;
  }

  var msg = '\n----------\n  ' + block.toString().replace(/\n/g, "\n  ") + '\n';

  if (has_gc_access) {
    gc_collect();
    var em = process.memoryUsage();
    var mrssd = em.rss - sm.rss;
    var mhtotd = em.heapTotal - sm.heapTotal;
    var mhusedd = em.heapUsed - sm.heapUsed;
    msg += '   rss:        ' + mrssd.toSignedHuman(1024) + ' kB -- (' +
           sm.rss.toHuman(1024) + ' kB -> ' + em.rss.toHuman(1024) + ' kB)\n';
    if (typeof sm.vsize === 'number') {
      var mvsized = em.vsize - sm.vsize;
      msg +=
           '   vsize:      ' + mvsized.toSignedHuman(1024) + ' kB -- (' +
           sm.vsize.toHuman(1024) + ' kB -> ' + em.vsize.toHuman(1024) + ' kB)\n';
    }
    msg += '   heap total: ' + mhtotd.toSignedHuman(1024) + ' kB -- (' +
           sm.heapTotal.toHuman(1024) + ' kB -> ' + em.heapTotal.toHuman(1024) + ' kB)\n' +
           '   heap used:  ' + mhusedd.toSignedHuman(1024) + ' kB -- (' +
           sm.heapUsed.toHuman(1024) + ' kB -> ' + em.heapUsed.toHuman(1024) + ' kB)\n\n';
  }

  var call_avg = usec;
  msg += '  -- ' + (call_avg / 1000) + ' ms avg per iteration --\n';

  process.stdout.write(msg);
}

var c = new LRUMap(N);

console.log('N = ' + N + ', Iterations = ' + Iterations);

// We should probably spin up the system in some way, or repeat the benchmarks a
// few times, since initial heap resizing takes considerable time.

measure(function(){
  // 1. put
  //    Simply append a new entry.
  //    There will be no reordering since we simply append to the tail.
  for (var i=N; --i;)
    c.set('key'+i, i);
});

measure(function(){
  // 2. get recent -> old
  //    Get entries starting with newest, effectively reversing the list.
  //
  // a. For each get, a find is first executed implemented as a native object with
  //    keys mapping to entries, so this should be reasonably fast as most native
  //    objects are implemented as hash maps.
  //
  // b. For each get, the aquired item will be moved to tail which includes a
  //    maximum of 7 assignment operations (minimum 3).
  for (var i=1,L=N+1; i<L; ++i)
    c.get('key'+i, i);
});


measure(function(){
  // 3. get old -> recent
  //    Get entries starting with oldest, effectively reversing the list.
  //
  //  - Same conditions apply as for test 2.
  for (var i=1,L=N+1; i<L; ++i)
    c.get('key'+i);
});

measure(function(){
  // 4. get missing
  //    Get try to get entries not in the cache.
  //  - Same conditions apply as for test 2, section a.
  for (var i=1,L=N+1; i<L; ++i)
    c.get('xkey'+i);
});

measure(function(){
  // 5. put overflow
  //    Overflow the cache with N more items than it can hold.
  // a. The complexity of put in this case should be:
  //    ( <get whith enough space> + <shift> )
  for (var i=N; --i;)
    c.set('key2_'+i, i);
});


measure(function(){
  // 6. shift head -> tail
  //    Remove all entries going from head to tail
  for (var i=1,L=N+1; i<L; ++i)
    c.shift();
});

measure(function(){
  // 7. put 
  //    Simply put N new items into an empty cache with exactly N space.
  for (var i=N; --i;)
    c.set('key'+i, i);
});

// pre-build random key array
var shuffledKeys = Array.from(c.keys());
shuffledKeys.sort(function (){return Math.random()-0.5; });

measure(function(){
  // 8. delete random
  // a. Most operations (which are not entries at head or tail) will cause closes
  //    siblings to be relinked.
  for (var i=shuffledKeys.length, key; key = shuffledKeys[--i]; ) {
    c.delete('key'+i, i);
  }
});
> lru_map@0.3.0 benchmark /src/js-lru
> node --expose-gc benchmark.js

N = 10000, Iterations = 1000

----------
  function (){
    // 1. put
    //    Simply append a new entry.
    //    There will be no reordering since we simply append to the tail.
    for (var i=N; --i;)
      c.set('key'+i, i);
  }
   rss:        +9,380 kB -- (19,564 kB -> 28,944 kB)
   heap total: +6,144 kB -- (11,260 kB -> 17,404 kB)
   heap used:  +1,640 kB -- (3,819 kB -> 5,459 kB)

  -- 1.192 ms avg per iteration --

----------
  function (){
    // 2. get recent -> old
    //    Get entries starting with newest, effectively reversing the list.
    //
    // a. For each get, a find is first executed implemented as a native object with
    //    keys mapping to entries, so this should be reasonably fast as most native
    //    objects are implemented as hash maps.
    //
    // b. For each get, the aquired item will be moved to tail which includes a
    //    maximum of 7 assignment operations (minimum 3).
    for (var i=1,L=N+1; i<L; ++i)
      c.get('key'+i, i);
  }
   rss:        +340 kB -- (29,112 kB -> 29,452 kB)
   heap total: +0 kB -- (18,428 kB -> 18,428 kB)
   heap used:  -255 kB -- (5,479 kB -> 5,224 kB)

  -- 1.197 ms avg per iteration --

----------
  function (){
    // 3. get old -> recent
    //    Get entries starting with oldest, effectively reversing the list.
    //
    //  - Same conditions apply as for test 2.
    for (var i=1,L=N+1; i<L; ++i)
      c.get('key'+i);
  }
   rss:        -344 kB -- (29,476 kB -> 29,132 kB)
   heap total: +0 kB -- (18,428 kB -> 18,428 kB)
   heap used:  +3 kB -- (5,211 kB -> 5,215 kB)

  -- 1.161 ms avg per iteration --

----------
  function (){
    // 4. get missing
    //    Get try to get entries not in the cache.
    //  - Same conditions apply as for test 2, section a.
    for (var i=1,L=N+1; i<L; ++i)
      c.get('xkey'+i);
  }
   rss:        +0 kB -- (29,132 kB -> 29,132 kB)
   heap total: +0 kB -- (18,428 kB -> 18,428 kB)
   heap used:  +5 kB -- (5,210 kB -> 5,215 kB)

  -- 1.035 ms avg per iteration --

----------
  function (){
    // 5. put overflow
    //    Overflow the cache with N more items than it can hold.
    // a. The complexity of put in this case should be:
    //    ( <get whith enough space> + <shift> )
    for (var i=N; --i;)
      c.set('key2_'+i, i);
  }
   rss:        +2,036 kB -- (29,132 kB -> 31,168 kB)
   heap total: +916 kB -- (18,428 kB -> 19,344 kB)
   heap used:  +542 kB -- (5,211 kB -> 5,752 kB)

  -- 1.185 ms avg per iteration --

----------
  function (){
    // 6. shift head -> tail
    //    Remove all entries going from head to tail
    for (var i=1,L=N+1; i<L; ++i)
      c.shift();
  }
   rss:        -1,528 kB -- (31,288 kB -> 29,760 kB)
   heap total: +108 kB -- (18,320 kB -> 18,428 kB)
   heap used:  -1,819 kB -- (5,748 kB -> 3,929 kB)

  -- 0.023 ms avg per iteration --

----------
  function (){
    // 7. put 
    //    Simply put N new items into an empty cache with exactly N space.
    for (var i=N; --i;)
      c.set('key'+i, i);
  }
   rss:        +8,064 kB -- (29,876 kB -> 37,940 kB)
   heap total: +8,192 kB -- (17,404 kB -> 25,596 kB)
   heap used:  +1,327 kB -- (3,904 kB -> 5,232 kB)

  -- 1.264 ms avg per iteration --

----------
  function (){
    // 8. delete random
    // a. Most operations (which are not entries at head or tail) will cause closes
    //    siblings to be relinked.
    for (var i=shuffledKeys.length, key; key = shuffledKeys[--i]; ) {
      c.delete('key'+i, i);
    }
  }
   rss:        +132 kB -- (38,088 kB -> 38,220 kB)
   heap total: +0 kB -- (25,596 kB -> 25,596 kB)
   heap used:  +410 kB -- (5,380 kB -> 5,789 kB)

  -- 1.914 ms avg per iteration --
<!DOCTYPE HTML>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>lru</title>
    <style type="text/css">

body {
  font-family:
    -apple-system,BlinkMacSystemFont,
    "Segoe UI",
    Roboto,
    Oxygen,
    Ubuntu,
    Cantarell,
    "Open Sans",
    "Helvetica Neue",
    sans-serif;
  letter-spacing:0;
  font-weight:400;
  font-style:normal;
  text-rendering:optimizeLegibility;
  -moz-font-feature-settings:"liga" on;
  background: white;
  color:rgba(0,0,0,.8);
  font-size:13px;
  line-height:1.4;
  margin:2em;
}

a { text-decoration:inherit; color: inherit; }
a:hover { color:#30C2FF; }
b { font-weight: 500; }

ul { list-style:none; }
li { line-height:1.4; }

h2 { font-size: 16px; font-weight:600; }

.log {
  background: rgba(0,0,0,0.05);
  white-space: pre-line;
  display: inline-block;
}

#out {
}

    </style>
    <!-- <script src="https://unpkg.com/amdld/amdld.min.js"></script> -->
    <script src="lru.js"></script>
  </head>
  <body>

    <h2>Expected results:</h2>
    <div class="log">adam:29 &lt; john:26 &lt; angela:24
adam:29 &lt; angela:24 &lt; john:26
angela:24 &lt; john:26 &lt; zorro:141
</div>

    <h2>Actual results:</h2>
    <div class="log" id="out"></div>

    <script>
const out = document.querySelector('#out')
function log(s) { out.innerText += s + '\n' }

let c = new LRUMap(3)
c.set('adam',   29)
c.set('john',   26)
c.set('angela', 24)
log(c.toString())        // -> "adam:29 < john:26 < angela:24"
c.get('john')       // -> 26

// Now 'john' is the most recently used entry, since we just requested it
log(c.toString())        // -> "adam:29 < angela:24 < john:26"
c.set('zorro', 141) // -> {key:adam, value:29}

// Because we only have room for 3 entries, adding 'zorro' caused 'adam'
// to be removed in order to make room for the new entry
log(c.toString())        // -> "angela:24 < john:26 < zorro:141"


// With AMDLD:
// define(['lru'], function(lru) {
//   let c = new lru.LRUMap(3)
//   // ...
// })

    </script>
  </body>
</html>
// An entry holds the key and value, and pointers to any older and newer entries.
interface Entry<K,V> {
  key   :K;
  value :V;
}

export class LRUMap<K,V> {
  // Construct a new cache object which will hold up to limit entries.
  // When the size == limit, a `put` operation will evict the oldest entry.
  //
  // If `entries` is provided, all entries are added to the new map.
  // `entries` should be an Array or other iterable object whose elements are
  // key-value pairs (2-element Arrays). Each key-value pair is added to the new Map.
  // null is treated as undefined.
  constructor(limit :number, entries? :Iterable<[K,V]>);

  // Convenience constructor equivalent to `new LRUMap(count(entries), entries)`
  constructor(entries :Iterable<[K,V]>);

  // Current number of items
  size :number;

  // Maximum number of items this map can hold
  limit :number;

  // Least recently-used entry. Invalidated when map is modified.
  oldest :Entry<K,V>;

  // Most recently-used entry. Invalidated when map is modified.
  newest :Entry<K,V>;

  // Replace all values in this map with key-value pairs (2-element Arrays) from
  // provided iterable.
  assign(entries :Iterable<[K,V]>) : void;

  // Put <value> into the cache associated with <key>. Replaces any existing entry
  // with the same key. Returns `this`.
  set(key :K, value :V) : LRUMap<K,V>;

  // Purge the least recently used (oldest) entry from the cache.
  // Returns the removed entry or undefined if the cache was empty.
  shift() : [K,V] | undefined;

  // Get and register recent use of <key>.
  // Returns the value associated with <key> or undefined if not in cache.
  get(key :K) : V | undefined;

  // Check if there's a value for key in the cache without registering recent use.
  has(key :K) : boolean;

  // Access value for <key> without registering recent use. Useful if you do not
  // want to chage the state of the map, but only "peek" at it.
  // Returns the value associated with <key> if found, or undefined if not found.
  find(key :K) : V | undefined;

  // Remove entry <key> from cache and return its value.
  // Returns the removed value, or undefined if not found.
  delete(key :K) : V | undefined;

  // Removes all entries
  clear() : void;

  // Returns an iterator over all keys, starting with the oldest.
  keys() : Iterator<K>;

  // Returns an iterator over all values, starting with the oldest.
  values() : Iterator<V>;

  // Returns an iterator over all entries, starting with the oldest.
  entries() : Iterator<[K,V]>;

  // Returns an iterator over all entries, starting with the oldest.
  [Symbol.iterator]() : Iterator<[K,V]>;

  // Call `fun` for each entry, starting with the oldest entry.
  forEach(fun :(value :V, key :K, m :LRUMap<K,V>)=>void, thisArg? :any) : void;

  // Returns an object suitable for JSON encoding
  toJSON() : Array<{key :K, value :V}>;

  // Returns a human-readable text representation
  toString() : string;
}
/**
 * A doubly linked list-based Least Recently Used (LRU) cache. Will keep most
 * recently used items while discarding least recently used items when its limit
 * is reached.
 *
 * Licensed under MIT. Copyright (c) 2010 Rasmus Andersson <http://hunch.se/>
 * See README.md for details.
 *
 * Illustration of the design:
 *
 *       entry             entry             entry             entry
 *       ______            ______            ______            ______
 *      | head |.newer => |      |.newer => |      |.newer => | tail |
 *      |  A   |          |  B   |          |  C   |          |  D   |
 *      |______| <= older.|______| <= older.|______| <= older.|______|
 *
 *  removed  <--  <--  <--  <--  <--  <--  <--  <--  <--  <--  <--  added
 */
(function(g,f){
  const e = typeof exports == 'object' ? exports : typeof g == 'object' ? g : {};
  f(e);
  if (typeof define == 'function' && define.amd) { define('lru', e); }
})(this, function(exports) {

const NEWER = Symbol('newer');
const OLDER = Symbol('older');

function LRUMap(limit, entries) {
  if (typeof limit !== 'number') {
    // called as (entries)
    entries = limit;
    limit = 0;
  }

  this.size = 0;
  this.limit = limit;
  this.oldest = this.newest = undefined;
  this._keymap = new Map();

  if (entries) {
    this.assign(entries);
    if (limit < 1) {
      this.limit = this.size;
    }
  }
}

exports.LRUMap = LRUMap;

function Entry(key, value) {
  this.key = key;
  this.value = value;
  this[NEWER] = undefined;
  this[OLDER] = undefined;
}


LRUMap.prototype._markEntryAsUsed = function(entry) {
  if (entry === this.newest) {
    // Already the most recenlty used entry, so no need to update the list
    return;
  }
  // HEAD--------------TAIL
  //   <.older   .newer>
  //  <--- add direction --
  //   A  B  C  <D>  E
  if (entry[NEWER]) {
    if (entry === this.oldest) {
      this.oldest = entry[NEWER];
    }
    entry[NEWER][OLDER] = entry[OLDER]; // C <-- E.
  }
  if (entry[OLDER]) {
    entry[OLDER][NEWER] = entry[NEWER]; // C. --> E
  }
  entry[NEWER] = undefined; // D --x
  entry[OLDER] = this.newest; // D. --> E
  if (this.newest) {
    this.newest[NEWER] = entry; // E. <-- D
  }
  this.newest = entry;
};

LRUMap.prototype.assign = function(entries) {
  let entry, limit = this.limit || Number.MAX_VALUE;
  this._keymap.clear();
  let it = entries[Symbol.iterator]();
  for (let itv = it.next(); !itv.done; itv = it.next()) {
    let e = new Entry(itv.value[0], itv.value[1]);
    this._keymap.set(e.key, e);
    if (!entry) {
      this.oldest = e;
    } else {
      entry[NEWER] = e;
      e[OLDER] = entry;
    }
    entry = e;
    if (limit-- == 0) {
      throw new Error('overflow');
    }
  }
  this.newest = entry;
  this.size = this._keymap.size;
};

LRUMap.prototype.get = function(key) {
  // First, find our cache entry
  var entry = this._keymap.get(key);
  if (!entry) return; // Not cached. Sorry.
  // As <key> was found in the cache, register it as being requested recently
  this._markEntryAsUsed(entry);
  return entry.value;
};

LRUMap.prototype.set = function(key, value) {
  var entry = this._keymap.get(key);

  if (entry) {
    // update existing
    entry.value = value;
    this._markEntryAsUsed(entry);
    return this;
  }

  // new entry
  this._keymap.set(key, (entry = new Entry(key, value)));

  if (this.newest) {
    // link previous tail to the new tail (entry)
    this.newest[NEWER] = entry;
    entry[OLDER] = this.newest;
  } else {
    // we're first in -- yay
    this.oldest = entry;
  }

  // add new entry to the end of the linked list -- it's now the freshest entry.
  this.newest = entry;
  ++this.size;
  if (this.size > this.limit) {
    // we hit the limit -- remove the head
    this.shift();
  }

  return this;
};

LRUMap.prototype.shift = function() {
  // todo: handle special case when limit == 1
  var entry = this.oldest;
  if (entry) {
    if (this.oldest[NEWER]) {
      // advance the list
      this.oldest = this.oldest[NEWER];
      this.oldest[OLDER] = undefined;
    } else {
      // the cache is exhausted
      this.oldest = undefined;
      this.newest = undefined;
    }
    // Remove last strong reference to <entry> and remove links from the purged
    // entry being returned:
    entry[NEWER] = entry[OLDER] = undefined;
    this._keymap.delete(entry.key);
    --this.size;
    return [entry.key, entry.value];
  }
};

// ----------------------------------------------------------------------------
// Following code is optional and can be removed without breaking the core
// functionality.

LRUMap.prototype.find = function(key) {
  let e = this._keymap.get(key);
  return e ? e.value : undefined;
};

LRUMap.prototype.has = function(key) {
  return this._keymap.has(key);
};

LRUMap.prototype['delete'] = function(key) {
  var entry = this._keymap.get(key);
  if (!entry) return;
  this._keymap.delete(entry.key);
  if (entry[NEWER] && entry[OLDER]) {
    // relink the older entry with the newer entry
    entry[OLDER][NEWER] = entry[NEWER];
    entry[NEWER][OLDER] = entry[OLDER];
  } else if (entry[NEWER]) {
    // remove the link to us
    entry[NEWER][OLDER] = undefined;
    // link the newer entry to head
    this.oldest = entry[NEWER];
  } else if (entry[OLDER]) {
    // remove the link to us
    entry[OLDER][NEWER] = undefined;
    // link the newer entry to head
    this.newest = entry[OLDER];
  } else {// if(entry[OLDER] === undefined && entry.newer === undefined) {
    this.oldest = this.newest = undefined;
  }

  this.size--;
  return entry.value;
};

LRUMap.prototype.clear = function() {
  // Not clearing links should be safe, as we don't expose live links to user
  this.oldest = this.newest = undefined;
  this.size = 0;
  this._keymap.clear();
};


function EntryIterator(oldestEntry) { this.entry = oldestEntry; }
EntryIterator.prototype[Symbol.iterator] = function() { return this; }
EntryIterator.prototype.next = function() {
  let ent = this.entry;
  if (ent) {
    this.entry = ent[NEWER];
    return { done: false, value: [ent.key, ent.value] };
  } else {
    return { done: true, value: undefined };
  }
};


function KeyIterator(oldestEntry) { this.entry = oldestEntry; }
KeyIterator.prototype[Symbol.iterator] = function() { return this; }
KeyIterator.prototype.next = function() {
  let ent = this.entry;
  if (ent) {
    this.entry = ent[NEWER];
    return { done: false, value: ent.key };
  } else {
    return { done: true, value: undefined };
  }
};

function ValueIterator(oldestEntry) { this.entry = oldestEntry; }
ValueIterator.prototype[Symbol.iterator] = function() { return this; }
ValueIterator.prototype.next = function() {
  let ent = this.entry;
  if (ent) {
    this.entry = ent[NEWER];
    return { done: false, value: ent.value };
  } else {
    return { done: true, value: undefined };
  }
};


LRUMap.prototype.keys = function() {
  return new KeyIterator(this.oldest);
};

LRUMap.prototype.values = function() {
  return new ValueIterator(this.oldest);
};

LRUMap.prototype.entries = function() {
  return this;
};

LRUMap.prototype[Symbol.iterator] = function() {
  return new EntryIterator(this.oldest);
};

LRUMap.prototype.forEach = function(fun, thisObj) {
  if (typeof thisObj !== 'object') {
    thisObj = this;
  }
  let entry = this.oldest;
  while (entry) {
    fun.call(thisObj, entry.value, entry.key, this);
    entry = entry[NEWER];
  }
};

/** Returns a JSON (array) representation */
LRUMap.prototype.toJSON = function() {
  var s = new Array(this.size), i = 0, entry = this.oldest;
  while (entry) {
    s[i++] = { key: entry.key, value: entry.value };
    entry = entry[NEWER];
  }
  return s;
};

/** Returns a String representation */
LRUMap.prototype.toString = function() {
  var s = '', entry = this.oldest;
  while (entry) {
    s += String(entry.key)+':'+entry.value;
    entry = entry[NEWER];
    if (entry) {
      s += ' < ';
    }
  }
  return s;
};

});
{
  "name": "lru_map",
  "version": "0.3.3",
  "description": "Finite key-value map using the Least Recently Used (LRU) algorithm where the most recently used objects are keept in the map while less recently used items are evicted to make room for new ones.",
  "main": "lru.js",
  "typings": "lru.d.ts",
  "scripts": {
    "test": "node test.js && echo 'Verifying TypeScript definition...' && tsc --noEmit",
    "prepublish": "npm test",
    "benchmark": "node --expose-gc benchmark.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/rsms/js-lru.git"
  },
  "keywords": [
    "cache",
    "lru",
    "buffer",
    "map"
  ],
  "author": "Rasmus Andersson <me@rsms.me>",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/rsms/js-lru/issues"
  },
  "homepage": "https://github.com/rsms/js-lru#readme",
  "devDependencies": {
    "typescript": "^2.0.10"
  }
}
# Least Recently Used (LRU) cache algorithm

A finite key-value map using the [Least Recently Used (LRU)](http://en.wikipedia.org/wiki/Cache_algorithms#Least_Recently_Used) algorithm, where the most recently-used items are "kept alive" while older, less-recently used items are evicted to make room for newer items.

Useful when you want to limit use of memory to only hold commonly-used things.

[![Build status](https://travis-ci.org/rsms/js-lru.svg?branch=master)](https://travis-ci.org/rsms/js-lru)

## Terminology & design

- Based on a doubly-linked list for low complexity random shuffling of entries.

- The cache object iself has a "head" (least recently used entry) and a
  "tail" (most recently used entry).

- The "oldest" and "newest" are list entries -- an entry might have a "newer" and
  an "older" entry (doubly-linked, "older" being close to "head" and "newer"
  being closer to "tail").

- Key lookup is done through a key-entry mapping native object, which on most 
  platforms mean `O(1)` complexity. This comes at a very low memory cost  (for 
  storing two extra pointers for each entry).

Fancy ASCII art illustration of the general design:

```txt
           entry             entry             entry             entry        
           ______            ______            ______            ______       
          | head |.newer => |      |.newer => |      |.newer => | tail |      
.oldest = |  A   |          |  B   |          |  C   |          |  D   | = .newest
          |______| <= older.|______| <= older.|______| <= older.|______|      
                                                                             
       removed  <--  <--  <--  <--  <--  <--  <--  <--  <--  <--  <--  added
```

## Example

```js
let c = new LRUMap(3)
c.set('adam',   29)
c.set('john',   26)
c.set('angela', 24)
c.toString()        // -> "adam:29 < john:26 < angela:24"
c.get('john')       // -> 26

// Now 'john' is the most recently used entry, since we just requested it
c.toString()        // -> "adam:29 < angela:24 < john:26"
c.set('zorro', 141) // -> {key:adam, value:29}

// Because we only have room for 3 entries, adding 'zorro' caused 'adam'
// to be removed in order to make room for the new entry
c.toString()        // -> "angela:24 < john:26 < zorro:141"
```

# Usage

**Recommended:** Copy the code in lru.js or copy the lru.js and lru.d.ts files into your source directory. For minimal functionality, you only need the lines up until the comment that says "Following code is optional".

**Using NPM:** [`yarn add lru_map`](https://www.npmjs.com/package/lru_map) (note that because NPM is one large flat namespace, you need to import the module as "lru_map" rather than simply "lru".)

**Using AMD:** An [AMD](https://github.com/amdjs/amdjs-api/blob/master/AMD.md#amd) module loader like [`amdld`](https://github.com/rsms/js-amdld) can be used to load this module as well. There should be nothing to configure.

**Testing**:

- Run tests with `npm test`
- Run benchmarks with `npm run benchmark`

**ES compatibility:** This implementation is compatible with modern JavaScript environments and depend on the following features not found in ES5:

- `const` and `let` keywords
- `Symbol` including `Symbol.iterator`
- `Map`

> Note: If you need ES5 compatibility e.g. to use with older browsers, [please use version 2](https://github.com/rsms/js-lru/tree/v2) which has a slightly less feature-full API but is well-tested and about as fast as this implementation.

**Using with TypeScript**

This module comes with complete typing coverage for use with TypeScript. If you copied the code or files rather than using a module loader, make sure to include `lru.d.ts` into the same location where you put `lru.js`.

```ts
import {LRUMap} from './lru'
// import {LRUMap} from 'lru'     // when using via AMD
// import {LRUMap} from 'lru_map' // when using from NPM
console.log('LRUMap:', LRUMap)
```

# API

The API imitates that of [`Map`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map), which means that in most cases you can use `LRUMap` as a drop-in replacement for `Map`.

```ts
export class LRUMap<K,V> {
  // Construct a new cache object which will hold up to limit entries.
  // When the size == limit, a `put` operation will evict the oldest entry.
  //
  // If `entries` is provided, all entries are added to the new map.
  // `entries` should be an Array or other iterable object whose elements are
  // key-value pairs (2-element Arrays). Each key-value pair is added to the new Map.
  // null is treated as undefined.
  constructor(limit :number, entries? :Iterable<[K,V]>);

  // Convenience constructor equivalent to `new LRUMap(count(entries), entries)`
  constructor(entries :Iterable<[K,V]>);

  // Current number of items
  size :number;

  // Maximum number of items this map can hold
  limit :number;

  // Least recently-used entry. Invalidated when map is modified.
  oldest :Entry<K,V>;

  // Most recently-used entry. Invalidated when map is modified.
  newest :Entry<K,V>;

  // Replace all values in this map with key-value pairs (2-element Arrays) from
  // provided iterable.
  assign(entries :Iterable<[K,V]>) : void;

  // Put <value> into the cache associated with <key>. Replaces any existing entry
  // with the same key. Returns `this`.
  set(key :K, value :V) : LRUMap<K,V>;

  // Purge the least recently used (oldest) entry from the cache.
  // Returns the removed entry or undefined if the cache was empty.
  shift() : [K,V] | undefined;

  // Get and register recent use of <key>.
  // Returns the value associated with <key> or undefined if not in cache.
  get(key :K) : V | undefined;

  // Check if there's a value for key in the cache without registering recent use.
  has(key :K) : boolean;

  // Access value for <key> without registering recent use. Useful if you do not
  // want to chage the state of the map, but only "peek" at it.
  // Returns the value associated with <key> if found, or undefined if not found.
  find(key :K) : V | undefined;

  // Remove entry <key> from cache and return its value.
  // Returns the removed value, or undefined if not found.
  delete(key :K) : V | undefined;

  // Removes all entries
  clear() : void;

  // Returns an iterator over all keys, starting with the oldest.
  keys() : Iterator<K>;

  // Returns an iterator over all values, starting with the oldest.
  values() : Iterator<V>;

  // Returns an iterator over all entries, starting with the oldest.
  entries() : Iterator<[K,V]>;

  // Returns an iterator over all entries, starting with the oldest.
  [Symbol.iterator]() : Iterator<[K,V]>;

  // Call `fun` for each entry, starting with the oldest entry.
  forEach(fun :(value :V, key :K, m :LRUMap<K,V>)=>void, thisArg? :any) : void;

  // Returns an object suitable for JSON encoding
  toJSON() : Array<{key :K, value :V}>;

  // Returns a human-readable text representation
  toString() : string;
}

// An entry holds the key and value, and pointers to any older and newer entries.
// Entries might hold references to adjacent entries in the internal linked-list.
// Therefore you should never store or modify Entry objects. Instead, reference the
// key and value of an entry when needed.
interface Entry<K,V> {
  key   :K;
  value :V;
}
```

If you need to perform any form of finalization of items as they are evicted from the cache, wrapping the `shift` method is a good way to do it:

```js
let c = new LRUMap(123);
c.shift = function() {
  let entry = LRUMap.prototype.shift.call(this);
  doSomethingWith(entry);
  return entry;
}
```

The internals calls `shift` as entries need to be evicted, so this method is guaranteed to be called for any item that's removed from the cache. The returned entry must not include any strong references to other entries. See note in the documentation of `LRUMap.prototype.set()`.


# MIT license

Copyright (c) 2010-2016 Rasmus Andersson <https://rsms.me/>

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
// Test which will run in nodejs
// $ node test.js
// (Might work with other CommonJS-compatible environments)
const assert = require('assert');
const LRUMap = require('./lru').LRUMap;
const asserteq = assert.equal;
const tests = {

['set and get']() {
  let c = new LRUMap(4);
  asserteq(c.size, 0);
  asserteq(c.limit, 4);
  asserteq(c.oldest, undefined);
  asserteq(c.newest, undefined);

  c.set('adam',   29)
   .set('john',   26)
   .set('angela', 24)
   .set('bob',    48);
  asserteq(c.toString(), 'adam:29 < john:26 < angela:24 < bob:48');
  asserteq(c.size, 4);

  asserteq(c.get('adam'), 29);
  asserteq(c.get('john'), 26);
  asserteq(c.get('angela'), 24);
  asserteq(c.get('bob'), 48);
  asserteq(c.toString(), 'adam:29 < john:26 < angela:24 < bob:48');

  asserteq(c.get('angela'), 24);
  asserteq(c.toString(), 'adam:29 < john:26 < bob:48 < angela:24');

  c.set('ygwie', 81);
  asserteq(c.toString(), 'john:26 < bob:48 < angela:24 < ygwie:81');
  asserteq(c.size, 4);
  asserteq(c.get('adam'), undefined);

  c.set('john', 11);
  asserteq(c.toString(), 'bob:48 < angela:24 < ygwie:81 < john:11');
  asserteq(c.get('john'), 11);

  let expectedKeys = ['bob', 'angela', 'ygwie', 'john'];
  c.forEach(function(v, k) {
    //sys.sets(k+': '+v);
    asserteq(k, expectedKeys.shift());
  })

  // removing one item decrements size by one
  let currentSize = c.size;
  assert(c.delete('john') !== undefined);
  asserteq(currentSize - 1, c.size);
},

['construct with iterator']() {
  let verifyEntries = function(c) {
    asserteq(c.size, 4);
    asserteq(c.limit, 4);
    asserteq(c.oldest.key, 'adam');
    asserteq(c.newest.key, 'bob');
    asserteq(c.get('adam'), 29);
    asserteq(c.get('john'), 26);
    asserteq(c.get('angela'), 24);
    asserteq(c.get('bob'), 48);
  };

  // with explicit limit
  verifyEntries(new LRUMap(4, [
    ['adam',   29],
    ['john',   26],
    ['angela', 24],
    ['bob',    48],
  ]));

  // with inferred limit
  verifyEntries(new LRUMap([
    ['adam',   29],
    ['john',   26],
    ['angela', 24],
    ['bob',    48],
  ]));
},

assign() {
  let c = new LRUMap([
    ['adam',   29],
    ['john',   26],
    ['angela', 24],
    ['bob',    48],
  ]);

  let newEntries = [
    ['mimi',    1],
    ['patrick', 2],
    ['jane',    3],
    ['fred',    4],
  ];
  c.assign(newEntries);
  asserteq(c.size, 4);
  asserteq(c.limit, 4);
  asserteq(c.oldest.key, newEntries[0][0]);
  asserteq(c.newest.key, newEntries[newEntries.length-1][0]);
  let i = 0;
  c.forEach(function(v, k) {
    asserteq(k, newEntries[i][0]);
    asserteq(v, newEntries[i][1]);
    i++;
  });

  // assigning too many items should throw an exception
  assert.throws(() => {
    c.assign([
      ['adam',   29],
      ['john',   26],
      ['angela', 24],
      ['bob',    48],
      ['ken',    30],
    ]);
  }, /overflow/);

  // assigning less than limit should not affect limit but adjust size
  c.assign([
    ['adam',   29],
    ['john',   26],
    ['angela', 24],
  ]);
  asserteq(c.size, 3);
  asserteq(c.limit, 4);
},

delete() {
  let c = new LRUMap([
    ['adam',   29],
    ['john',   26],
    ['angela', 24],
    ['bob',    48],
  ]);
  c.delete('adam');
  asserteq(c.size, 3);
  c.delete('angela');
  asserteq(c.size, 2);
  c.delete('bob');
  asserteq(c.size, 1);
  c.delete('john');
  asserteq(c.size, 0);
  asserteq(c.oldest, undefined);
  asserteq(c.newest, undefined);
},

clear() {
  let c = new LRUMap(4);
  c.set('adam', 29);
  c.set('john', 26);
  asserteq(c.size, 2);
  c.clear();
  asserteq(c.size, 0);
  asserteq(c.oldest, undefined);
  asserteq(c.newest, undefined);
},

shift() {
  let c2 = new LRUMap(4);
  asserteq(c2.size, 0);
  c2.set('a', 1)
  c2.set('b', 2)
  c2.set('c', 3)
  asserteq(c2.size, 3);

  let e = c2.shift();
  asserteq(e[0], 'a');
  asserteq(e[1], 1);
  
  e = c2.shift();
  asserteq(e[0], 'b');
  asserteq(e[1], 2);
  
  e = c2.shift();
  asserteq(e[0], 'c');
  asserteq(e[1], 3);

  // c2 should be empty
  c2.forEach(function () { assert(false); });
  asserteq(c2.size, 0);
},

set() {
  // Note: v0.1 allows putting same key multiple times. v0.2 does not.
  c = new LRUMap(4);
  c.set('a', 1);
  c.set('a', 2);
  c.set('a', 3);
  c.set('a', 4);
  asserteq(c.size, 1);
  asserteq(c.newest, c.oldest);
  assert.deepEqual(c.newest, {key:'a', value:4 });

  c.set('a', 5);
  asserteq(c.size, 1);
  asserteq(c.newest, c.oldest);
  assert.deepEqual(c.newest, {key:'a', value:5 });

  c.set('b', 6);
  asserteq(c.size, 2);
  assert(c.newest !== c.oldest);

  assert.deepEqual(c.newest, { key:'b', value:6 });
  assert.deepEqual(c.oldest, { key:'a', value:5 });

  c.shift();
  asserteq(c.size, 1);
  c.shift();
  asserteq(c.size, 0);
  c.forEach(function(){ assert(false) });
},


['entry iterator']() {
  let c = new LRUMap(4, [
    ['adam',   29],
    ['john',   26],
    ['angela', 24],
    ['bob',    48],
  ]);

  let verifyEntries = function(iterable) {
    asserteq(typeof iterable[Symbol.iterator], 'function');
    let it = iterable[Symbol.iterator]();
    assert.deepEqual(it.next().value, ['adam',   29]);
    assert.deepEqual(it.next().value, ['john',   26]);
    assert.deepEqual(it.next().value, ['angela', 24]);
    assert.deepEqual(it.next().value, ['bob',    48]);
    assert(it.next().done);
  };

  verifyEntries(c);
  verifyEntries(c.entries());
},


['key iterator']() {
  let c = new LRUMap(4, [
    ['adam',   29],
    ['john',   26],
    ['angela', 24],
    ['bob',    48],
  ]);
  let kit = c.keys();
  asserteq(kit.next().value, 'adam');
  asserteq(kit.next().value, 'john');
  asserteq(kit.next().value, 'angela');
  asserteq(kit.next().value, 'bob');
  assert(kit.next().done);
},


['value iterator']() {
  let c = new LRUMap(4, [
    ['adam',   29],
    ['john',   26],
    ['angela', 24],
    ['bob',    48],
  ]);
  let kit = c.values();
  asserteq(kit.next().value, 29);
  asserteq(kit.next().value, 26);
  asserteq(kit.next().value, 24);
  asserteq(kit.next().value, 48);
  assert(kit.next().done);
},


toJSON() {
  let c = new LRUMap(4, [
    ['adam',   29],
    ['john',   26],
    ['angela', 24],
    ['bob',    48],
  ]);
  let json = c.toJSON();
  assert(json.length == 4);
  assert.deepEqual(json, [
    {key:'adam', value:29},
    {key:'john', value:26},
    {key:'angela', value:24},
    {key:'bob', value:48},
  ]);
},


}; // tests


function fmttime(t) {
  return (Math.round((t)*10)/10)+'ms';
}

function die(err) {
  console.error('\n' + (err.stack || err));
  process.exit(1);
}

function runNextTest(tests, testNames, allDoneCallback) {
  let testName = testNames[0];
  if (!testName) {
    return allDoneCallback();
  }
  process.stdout.write(testName+' ... ');
  let t1 = Date.now();
  let next = function() {
    t1 = Date.now() - t1;
    if (t1 > 10) {
      process.stdout.write('ok ('+fmttime(t1)+')\n');
    } else {
      process.stdout.write('ok\n');
    }
    runNextTest(tests, testNames.slice(1), allDoneCallback);
  };
  try {
    let p = tests[testName]();
    if (p && p instanceof Promise) {
      p.then(next).catch(die);
    } else {
      next();
    }
  } catch (err) {
    die(err);
  }
}

let t = Date.now();
runNextTest(tests, Object.keys(tests), function() {
  t = Date.now() - t;
  let timestr = '';
  if (t > 10) {
    timestr = '(' + fmttime(t) + ')';
  }
  console.log(`${Object.keys(tests).length} tests passed ${timestr}`);
});
{
  "compilerOptions": {
    "module": "commonjs",
    "target": "es6",
    "noImplicitAny": false,
    "sourceMap": false,
    "lib": [
      "es6",
      "dom"
    ],
    "pretty": true
  },
  "files": [
    "tstest.ts"
  ]
}import {LRUMap} from './lru'

let m = new LRUMap<string, number>(3);
let entit = m.entries();
let k : string = entit.next().value[0];
let v : number = entit.next().value[1];
{
  "application/1d-interleaved-parityfec": {
    "source": "iana"
  },
  "application/3gpdash-qoe-report+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/3gpp-ims+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/3gpphal+json": {
    "source": "iana",
    "compressible": true
  },
  "application/3gpphalforms+json": {
    "source": "iana",
    "compressible": true
  },
  "application/a2l": {
    "source": "iana"
  },
  "application/activemessage": {
    "source": "iana"
  },
  "application/activity+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-costmap+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-costmapfilter+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-directory+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-endpointcost+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-endpointcostparams+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-endpointprop+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-endpointpropparams+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-error+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-networkmap+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-networkmapfilter+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-updatestreamcontrol+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-updatestreamparams+json": {
    "source": "iana",
    "compressible": true
  },
  "application/aml": {
    "source": "iana"
  },
  "application/andrew-inset": {
    "source": "iana",
    "extensions": ["ez"]
  },
  "application/applefile": {
    "source": "iana"
  },
  "application/applixware": {
    "source": "apache",
    "extensions": ["aw"]
  },
  "application/atf": {
    "source": "iana"
  },
  "application/atfx": {
    "source": "iana"
  },
  "application/atom+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["atom"]
  },
  "application/atomcat+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["atomcat"]
  },
  "application/atomdeleted+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["atomdeleted"]
  },
  "application/atomicmail": {
    "source": "iana"
  },
  "application/atomsvc+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["atomsvc"]
  },
  "application/atsc-dwd+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["dwd"]
  },
  "application/atsc-dynamic-event-message": {
    "source": "iana"
  },
  "application/atsc-held+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["held"]
  },
  "application/atsc-rdt+json": {
    "source": "iana",
    "compressible": true
  },
  "application/atsc-rsat+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["rsat"]
  },
  "application/atxml": {
    "source": "iana"
  },
  "application/auth-policy+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/bacnet-xdd+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/batch-smtp": {
    "source": "iana"
  },
  "application/bdoc": {
    "compressible": false,
    "extensions": ["bdoc"]
  },
  "application/beep+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/calendar+json": {
    "source": "iana",
    "compressible": true
  },
  "application/calendar+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xcs"]
  },
  "application/call-completion": {
    "source": "iana"
  },
  "application/cals-1840": {
    "source": "iana"
  },
  "application/captive+json": {
    "source": "iana",
    "compressible": true
  },
  "application/cbor": {
    "source": "iana"
  },
  "application/cbor-seq": {
    "source": "iana"
  },
  "application/cccex": {
    "source": "iana"
  },
  "application/ccmp+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/ccxml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["ccxml"]
  },
  "application/cdfx+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["cdfx"]
  },
  "application/cdmi-capability": {
    "source": "iana",
    "extensions": ["cdmia"]
  },
  "application/cdmi-container": {
    "source": "iana",
    "extensions": ["cdmic"]
  },
  "application/cdmi-domain": {
    "source": "iana",
    "extensions": ["cdmid"]
  },
  "application/cdmi-object": {
    "source": "iana",
    "extensions": ["cdmio"]
  },
  "application/cdmi-queue": {
    "source": "iana",
    "extensions": ["cdmiq"]
  },
  "application/cdni": {
    "source": "iana"
  },
  "application/cea": {
    "source": "iana"
  },
  "application/cea-2018+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/cellml+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/cfw": {
    "source": "iana"
  },
  "application/clr": {
    "source": "iana"
  },
  "application/clue+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/clue_info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/cms": {
    "source": "iana"
  },
  "application/cnrp+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/coap-group+json": {
    "source": "iana",
    "compressible": true
  },
  "application/coap-payload": {
    "source": "iana"
  },
  "application/commonground": {
    "source": "iana"
  },
  "application/conference-info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/cose": {
    "source": "iana"
  },
  "application/cose-key": {
    "source": "iana"
  },
  "application/cose-key-set": {
    "source": "iana"
  },
  "application/cpl+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/csrattrs": {
    "source": "iana"
  },
  "application/csta+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/cstadata+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/csvm+json": {
    "source": "iana",
    "compressible": true
  },
  "application/cu-seeme": {
    "source": "apache",
    "extensions": ["cu"]
  },
  "application/cwt": {
    "source": "iana"
  },
  "application/cybercash": {
    "source": "iana"
  },
  "application/dart": {
    "compressible": true
  },
  "application/dash+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["mpd"]
  },
  "application/dashdelta": {
    "source": "iana"
  },
  "application/davmount+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["davmount"]
  },
  "application/dca-rft": {
    "source": "iana"
  },
  "application/dcd": {
    "source": "iana"
  },
  "application/dec-dx": {
    "source": "iana"
  },
  "application/dialog-info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/dicom": {
    "source": "iana"
  },
  "application/dicom+json": {
    "source": "iana",
    "compressible": true
  },
  "application/dicom+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/dii": {
    "source": "iana"
  },
  "application/dit": {
    "source": "iana"
  },
  "application/dns": {
    "source": "iana"
  },
  "application/dns+json": {
    "source": "iana",
    "compressible": true
  },
  "application/dns-message": {
    "source": "iana"
  },
  "application/docbook+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["dbk"]
  },
  "application/dots+cbor": {
    "source": "iana"
  },
  "application/dskpp+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/dssc+der": {
    "source": "iana",
    "extensions": ["dssc"]
  },
  "application/dssc+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xdssc"]
  },
  "application/dvcs": {
    "source": "iana"
  },
  "application/ecmascript": {
    "source": "iana",
    "compressible": true,
    "extensions": ["es","ecma"]
  },
  "application/edi-consent": {
    "source": "iana"
  },
  "application/edi-x12": {
    "source": "iana",
    "compressible": false
  },
  "application/edifact": {
    "source": "iana",
    "compressible": false
  },
  "application/efi": {
    "source": "iana"
  },
  "application/elm+json": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/elm+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/emergencycalldata.cap+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/emergencycalldata.comment+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/emergencycalldata.control+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/emergencycalldata.deviceinfo+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/emergencycalldata.ecall.msd": {
    "source": "iana"
  },
  "application/emergencycalldata.providerinfo+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/emergencycalldata.serviceinfo+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/emergencycalldata.subscriberinfo+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/emergencycalldata.veds+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/emma+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["emma"]
  },
  "application/emotionml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["emotionml"]
  },
  "application/encaprtp": {
    "source": "iana"
  },
  "application/epp+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/epub+zip": {
    "source": "iana",
    "compressible": false,
    "extensions": ["epub"]
  },
  "application/eshop": {
    "source": "iana"
  },
  "application/exi": {
    "source": "iana",
    "extensions": ["exi"]
  },
  "application/expect-ct-report+json": {
    "source": "iana",
    "compressible": true
  },
  "application/fastinfoset": {
    "source": "iana"
  },
  "application/fastsoap": {
    "source": "iana"
  },
  "application/fdt+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["fdt"]
  },
  "application/fhir+json": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/fhir+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/fido.trusted-apps+json": {
    "compressible": true
  },
  "application/fits": {
    "source": "iana"
  },
  "application/flexfec": {
    "source": "iana"
  },
  "application/font-sfnt": {
    "source": "iana"
  },
  "application/font-tdpfr": {
    "source": "iana",
    "extensions": ["pfr"]
  },
  "application/font-woff": {
    "source": "iana",
    "compressible": false
  },
  "application/framework-attributes+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/geo+json": {
    "source": "iana",
    "compressible": true,
    "extensions": ["geojson"]
  },
  "application/geo+json-seq": {
    "source": "iana"
  },
  "application/geopackage+sqlite3": {
    "source": "iana"
  },
  "application/geoxacml+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/gltf-buffer": {
    "source": "iana"
  },
  "application/gml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["gml"]
  },
  "application/gpx+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["gpx"]
  },
  "application/gxf": {
    "source": "apache",
    "extensions": ["gxf"]
  },
  "application/gzip": {
    "source": "iana",
    "compressible": false,
    "extensions": ["gz"]
  },
  "application/h224": {
    "source": "iana"
  },
  "application/held+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/hjson": {
    "extensions": ["hjson"]
  },
  "application/http": {
    "source": "iana"
  },
  "application/hyperstudio": {
    "source": "iana",
    "extensions": ["stk"]
  },
  "application/ibe-key-request+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/ibe-pkg-reply+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/ibe-pp-data": {
    "source": "iana"
  },
  "application/iges": {
    "source": "iana"
  },
  "application/im-iscomposing+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/index": {
    "source": "iana"
  },
  "application/index.cmd": {
    "source": "iana"
  },
  "application/index.obj": {
    "source": "iana"
  },
  "application/index.response": {
    "source": "iana"
  },
  "application/index.vnd": {
    "source": "iana"
  },
  "application/inkml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["ink","inkml"]
  },
  "application/iotp": {
    "source": "iana"
  },
  "application/ipfix": {
    "source": "iana",
    "extensions": ["ipfix"]
  },
  "application/ipp": {
    "source": "iana"
  },
  "application/isup": {
    "source": "iana"
  },
  "application/its+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["its"]
  },
  "application/java-archive": {
    "source": "apache",
    "compressible": false,
    "extensions": ["jar","war","ear"]
  },
  "application/java-serialized-object": {
    "source": "apache",
    "compressible": false,
    "extensions": ["ser"]
  },
  "application/java-vm": {
    "source": "apache",
    "compressible": false,
    "extensions": ["class"]
  },
