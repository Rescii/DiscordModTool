import "core-js/modules/es.object.keys.js";
import "core-js/modules/es.symbol.js";
import "core-js/modules/es.array.filter.js";
import "core-js/modules/es.object.get-own-property-descriptor.js";
import "core-js/modules/web.dom-collections.for-each.js";
import "core-js/modules/es.object.get-own-property-descriptors.js";
import _toArray from "@babel/runtime/helpers/toArray";
import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _newArrowCheck from "@babel/runtime/helpers/newArrowCheck";
import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _regeneratorRuntime from "@babel/runtime/regenerator";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

import "core-js/modules/es.array.concat.js";
import "core-js/modules/es.object.to-string.js";
import "core-js/modules/es.regexp.to-string.js";
import "core-js/modules/es.array.find.js";
import "core-js/modules/es.array.index-of.js";
import "core-js/modules/es.array.join.js";
import "core-js/modules/es.object.entries.js";
import "core-js/modules/es.string.match.js";
import "core-js/modules/es.regexp.exec.js";
import "core-js/modules/es.array.sort.js";
import "core-js/modules/es.array.map.js";
import "core-js/modules/es.string.replace.js";
import "core-js/modules/es.array.slice.js";
import "core-js/modules/es.promise.js";
import Sigar from 'node-sigar';
import execa from 'execa';
import fs from 'fs-extra';
import ora from 'ora';
import path from 'path';
import which from 'which';
import { v4 as uuidv4 } from 'uuid';
var COMMAND = '([{<COMMAND>}])';
var spinner = ora();
var sigar = new Sigar();
export var defaultOptions = {
  commandTemplate: COMMAND,
  cwd: process.cwd(),
  terminals: {
    darwin: [['osascript', '-e', "tell app \"Terminal\" to do script \"".concat(COMMAND, "\"")]],
    linux: [['gnome-terminal', '--', 'sh', '-c', COMMAND], ['xterm', '-e', "sh -c \"".concat(COMMAND, "\"")], ['konsole', '-e', "sh -c \"".concat(COMMAND, "\"")], ['terminator', '-u', '-e', "sh -c \"".concat(COMMAND, "\"")]]
  }
};

function getDefaultTerminalCommand() {
  return _getDefaultTerminalCommand.apply(this, arguments);
}

function _getDefaultTerminalCommand() {
  _getDefaultTerminalCommand = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
    var _ref3, REGEX, terminalPath, command;

    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.prev = 0;
            REGEX = /[^/]+$/g;
            _context.t0 = fs;
            _context.next = 5;
            return which('x-terminal-emulator');

          case 5:
            _context.t1 = _context.sent;
            _context.next = 8;
            return _context.t0.realpath.call(_context.t0, _context.t1);

          case 8:
            terminalPath = _context.sent;
            command = (_ref3 = _toConsumableArray(terminalPath.match(REGEX) || [])) === null || _ref3 === void 0 ? void 0 : _ref3[0];
            return _context.abrupt("return", command);

          case 13:
            _context.prev = 13;
            _context.t2 = _context["catch"](0);

            if (!(_context.t2.message.indexOf('not found') > -1)) {
              _context.next = 17;
              break;
            }

            return _context.abrupt("return", undefined);

          case 17:
            throw _context.t2;

          case 18:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[0, 13]]);
  }));
  return _getDefaultTerminalCommand.apply(this, arguments);
}

function createSafeCommand(uid, command) {
  if (process.platform === 'darwin') {
    command = "cd ".concat(process.cwd(), " && ").concat(command);
  }

  return "node ".concat(path.resolve(__dirname, '../lib/shb64'), " ").concat(Buffer.from(command).toString('base64'), " open-terminal:uid:").concat(uid);
}

function hasTerminal(_x) {
  return _hasTerminal.apply(this, arguments);
}

function _hasTerminal() {
  _hasTerminal = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(terminal) {
    var command;
    return _regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            command = Array.isArray(terminal) ? (terminal === null || terminal === void 0 ? void 0 : terminal[0]) || '' : terminal;
            _context2.prev = 1;
            _context2.next = 4;
            return which(command);

          case 4:
            return _context2.abrupt("return", true);

          case 7:
            _context2.prev = 7;
            _context2.t0 = _context2["catch"](1);

            if (!(_context2.t0.message.indexOf('not found') > -1)) {
              _context2.next = 11;
              break;
            }

            return _context2.abrupt("return", false);

          case 11:
            throw _context2.t0;

          case 12:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[1, 7]]);
  }));
  return _hasTerminal.apply(this, arguments);
}

export default function openTerminal(_x2, _x3) {
  return _openTerminal.apply(this, arguments);
}

function _openTerminal() {
  _openTerminal = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(command, options) {
    return _regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            return _context3.abrupt("return", openDefaultTerminal(command, options));

          case 1:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _openTerminal.apply(this, arguments);
}

function openDefaultTerminal(_x4, _x5, _x6) {
  return _openDefaultTerminal.apply(this, arguments);
}

function _openDefaultTerminal() {
  _openDefaultTerminal = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(command, options, _terminals) {
    var _this5 = this;

    var _i,
        uid,
        fullOptions,
        terminals,
        defaultTerminalCommand,
        safeCommand,
        terminal,
        result,
        error,
        _args4 = arguments;

    return _regeneratorRuntime.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _i = _args4.length > 3 && _args4[3] !== undefined ? _args4[3] : 0;
            uid = uuidv4();
            fullOptions = mergeDefaults(options);

            if (_terminals) {
              _context4.next = 11;
              break;
            }

            terminals = fullOptions.terminals[process.platform];

            if (terminals) {
              _context4.next = 7;
              break;
            }

            throw new Error("operating system ".concat(process.platform, " not supported"));

          case 7:
            _context4.next = 9;
            return getDefaultTerminalCommand();

          case 9:
            defaultTerminalCommand = _context4.sent;
            _terminals = terminals.sort(function (a) {
              _newArrowCheck(this, _this5);

              if ((a[0] || '').indexOf(defaultTerminalCommand || '') > -1) return -1;
              return 1;
            }.bind(this));

          case 11:
            safeCommand = createSafeCommand(uid, (Array.isArray(command) ? command : [command]).join(' '));
            terminal = _terminals[_i];

            if (terminal) {
              _context4.next = 19;
              break;
            }

            spinner.warn("running process in background because terminal could not be found\ntry installing on of the following terminals to run correctly: ".concat(_terminals.map(function (terminal) {
              _newArrowCheck(this, _this5);

              return terminal[0];
            }.bind(this)).join(', '), "\n"));
            _context4.next = 17;
            return execa(safeCommand, {
              cwd: fullOptions.cwd,
              shell: true,
              stdio: 'inherit'
            });

          case 17:
            result = _context4.sent;
            return _context4.abrupt("return", result);

          case 19:
            _context4.next = 21;
            return hasTerminal(terminal);

          case 21:
            if (_context4.sent) {
              _context4.next = 23;
              break;
            }

            return _context4.abrupt("return", openDefaultTerminal(command, options, _terminals, ++_i));

          case 23:
            _context4.prev = 23;
            _context4.next = 26;
            return tryOpenTerminal(uid, terminal, safeCommand, fullOptions);

          case 26:
            return _context4.abrupt("return", process.exit());

          case 29:
            _context4.prev = 29;
            _context4.t0 = _context4["catch"](23);
            error = _context4.t0;

            if (!(error.command && error.failed)) {
              _context4.next = 34;
              break;
            }

            return _context4.abrupt("return", openDefaultTerminal(command, options, _terminals, ++_i));

          case 34:
            throw _context4.t0;

          case 35:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, this, [[23, 29]]);
  }));
  return _openDefaultTerminal.apply(this, arguments);
}

function tryOpenTerminal(_x7, _x8, _x9, _x10) {
  return _tryOpenTerminal.apply(this, arguments);
}

function _tryOpenTerminal() {
  _tryOpenTerminal = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(uid, terminal, command, options) {
    var _this6 = this;

    var _mergeDefaults, commandTemplate, cwd, _terminal, cmd, _terminal$map, _terminal$map2, args, p, result;

    return _regeneratorRuntime.wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            _mergeDefaults = mergeDefaults(options), commandTemplate = _mergeDefaults.commandTemplate, cwd = _mergeDefaults.cwd;
            _terminal = _slicedToArray(terminal, 1), cmd = _terminal[0];

            if (cmd) {
              _context5.next = 4;
              break;
            }

            throw new Error("terminal ".concat(terminal[0], " not found"));

          case 4:
            _terminal$map = terminal.map(function (arg) {
              _newArrowCheck(this, _this6);

              return arg.replace(commandTemplate, Array.isArray(command) ? command.join(' ') : command);
            }.bind(this)), _terminal$map2 = _toArray(_terminal$map), args = _terminal$map2.slice(1);
            p = execa(cmd, args, {
              stdio: 'inherit',
              cwd: cwd
            });
            _context5.next = 8;
            return new Promise(function (r) {
              _newArrowCheck(this, _this6);

              return setTimeout(r, 1000);
            }.bind(this));

          case 8:
            _context5.next = 10;
            return waitOnTerminal(uid);

          case 10:
            _context5.next = 12;
            return p;

          case 12:
            result = _context5.sent;
            process.on('SIGINT', function () {
              _newArrowCheck(this, _this6);

              var pid = uidToPid(uid);
              if (pid) process.kill(pid);
              process.exit();
            }.bind(this));
            process.on('SIGTERM', function () {
              _newArrowCheck(this, _this6);

              var pid = uidToPid(uid);
              if (pid) process.kill(pid);
              process.exit();
            }.bind(this));
            return _context5.abrupt("return", result);

          case 16:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5, this);
  }));
  return _tryOpenTerminal.apply(this, arguments);
}

function uidToPid(uid) {
  var _this = this;

  return sigar.procList.find(function (pid) {
    _newArrowCheck(this, _this);

    return sigar.getProcArgs(pid).join(' ').indexOf(uid) > -1;
  }.bind(this));
}

function waitOnTerminal(_x11) {
  return _waitOnTerminal.apply(this, arguments);
}

function _waitOnTerminal() {
  _waitOnTerminal = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(uid) {
    var _this7 = this;

    var pollInterval,
        timeout,
        pid,
        _args6 = arguments;
    return _regeneratorRuntime.wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            pollInterval = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : 3000;
            timeout = _args6.length > 2 ? _args6[2] : undefined;
            _context6.next = 4;
            return new Promise(function (r) {
              _newArrowCheck(this, _this7);

              return setTimeout(r, pollInterval);
            }.bind(this));

          case 4:
            pid = uidToPid(uid);

            if (pid) {
              _context6.next = 7;
              break;
            }

            return _context6.abrupt("return", undefined);

          case 7:
            return _context6.abrupt("return", waitOnTerminal(uid, timeout, typeof timeout === 'undefined' ? timeout : timeout - pollInterval));

          case 8:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6, this);
  }));
  return _waitOnTerminal.apply(this, arguments);
}

function mergeDefaults(options) {
  var _this2 = this;

  return _objectSpread(_objectSpread(_objectSpread({}, defaultOptions), options || {}), {}, {
    terminals: _objectSpread(_objectSpread({}, defaultOptions.terminals), Object.entries((options === null || options === void 0 ? void 0 : options.terminals) || {}).reduce(function (osTerminals, _ref) {
      var _this3 = this;

      _newArrowCheck(this, _this2);

      var _ref2 = _slicedToArray(_ref, 2),
          os = _ref2[0],
          terminals = _ref2[1];

      osTerminals[os] = (terminals || []).reduce(function (terminals, terminal) {
        var _this4 = this;

        _newArrowCheck(this, _this3);

        if (!terminals.find(function (existingTerminal) {
          _newArrowCheck(this, _this4);

          return existingTerminal[0] === terminal[0];
        }.bind(this))) {
          terminals.push(terminal);
        }

        return terminals;
      }.bind(this), []);
      return osTerminals;
    }.bind(this), {}))
  });
}

export * from "./types";
//# sourceMappingURL=index.js.map